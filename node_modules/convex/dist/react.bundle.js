"use strict";
var convex = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // external-global-plugin:react
  var require_react = __commonJS({
    "external-global-plugin:react"(exports, module) {
      module.exports = window.React;
    }
  });

  // external-global-plugin:react-dom
  var require_react_dom = __commonJS({
    "external-global-plugin:react-dom"(exports, module) {
      module.exports = window.ReactDOM;
    }
  });

  // src/react/index.ts
  var react_exports = {};
  __export(react_exports, {
    AuthLoading: () => AuthLoading,
    Authenticated: () => Authenticated,
    ConvexProvider: () => ConvexProvider,
    ConvexProviderWithAuth: () => ConvexProviderWithAuth,
    ConvexReactClient: () => ConvexReactClient,
    Unauthenticated: () => Unauthenticated,
    optimisticallyUpdateValueInPaginatedQuery: () => optimisticallyUpdateValueInPaginatedQuery,
    useActionGeneric: () => useActionGeneric,
    useConvexAuth: () => useConvexAuth,
    useConvexGeneric: () => useConvexGeneric,
    useMutationGeneric: () => useMutationGeneric,
    usePaginatedQueryGeneric: () => usePaginatedQueryGeneric,
    useQueriesGeneric: () => useQueriesGeneric,
    useQueryGeneric: () => useQueryGeneric,
    useSubscription: () => useSubscription
  });

  // src/react/use_paginated_query.ts
  var import_react4 = __toESM(require_react());

  // src/values/base64.ts
  var base64_exports = {};
  __export(base64_exports, {
    byteLength: () => byteLength,
    fromByteArray: () => fromByteArray,
    toByteArray: () => toByteArray
  });
  var lookup = [];
  var revLookup = [];
  var Arr = Uint8Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(_b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i,
          i + maxChunkLength > len2 ? len2 : i + maxChunkLength
        )
      );
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }

  // src/common/index.ts
  function parseArgs(args) {
    if (args === void 0) {
      return {};
    }
    if (!isSimpleObject(args)) {
      throw new Error(
        `The arguments to a Convex function must be an object. Received: ${args}`
      );
    }
    return args;
  }
  function isSimpleObject(value) {
    const isObject = typeof value === "object";
    const prototype = Object.getPrototypeOf(value);
    const isSimple = prototype === null || prototype === Object.prototype || prototype?.constructor?.name === "Object";
    return isObject && isSimple;
  }

  // src/values/value.ts
  var LITTLE_ENDIAN = true;
  var MIN_INT64 = BigInt("-9223372036854775808");
  var MAX_INT64 = BigInt("9223372036854775807");
  var ZERO = BigInt("0");
  var EIGHT = BigInt("8");
  var TWOFIFTYSIX = BigInt("256");
  var Id = class {
    constructor(tableName, id) {
      this.tableName = tableName;
      this.id = id;
    }
    equals(other) {
      if (other instanceof Id) {
        return this.tableName === other.tableName && this.id === other.id;
      }
      return false;
    }
    static fromJSON(obj) {
      if (typeof obj.$id !== "string") {
        throw new Error(
          `Object ${JSON.stringify(obj)} isn't a valid Id: $id isn't a string.`
        );
      }
      const parts = obj.$id.split("|");
      if (parts.length !== 2) {
        throw new Error(
          `Object ${JSON.stringify(obj)} isn't a valid Id: Wrong number of parts.`
        );
      }
      return new Id(parts[0], parts[1]);
    }
    toJSON() {
      const idString = `${this.tableName}|${this.id}`;
      return { $id: idString };
    }
    toString() {
      return this.id;
    }
    inspect() {
      return `Id('${this.tableName}', '${this.id}')`;
    }
  };
  function isSpecial(n2) {
    return Number.isNaN(n2) || !Number.isFinite(n2) || Object.is(n2, -0);
  }
  function slowBigIntToBase64(value) {
    if (value < ZERO) {
      value -= MIN_INT64 + MIN_INT64;
    }
    let hex = value.toString(16);
    if (hex.length % 2 === 1)
      hex = "0" + hex;
    const bytes = new Uint8Array(new ArrayBuffer(8));
    let i = 0;
    for (const hexByte of hex.match(/.{2}/g).reverse()) {
      bytes.set([parseInt(hexByte, 16)], i++);
      value >>= EIGHT;
    }
    return fromByteArray(bytes);
  }
  function slowBase64ToBigInt(encoded) {
    const integerBytes = toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
      throw new Error(
        `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`
      );
    }
    let value = ZERO;
    let power = ZERO;
    for (const byte of integerBytes) {
      value += BigInt(byte) * TWOFIFTYSIX ** power;
      power++;
    }
    if (value > MAX_INT64) {
      value += MIN_INT64 + MIN_INT64;
    }
    return value;
  }
  function modernBigIntToBase64(value) {
    if (value < MIN_INT64 || MAX_INT64 < value) {
      throw new Error(
        `BigInt ${value} does not fit into a 64-bit signed integer.`
      );
    }
    const buffer = new ArrayBuffer(8);
    new DataView(buffer).setBigInt64(0, value, true);
    return fromByteArray(new Uint8Array(buffer));
  }
  function modernBase64ToBigInt(encoded) {
    const integerBytes = toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
      throw new Error(
        `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`
      );
    }
    const intBytesView = new DataView(integerBytes.buffer);
    return intBytesView.getBigInt64(0, true);
  }
  var bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;
  var base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;
  var MAX_IDENTIFIER_LEN = 64;
  var ALL_UNDERSCORES = /^_+$/;
  var IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;
  function validateObjectField(k) {
    if (k.length === 0) {
      throw new Error("Empty field names are disallowed.");
    }
    if (k.length > MAX_IDENTIFIER_LEN) {
      throw new Error(
        `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`
      );
    }
    if (k.startsWith("$")) {
      throw new Error(`Field name ${k} starts with a '$', which is reserved.`);
    }
    if (ALL_UNDERSCORES.test(k)) {
      throw new Error(`Field name ${k} can't exclusively be underscores.`);
    }
    if (!IDENTIFIER_REGEX.test(k)) {
      throw new Error(
        `Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`
      );
    }
  }
  function jsonToConvexInternal(value) {
    if (value === null) {
      return value;
    }
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(jsonToConvexInternal);
    }
    if (typeof value !== "object") {
      throw new Error(`Unexpected type of ${value}`);
    }
    const entries = Object.entries(value);
    if (entries.length === 1) {
      const key = entries[0][0];
      if (key === "$id" || key === "$weakRef" || key === "$strongRef") {
        return Id.fromJSON(value);
      }
      if (key === "$bytes") {
        if (typeof value.$bytes !== "string") {
          throw new Error(`Malformed $bytes field on ${value}`);
        }
        return toByteArray(value.$bytes).buffer;
      }
      if (key === "$integer") {
        if (typeof value.$integer !== "string") {
          throw new Error(`Malformed $integer field on ${value}`);
        }
        return base64ToBigInt(value.$integer);
      }
      if (key === "$float") {
        if (typeof value.$float !== "string") {
          throw new Error(`Malformed $float field on ${value}`);
        }
        const floatBytes = toByteArray(value.$float);
        if (floatBytes.byteLength !== 8) {
          throw new Error(
            `Received ${floatBytes.byteLength} bytes, expected 8 for $float`
          );
        }
        const floatBytesView = new DataView(floatBytes.buffer);
        const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);
        if (!isSpecial(float)) {
          throw new Error(`Float ${float} should be encoded as a number`);
        }
        return float;
      }
      if (key === "$set") {
        if (!Array.isArray(value.$set)) {
          throw new Error(`Malformed $set field on ${value}`);
        }
        return new Set(value.$set.map(jsonToConvexInternal));
      }
      if (key === "$map") {
        if (!Array.isArray(value.$map)) {
          throw new Error(`Malformed $map field on ${value}`);
        }
        const map = /* @__PURE__ */ new Map();
        for (const pair of value.$map) {
          if (!Array.isArray(pair) || pair.length !== 2) {
            throw new Error(`Malformed pair in $map ${value}`);
          }
          const k = jsonToConvexInternal(pair[0]);
          const v = jsonToConvexInternal(pair[1]);
          map.set(k, v);
        }
        return map;
      }
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
      validateObjectField(k);
      out[k] = jsonToConvexInternal(v);
    }
    return out;
  }
  function jsonToConvex(value) {
    return jsonToConvexInternal(value);
  }
  function stringifyValueForError(value) {
    return JSON.stringify(value, (_key, value2) => {
      if (value2 === void 0) {
        return "undefined";
      }
      if (typeof value2 === "bigint") {
        return `${value2.toString()}n`;
      }
      return value2;
    });
  }
  function convexToJsonInternal(value, originalValue, context) {
    if (value === void 0) {
      const contextText = context && ` (present at path ${context} in original object ${stringifyValueForError(
        originalValue
      )})`;
      throw new Error(
        `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`
      );
    }
    if (value === null) {
      return value;
    }
    if (value instanceof Id) {
      return value.toJSON();
    }
    if (typeof value === "bigint") {
      if (value < MIN_INT64 || MAX_INT64 < value) {
        throw new Error(
          `BigInt ${value} does not fit into a 64-bit signed integer.`
        );
      }
      return { $integer: bigIntToBase64(value) };
    }
    if (typeof value === "number") {
      if (isSpecial(value)) {
        const buffer = new ArrayBuffer(8);
        new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);
        return { $float: fromByteArray(new Uint8Array(buffer)) };
      } else {
        return value;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      return value;
    }
    if (value instanceof ArrayBuffer) {
      return { $bytes: fromByteArray(new Uint8Array(value)) };
    }
    if (Array.isArray(value)) {
      return value.map(
        (value2, i) => convexToJsonInternal(value2, originalValue, context + `[${i}]`)
      );
    }
    if (value instanceof Set) {
      return {
        $set: [...value].map(
          (value2, i) => convexToJsonInternal(value2, originalValue, context + `.keys()[${i}]`)
        )
      };
    }
    if (value instanceof Map) {
      return {
        $map: [...value].map(([k, v], i) => {
          const jsonKey = convexToJsonInternal(
            k,
            originalValue,
            context + `.keys()[${i}]`
          );
          const jsonValue = convexToJsonInternal(
            v,
            originalValue,
            context + `.values()[${i}]`
          );
          return [jsonKey, jsonValue];
        })
      };
    }
    if (!isSimpleObject(value)) {
      const theType = value?.constructor?.name;
      const typeMsg = theType ? `${theType} ` : "";
      if (context) {
        throw new Error(
          `${typeMsg}${stringifyValueForError(
            value
          )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(
            originalValue
          )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`
        );
      } else {
        throw new Error(
          `${typeMsg}${stringifyValueForError(
            value
          )} is not a supported Convex type.`
        );
      }
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
      if (v !== void 0) {
        validateObjectField(k);
        out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);
      }
    }
    return out;
  }
  function convexToJson(value) {
    return convexToJsonInternal(value, value, "");
  }

  // src/react/use_queries.ts
  var import_react3 = __toESM(require_react());

  // src/index.ts
  var version = "0.14.0";

  // src/browser/logging.ts
  var INFO_COLOR = "color:rgb(0, 145, 255)";
  function prefix_for_source(source) {
    switch (source) {
      case "query":
        return "Q";
      case "mutation":
        return "M";
      case "action":
        return "A";
    }
  }
  function logToConsole(type, source, udfPath, message) {
    const prefix = prefix_for_source(source);
    if (type === "info") {
      console.log(`%c[CONVEX ${prefix}(${udfPath})] ${message}`, INFO_COLOR);
    } else {
      console.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
    }
  }
  function logFatalError(message) {
    const errorMessage = `[CONVEX FATAL ERROR] ${message}`;
    console.error(errorMessage);
    return new Error(errorMessage);
  }
  function createError(source, udfPath, message) {
    const prefix = prefix_for_source(source);
    return new Error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
  }

  // src/browser/sync/udf_path_utils.ts
  function canonicalizeUdfPath(udfPath) {
    const pieces = udfPath.split(":");
    let moduleName;
    let functionName;
    if (pieces.length === 1) {
      moduleName = pieces[0];
      functionName = "default";
    } else {
      moduleName = pieces.slice(0, pieces.length - 1).join(":");
      functionName = pieces[pieces.length - 1];
    }
    if (!moduleName.endsWith(".js")) {
      moduleName = `${moduleName}.js`;
    }
    return `${moduleName}:${functionName}`;
  }
  function serializePathAndArgs(udfPath, args) {
    return JSON.stringify({
      udfPath: canonicalizeUdfPath(udfPath),
      args: convexToJson(args)
    });
  }

  // src/browser/sync/local_state.ts
  var LocalSyncState = class {
    constructor() {
      this.nextQueryId = 0;
      this.querySetVersion = 0;
      this.identityVersion = 0;
      this.querySet = /* @__PURE__ */ new Map();
      this.queryIdToToken = /* @__PURE__ */ new Map();
    }
    subscribe(udfPath, args, journal) {
      const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
      const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
      const existingEntry = this.querySet.get(queryToken);
      if (existingEntry !== void 0) {
        existingEntry.numSubscribers += 1;
        return {
          queryToken,
          modification: null,
          unsubscribe: () => this.removeSubscriber(queryToken)
        };
      } else {
        const queryId = this.nextQueryId++;
        const query = {
          id: queryId,
          canonicalizedUdfPath,
          args,
          numSubscribers: 1,
          journal
        };
        this.querySet.set(queryToken, query);
        this.queryIdToToken.set(queryId, queryToken);
        const baseVersion = this.querySetVersion;
        const newVersion = ++this.querySetVersion;
        const add = {
          type: "Add",
          queryId,
          udfPath: canonicalizedUdfPath,
          args: [convexToJson(args)],
          journal
        };
        const modification = {
          type: "ModifyQuerySet",
          baseVersion,
          newVersion,
          modifications: [add]
        };
        return {
          queryToken,
          modification,
          unsubscribe: () => this.removeSubscriber(queryToken)
        };
      }
    }
    saveQueryJournals(transition) {
      for (const modification of transition.modifications) {
        switch (modification.type) {
          case "QueryUpdated":
          case "QueryFailed": {
            const journal = modification.journal;
            if (journal !== void 0) {
              const queryToken = this.queryIdToToken.get(modification.queryId);
              if (queryToken !== void 0) {
                this.querySet.get(queryToken).journal = journal;
              }
            }
            break;
          }
          case "QueryRemoved": {
            break;
          }
          default: {
            const _ = modification;
            throw new Error(`Invalid modification ${modification}`);
          }
        }
      }
    }
    queryId(udfPath, args) {
      const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
      const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
      const existingEntry = this.querySet.get(queryToken);
      if (existingEntry !== void 0) {
        return existingEntry.id;
      }
      return null;
    }
    isCurrentOrNewerAuthVersion(version2) {
      return version2 >= this.identityVersion;
    }
    setAuth(value) {
      this.auth = {
        tokenType: "User",
        value
      };
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        baseVersion,
        ...this.auth
      };
    }
    setAdminAuth(value, actingAs) {
      const auth = {
        tokenType: "Admin",
        value,
        impersonating: actingAs
      };
      this.auth = auth;
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        baseVersion,
        ...auth
      };
    }
    clearAuth() {
      this.auth = void 0;
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        tokenType: "None",
        baseVersion
      };
    }
    hasAuth() {
      return !!this.auth;
    }
    isNewAuth(value) {
      return this.auth?.value !== value;
    }
    queryPath(queryId) {
      const pathAndArgs = this.queryIdToToken.get(queryId);
      if (pathAndArgs) {
        return this.querySet.get(pathAndArgs).canonicalizedUdfPath;
      }
      return null;
    }
    queryArgs(queryId) {
      const pathAndArgs = this.queryIdToToken.get(queryId);
      if (pathAndArgs) {
        return this.querySet.get(pathAndArgs).args;
      }
      return null;
    }
    queryToken(queryId) {
      return this.queryIdToToken.get(queryId) ?? null;
    }
    queryJournal(queryToken) {
      return this.querySet.get(queryToken)?.journal;
    }
    restart() {
      const modifications = [];
      for (const localQuery of this.querySet.values()) {
        const add = {
          type: "Add",
          queryId: localQuery.id,
          udfPath: localQuery.canonicalizedUdfPath,
          args: [convexToJson(localQuery.args)],
          journal: localQuery.journal
        };
        modifications.push(add);
      }
      this.querySetVersion = 1;
      const querySet = {
        type: "ModifyQuerySet",
        baseVersion: 0,
        newVersion: 1,
        modifications
      };
      if (!this.auth) {
        this.identityVersion = 0;
        return [querySet, void 0];
      }
      const authenticate = {
        type: "Authenticate",
        baseVersion: 0,
        ...this.auth
      };
      this.identityVersion = 1;
      return [querySet, authenticate];
    }
    removeSubscriber(queryToken) {
      const localQuery = this.querySet.get(queryToken);
      if (localQuery.numSubscribers > 1) {
        localQuery.numSubscribers -= 1;
        return null;
      } else {
        this.querySet.delete(queryToken);
        this.queryIdToToken.delete(localQuery.id);
        const baseVersion = this.querySetVersion;
        const newVersion = ++this.querySetVersion;
        const remove = {
          type: "Remove",
          queryId: localQuery.id
        };
        return {
          type: "ModifyQuerySet",
          baseVersion,
          newVersion,
          modifications: [remove]
        };
      }
    }
  };

  // src/browser/sync/request_manager.ts
  var RequestManager = class {
    constructor() {
      this.inflightRequests = /* @__PURE__ */ new Map();
      this._timeOfOldestInflightRequest = null;
    }
    request(message, sent) {
      const result = new Promise((resolve) => {
        const status = sent ? "Requested" : "NotSent";
        this.inflightRequests.set(message.requestId, {
          message,
          status: { status, requestedAt: new Date(), onResult: resolve }
        });
      });
      return result;
    }
    onResponse(response) {
      const requestInfo = this.inflightRequests.get(response.requestId);
      if (requestInfo === void 0) {
        return null;
      }
      if (requestInfo.status.status === "Completed") {
        return null;
      }
      const udfType = requestInfo.message.type === "Mutation" ? "mutation" : "action";
      const udfPath = requestInfo.message.udfPath;
      for (const line of response.logLines) {
        logToConsole("info", udfType, udfPath, line);
      }
      const status = requestInfo.status;
      let onResolve;
      if (response.success) {
        onResolve = () => status.onResult({
          success: true,
          logLines: response.logLines,
          value: jsonToConvex(response.result)
        });
      } else {
        logToConsole("error", udfType, udfPath, response.result);
        onResolve = () => status.onResult({
          success: false,
          errorMessage: response.result,
          logLines: response.logLines
        });
      }
      if (response.type === "ActionResponse" || !response.success) {
        onResolve();
        this.inflightRequests.delete(response.requestId);
        return response.requestId;
      }
      requestInfo.status = {
        status: "Completed",
        ts: response.ts,
        onResolve
      };
      return null;
    }
    removeCompleted(ts) {
      const completeRequests = /* @__PURE__ */ new Set();
      for (const [requestId, requestInfo] of this.inflightRequests.entries()) {
        const status = requestInfo.status;
        if (status.status === "Completed" && status.ts.lessThanOrEqual(ts)) {
          status.onResolve();
          completeRequests.add(requestId);
          this.inflightRequests.delete(requestId);
        }
      }
      return completeRequests;
    }
    restart() {
      const allMessages = [];
      for (const [requestId, value] of this.inflightRequests) {
        if (value.status.status === "NotSent") {
          value.status.status = "Requested";
          allMessages.push(value.message);
          continue;
        }
        if (value.message.type === "Mutation") {
          allMessages.push(value.message);
        } else {
          this.inflightRequests.delete(requestId);
          if (value.status.status === "Completed") {
            throw new Error("Action should never be in 'Completed' state");
          }
          value.status.onResult({
            success: false,
            errorMessage: "Connection lost while action was in flight",
            logLines: []
          });
        }
      }
      return allMessages;
    }
    hasIncompleteRequests() {
      for (const requestInfo of this.inflightRequests.values()) {
        if (requestInfo.status.status === "Requested") {
          return true;
        }
      }
      return false;
    }
    hasInflightRequests() {
      return this.inflightRequests.size > 0;
    }
    timeOfOldestInflightRequest() {
      if (this.inflightRequests.size === 0) {
        return null;
      }
      let oldestInflightRequest = Date.now();
      for (const request of this.inflightRequests.values()) {
        if (request.status.status !== "Completed") {
          if (request.status.requestedAt.getTime() < oldestInflightRequest) {
            oldestInflightRequest = request.status.requestedAt.getTime();
          }
        }
      }
      return new Date(oldestInflightRequest);
    }
  };

  // src/browser/sync/optimistic_updates_impl.ts
  var OptimisticLocalStoreImpl = class {
    constructor(queryResults) {
      this.queryResults = queryResults;
      this.modifiedQueries = [];
    }
    getQuery(name, args) {
      const queryArgs = parseArgs(args);
      const query = this.queryResults.get(serializePathAndArgs(name, queryArgs));
      if (query === void 0) {
        return void 0;
      }
      return OptimisticLocalStoreImpl.queryValue(query.result);
    }
    getAllQueries(name) {
      const queriesWithName = [];
      for (const query of this.queryResults.values()) {
        if (query.udfPath === canonicalizeUdfPath(name)) {
          queriesWithName.push({
            args: query.args,
            value: OptimisticLocalStoreImpl.queryValue(query.result)
          });
        }
      }
      return queriesWithName;
    }
    setQuery(name, args, value) {
      const queryToken = serializePathAndArgs(name, args);
      let result;
      if (value === void 0) {
        result = void 0;
      } else {
        result = {
          success: true,
          value,
          logLines: []
        };
      }
      const query = {
        udfPath: name,
        args,
        result
      };
      this.queryResults.set(queryToken, query);
      this.modifiedQueries.push(queryToken);
    }
    static queryValue(result) {
      if (result === void 0) {
        return void 0;
      } else if (result.success) {
        return result.value;
      } else {
        return void 0;
      }
    }
  };
  var OptimisticQueryResults = class {
    constructor() {
      this.queryResults = /* @__PURE__ */ new Map();
      this.optimisticUpdates = [];
    }
    ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {
      this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId) => {
        return !optimisticUpdatesToDrop.has(updateAndId.mutationId);
      });
      const oldQueryResults = this.queryResults;
      this.queryResults = new Map(serverQueryResults);
      const localStore = new OptimisticLocalStoreImpl(this.queryResults);
      for (const updateAndId of this.optimisticUpdates) {
        updateAndId.update(localStore);
      }
      const changedQueries = [];
      for (const [queryToken, query] of this.queryResults) {
        const oldQuery = oldQueryResults.get(queryToken);
        if (oldQuery === void 0 || oldQuery.result !== query.result) {
          changedQueries.push(queryToken);
        }
      }
      return changedQueries;
    }
    applyOptimisticUpdate(update, mutationId) {
      this.optimisticUpdates.push({
        update,
        mutationId
      });
      const localStore = new OptimisticLocalStoreImpl(this.queryResults);
      update(localStore);
      return localStore.modifiedQueries;
    }
    queryResult(queryToken) {
      const query = this.queryResults.get(queryToken);
      if (query === void 0) {
        return void 0;
      }
      const result = query.result;
      if (result === void 0) {
        return void 0;
      } else if (result.success) {
        return result.value;
      } else {
        throw createError("query", query.udfPath, result.errorMessage);
      }
    }
    queryLogs(queryToken) {
      const query = this.queryResults.get(queryToken);
      return query?.result?.logLines;
    }
  };

  // src/browser/long.ts
  var Long = class {
    static isLong(obj) {
      return (obj && obj.__isUnsignedLong__) === true;
    }
    constructor(low, high) {
      this.low = low | 0;
      this.high = high | 0;
      this.__isUnsignedLong__ = true;
    }
    static fromBytesLE(bytes) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24
      );
    }
    toBytesLE() {
      const hi = this.high;
      const lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    static fromNumber(value) {
      if (isNaN(value))
        return UZERO;
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
      return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    notEquals(other) {
      return !this.equals(other);
    }
    comp(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.equals(other))
        return 0;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    static fromValue(val) {
      if (typeof val === "number")
        return Long.fromNumber(val);
      return new Long(val.low, val.high);
    }
  };
  var UZERO = new Long(0, 0);
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var MAX_UNSIGNED_VALUE = new Long(4294967295 | 0, 4294967295 | 0);

  // src/browser/sync/remote_query_set.ts
  var RemoteQuerySet = class {
    constructor(queryPath) {
      this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };
      this.remoteQuerySet = /* @__PURE__ */ new Map();
      this.queryPath = queryPath;
    }
    transition(transition) {
      const start = transition.startVersion;
      if (this.version.querySet !== start.querySet || this.version.ts.notEquals(start.ts) || this.version.identity !== start.identity) {
        throw new Error(`Invalid start version: ${start.ts}:${start.querySet}`);
      }
      for (const modification of transition.modifications) {
        switch (modification.type) {
          case "QueryUpdated": {
            const queryPath = this.queryPath(modification.queryId);
            if (queryPath) {
              for (const line of modification.logLines) {
                logToConsole("info", "query", queryPath, line);
              }
            }
            const value = jsonToConvex(modification.value ?? null);
            this.remoteQuerySet.set(modification.queryId, {
              success: true,
              value,
              logLines: modification.logLines
            });
            break;
          }
          case "QueryFailed": {
            const queryPath = this.queryPath(modification.queryId);
            if (queryPath) {
              for (const line of modification.logLines) {
                logToConsole("info", "query", queryPath, line);
              }
            }
            this.remoteQuerySet.set(modification.queryId, {
              success: false,
              errorMessage: modification.errorMessage,
              logLines: modification.logLines
            });
            break;
          }
          case "QueryRemoved": {
            this.remoteQuerySet.delete(modification.queryId);
            break;
          }
          default: {
            const _ = modification;
            throw new Error(`Invalid modification ${modification}`);
          }
        }
      }
      this.version = transition.endVersion;
    }
    remoteQueryResults() {
      return this.remoteQuerySet;
    }
    timestamp() {
      return this.version.ts;
    }
  };

  // src/browser/sync/protocol.ts
  function u64ToLong(encoded) {
    const integerBytes = base64_exports.toByteArray(encoded);
    return Long.fromBytesLE(Array.from(integerBytes));
  }
  function parseServerMessage(encoded) {
    switch (encoded.type) {
      case "FatalError":
      case "AuthError":
      case "ActionResponse":
      case "Ping": {
        return { ...encoded };
      }
      case "MutationResponse": {
        if (encoded.success) {
          return { ...encoded, ts: u64ToLong(encoded.ts) };
        } else {
          return { ...encoded };
        }
      }
      case "Transition": {
        return {
          ...encoded,
          startVersion: {
            ...encoded.startVersion,
            ts: u64ToLong(encoded.startVersion.ts)
          },
          endVersion: {
            ...encoded.endVersion,
            ts: u64ToLong(encoded.endVersion.ts)
          }
        };
      }
      default: {
        const _exhaustivenessCheck = encoded;
      }
    }
    return void 0;
  }

  // src/browser/sync/web_socket_manager.ts
  var CLOSE_NORMAL = 1e3;
  var CLOSE_GOING_AWAY = 1001;
  var CLOSE_NO_STATUS = 1005;
  var CLOSE_NOT_FOUND = 4040;
  function promisePair() {
    let resolvePromise;
    const promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    return { promise, resolve: resolvePromise };
  }
  var WebSocketManager = class {
    constructor(uri, onOpen, onMessage, webSocketConstructor, verbose) {
      this.webSocketConstructor = webSocketConstructor;
      this.socket = { state: "disconnected" };
      this.connectionCount = 0;
      this.lastCloseReason = "InitialConnect";
      this.initialBackoff = 100;
      this.maxBackoff = 16e3;
      this.retries = 0;
      this.serverInactivityThreshold = 3e4;
      this.reconnectDueToServerInactivityTimeout = null;
      this.uri = uri;
      this.onOpen = onOpen;
      this.onMessage = onMessage;
      this.verbose = verbose;
      void this.connect();
    }
    async connect() {
      if (this.socket.state === "closing" || this.socket.state === "stopping" || this.socket.state === "stopped") {
        return;
      }
      if (this.socket.state !== "disconnected" && this.socket.state !== "paused") {
        throw new Error(
          "Didn't start connection from disconnected state: " + this.socket.state
        );
      }
      const ws = new this.webSocketConstructor(this.uri);
      this._logVerbose("constructed WebSocket");
      this.socket = {
        state: "connecting",
        ws
      };
      ws.onopen = () => {
        this._logVerbose("begin ws.onopen");
        if (this.socket.state !== "connecting") {
          throw new Error("onopen called with socket not in connecting state");
        }
        this.socket = { state: "ready", ws };
        this.onServerActivity();
        this.onOpen({
          connectionCount: this.connectionCount,
          lastCloseReason: this.lastCloseReason
        });
        if (this.lastCloseReason !== "InitialConnect") {
          console.log("WebSocket reconnected");
        }
        this.connectionCount += 1;
        this.lastCloseReason = null;
      };
      ws.onerror = (error) => {
        const message = error.message;
        console.log(`WebSocket error: ${message}`);
        this.closeAndReconnect("WebSocketError");
      };
      ws.onmessage = (message) => {
        this.retries = 0;
        this.onServerActivity();
        const serverMessage = parseServerMessage(JSON.parse(message.data));
        this._logVerbose(`received ws message with type ${serverMessage.type}`);
        this.onMessage(serverMessage);
      };
      ws.onclose = (event) => {
        this._logVerbose("begin ws.onclose");
        if (this.lastCloseReason === null) {
          this.lastCloseReason = event.reason ?? "OnCloseInvoked";
        }
        if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY && event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {
          let msg = `WebSocket closed unexpectedly with code ${event.code}`;
          if (event.reason) {
            msg += `: ${event.reason}`;
          }
          console.error(msg);
        }
        if (this.socket.state === "stopping") {
          this.socket.promisePair.resolve(null);
          this.socket = { state: "stopped" };
          return;
        }
        if (this.socket.state === "pausing") {
          this.socket.promisePair.resolve(null);
          this.socket = { state: "paused" };
          return;
        }
        this.socket = { state: "disconnected" };
        const backoff = this.nextBackoff();
        console.log(`Attempting reconnect in ${backoff}ms`);
        setTimeout(() => this.connect(), backoff);
      };
    }
    socketState() {
      return this.socket.state;
    }
    sendMessage(message) {
      this._logVerbose(`sending message with type ${message.type}`);
      if (this.socket.state === "ready") {
        const request = JSON.stringify(message);
        try {
          this.socket.ws.send(request);
        } catch (error) {
          console.log(
            `Failed to send message on WebSocket, reconnecting: ${error}`
          );
          this.closeAndReconnect("FailedToSendMessage");
        }
        return true;
      }
      return false;
    }
    onServerActivity() {
      if (this.reconnectDueToServerInactivityTimeout !== null) {
        clearTimeout(this.reconnectDueToServerInactivityTimeout);
        this.reconnectDueToServerInactivityTimeout = null;
      }
      this.reconnectDueToServerInactivityTimeout = setTimeout(() => {
        this.closeAndReconnect("InactiveServer");
      }, this.serverInactivityThreshold);
    }
    closeAndReconnect(closeReason) {
      this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);
      switch (this.socket.state) {
        case "disconnected":
        case "closing":
        case "stopping":
        case "stopped":
        case "pausing":
        case "paused":
          return;
        case "connecting":
        case "ready":
          this.lastCloseReason = closeReason;
          this.socket.ws.close();
          this.socket = {
            state: "closing",
            ws: this.socket.ws
          };
          this._logVerbose("ws.close called");
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    async stop() {
      if (this.reconnectDueToServerInactivityTimeout) {
        clearTimeout(this.reconnectDueToServerInactivityTimeout);
      }
      switch (this.socket.state) {
        case "stopped":
          return;
        case "connecting":
        case "ready":
          this.socket.ws.close();
          this.socket = {
            state: "stopping",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "pausing":
        case "closing":
          this.socket = {
            state: "stopping",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "paused":
        case "disconnected":
          this.socket = { state: "stopped" };
          return;
        case "stopping":
          await this.socket.promisePair.promise;
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    async pause() {
      switch (this.socket.state) {
        case "stopping":
        case "stopped":
          return;
        case "paused":
          return;
        case "connecting":
        case "ready":
          this.socket.ws.close();
          this.socket = {
            state: "pausing",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "closing":
          this.socket = {
            state: "pausing",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "disconnected":
          this.socket = { state: "paused" };
          return;
        case "pausing":
          await this.socket.promisePair.promise;
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    async resume() {
      switch (this.socket.state) {
        case "pausing":
        case "paused":
          break;
        case "stopping":
        case "stopped":
          return;
        case "connecting":
        case "ready":
        case "closing":
        case "disconnected":
          throw new Error("`resume()` is only valid after `pause()`");
        default: {
          const _ = this.socket;
        }
      }
      if (this.socket.state === "pausing") {
        await this.socket.promisePair.promise;
      }
      await this.connect();
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(`${new Date().toISOString()} ${message}`);
      }
    }
    nextBackoff() {
      const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);
      this.retries += 1;
      const actualBackoff = Math.min(baseBackoff, this.maxBackoff);
      const jitter = actualBackoff * (Math.random() - 0.5);
      return actualBackoff + jitter;
    }
  };

  // src/browser/sync/session.ts
  function newSessionId() {
    return uuidv4();
  }
  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r2 = Math.random() * 16 | 0, v = c === "x" ? r2 : r2 & 3 | 8;
      return v.toString(16);
    });
  }

  // ../common/temp/node_modules/.pnpm/jwt-decode@3.1.2/node_modules/jwt-decode/build/jwt-decode.esm.js
  function e(e2) {
    this.message = e2;
  }
  e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
  var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
    var t2 = String(r2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
      o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
    return c;
  };
  function t(e2) {
    var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
    switch (t2.length % 4) {
      case 0:
        break;
      case 2:
        t2 += "==";
        break;
      case 3:
        t2 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e3) {
        return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
          var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
          return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
        }));
      }(t2);
    } catch (e3) {
      return r(t2);
    }
  }
  function n(e2) {
    this.message = e2;
  }
  function o(e2, r2) {
    if ("string" != typeof e2)
      throw new n("Invalid token specified");
    var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
    try {
      return JSON.parse(t(e2.split(".")[o2]));
    } catch (e3) {
      throw new n("Invalid token specified: " + e3.message);
    }
  }
  n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
  var jwt_decode_esm_default = o;

  // src/browser/sync/authentication_manager.ts
  var AuthenticationManager = class {
    constructor(syncState, {
      authenticate,
      pauseSocket: pause,
      resumeSocket: resume,
      clearAuth,
      verbose
    }) {
      this.authState = { state: "noAuth" };
      this.configVersion = 0;
      this.syncState = syncState;
      this.authenticate = authenticate;
      this.pauseSocket = pause;
      this.resumeSocket = resume;
      this.clearAuth = clearAuth;
      this.verbose = verbose;
    }
    async setConfig(fetchToken, onChange) {
      this.resetAuthState();
      const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {
        forceRefreshToken: false
      });
      if (token.isFromOutdatedConfig) {
        return;
      }
      if (token.value) {
        this.setAuthState({
          state: "waitingForServerConfirmationOfCachedToken",
          config: { fetchToken, onAuthChange: onChange },
          hasRetried: false
        });
        this.authenticate(token.value);
      } else {
        await this.refetchToken();
      }
    }
    onTransition(serverMessage) {
      if (!this.syncState.isCurrentOrNewerAuthVersion(
        serverMessage.endVersion.identity
      )) {
        return;
      }
      if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) {
        return;
      }
      if (this.authState.state === "waitingForServerConfirmationOfCachedToken") {
        this._logVerbose("server confirmed auth token is valid");
        void this.refetchToken();
        this.authState.config.onAuthChange(true);
        return;
      }
      if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
        this._logVerbose("server confirmed new auth token is valid");
        this.scheduleTokenRefetch(this.authState.token);
        if (!this.authState.hadAuth) {
          this.authState.config.onAuthChange(true);
        }
      }
    }
    onAuthError(serverMessage) {
      const { baseVersion } = serverMessage;
      if (baseVersion !== null && baseVersion !== void 0) {
        if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {
          this._logVerbose("ignoring auth error for previous auth attempt");
          return;
        }
        void this.tryToReauthenticate(serverMessage);
        return;
      }
      void this.tryToReauthenticate(serverMessage);
    }
    async tryToReauthenticate(serverMessage) {
      if (this.authState.state === "noAuth" || this.authState.state === "waitingForServerConfirmationOfFreshToken") {
        console.error(
          `Failed to authenticate: "${serverMessage.error}", check your server auth config`
        );
        if (this.syncState.hasAuth()) {
          this.syncState.clearAuth();
        }
        if (this.authState.state !== "noAuth") {
          this.setAndReportAuthFailed(this.authState.config.onAuthChange);
        }
        return;
      }
      this._logVerbose("attempting to reauthenticate");
      await this.pauseSocket();
      const token = await this.fetchTokenAndGuardAgainstRace(
        this.authState.config.fetchToken,
        {
          forceRefreshToken: true
        }
      );
      if (token.isFromOutdatedConfig) {
        await this.resumeSocket();
        return;
      }
      if (token.value && this.syncState.isNewAuth(token.value)) {
        this.syncState.setAuth(token.value);
        this.setAuthState({
          state: "waitingForServerConfirmationOfFreshToken",
          config: this.authState.config,
          token: token.value,
          hadAuth: this.authState.state === "notRefetching" || this.authState.state === "waitingForScheduledRefetch"
        });
      } else {
        this._logVerbose("reauthentication failed, could not fetch a new token");
        if (this.syncState.hasAuth()) {
          this.syncState.clearAuth();
        }
        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
      }
      await this.resumeSocket();
    }
    async refetchToken() {
      if (this.authState.state === "noAuth") {
        return;
      }
      this._logVerbose("refetching auth token");
      const token = await this.fetchTokenAndGuardAgainstRace(
        this.authState.config.fetchToken,
        {
          forceRefreshToken: true
        }
      );
      if (token.isFromOutdatedConfig) {
        return;
      }
      if (token.value) {
        if (this.syncState.isNewAuth(token.value)) {
          this.setAuthState({
            state: "waitingForServerConfirmationOfFreshToken",
            hadAuth: this.syncState.hasAuth(),
            token: token.value,
            config: this.authState.config
          });
          this.authenticate(token.value);
        } else {
          this.setAuthState({
            state: "notRefetching",
            config: this.authState.config
          });
        }
      } else {
        this._logVerbose("refetching token failed");
        if (this.syncState.hasAuth()) {
          this.clearAuth();
        }
        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
      }
    }
    scheduleTokenRefetch(token) {
      if (this.authState.state === "noAuth") {
        return;
      }
      const decodedToken = this.decodeToken(token);
      if (!decodedToken) {
        console.error("Auth token is not a valid JWT, cannot refetch the token");
        return;
      }
      const { iat, exp } = decodedToken;
      if (!iat || !exp) {
        console.error(
          "Auth token does not have required fields, cannot refetch the token"
        );
        return;
      }
      const leewaySeconds = 2;
      const delay = (exp - iat - leewaySeconds) * 1e3;
      if (delay <= 0) {
        console.error(
          "Auth token does not live long enough, cannot refetch the token"
        );
        return;
      }
      const refetchTokenTimeoutId = setTimeout(() => {
        void this.refetchToken();
      }, delay);
      this.setAuthState({
        state: "waitingForScheduledRefetch",
        refetchTokenTimeoutId,
        config: this.authState.config
      });
      this._logVerbose(
        `scheduled preemptive auth token refetching in ${delay}ms`
      );
    }
    async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {
      const originalConfigVersion = ++this.configVersion;
      const token = await fetchToken(fetchArgs);
      if (this.configVersion !== originalConfigVersion) {
        return { isFromOutdatedConfig: true };
      }
      return { isFromOutdatedConfig: false, value: token };
    }
    stop() {
      this.resetAuthState();
      this.configVersion++;
    }
    setAndReportAuthFailed(onAuthChange) {
      onAuthChange(false);
      this.resetAuthState();
    }
    resetAuthState() {
      this.setAuthState({ state: "noAuth" });
    }
    setAuthState(newAuth) {
      if (this.authState.state === "waitingForScheduledRefetch") {
        clearTimeout(this.authState.refetchTokenTimeoutId);
      }
      this.authState = newAuth;
    }
    decodeToken(token) {
      try {
        return jwt_decode_esm_default(token);
      } catch (e2) {
        return null;
      }
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(
          `${new Date().toISOString()} ${message} [v${this.configVersion}]`
        );
      }
    }
  };

  // src/browser/sync/metrics.ts
  var markNames = [
    "convexClientConstructed",
    "convexWebSocketOpen",
    "convexFirstMessageReceived"
  ];
  function mark(name, sessionId) {
    const detail = { sessionId };
    if (typeof performance === "undefined" || !performance.mark)
      return;
    performance.mark(name, { detail });
  }
  function performanceMarkToJson(mark2) {
    let name = mark2.name.slice("convex".length);
    name = name.charAt(0).toLowerCase() + name.slice(1);
    return {
      name,
      startTime: mark2.startTime
    };
  }
  function getMarksReport(sessionId) {
    if (typeof performance === "undefined" || !performance.getEntriesByName) {
      return [];
    }
    const allMarks = [];
    for (const name of markNames) {
      const marks = performance.getEntriesByName(name).filter((entry) => entry.entryType === "mark").filter((mark2) => mark2.detail.sessionId === sessionId);
      allMarks.push(...marks);
    }
    return allMarks.map(performanceMarkToJson);
  }

  // src/browser/sync/client.ts
  var BaseConvexClient = class {
    constructor(address, onTransition, options) {
      this.fetchToken = null;
      this.refetchTokenTimeoutId = null;
      this.firstMessageReceived = false;
      this.mark = (name) => {
        if (this.debug) {
          mark(name, this.sessionId);
        }
      };
      if (typeof address === "object") {
        throw new Error(
          "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly."
        );
      }
      options = { ...options };
      let webSocketConstructor = options.webSocketConstructor;
      if (!webSocketConstructor && typeof WebSocket === "undefined") {
        throw new Error(
          "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient"
        );
      }
      webSocketConstructor = webSocketConstructor || WebSocket;
      this.verbose = options.verbose ?? false;
      this.debug = options.reportDebugInfoToConvex ?? false;
      this.address = address;
      const i = address.search("://");
      if (i === -1) {
        throw new Error("Provided address was not an absolute URL.");
      }
      const origin = address.substring(i + 3);
      const protocol = address.substring(0, i);
      let wsProtocol;
      if (protocol === "http") {
        wsProtocol = "ws";
      } else if (protocol === "https") {
        wsProtocol = "wss";
      } else {
        throw new Error(`Unknown parent protocol ${protocol}`);
      }
      const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;
      this.state = new LocalSyncState();
      this.remoteQuerySet = new RemoteQuerySet(
        (queryId) => this.state.queryPath(queryId)
      );
      this.requestManager = new RequestManager();
      this.authenticationManager = new AuthenticationManager(this.state, {
        authenticate: (token) => {
          const message = this.state.setAuth(token);
          this.webSocketManager.sendMessage(message);
        },
        pauseSocket: () => this.webSocketManager.pause(),
        resumeSocket: () => this.webSocketManager.resume(),
        clearAuth: () => {
          this.clearAuth();
        },
        verbose: this.verbose
      });
      this.optimisticQueryResults = new OptimisticQueryResults();
      this.onTransition = onTransition;
      this.nextRequestId = 0;
      this.sessionId = newSessionId();
      const { unsavedChangesWarning } = options;
      if (typeof window === "undefined" || typeof window.addEventListener === "undefined") {
        if (unsavedChangesWarning === true) {
          throw new Error(
            "unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options."
          );
        }
      } else if (unsavedChangesWarning !== false) {
        window.addEventListener("beforeunload", (e2) => {
          if (this.requestManager.hasIncompleteRequests()) {
            e2.preventDefault();
            const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
            (e2 || window.event).returnValue = confirmationMessage;
            return confirmationMessage;
          }
        });
      }
      this.webSocketManager = new WebSocketManager(
        wsUri,
        (reconnectMetadata) => {
          this.mark("convexWebSocketOpen");
          this.webSocketManager.sendMessage({
            ...reconnectMetadata,
            type: "Connect",
            sessionId: this.sessionId
          });
          this.remoteQuerySet = new RemoteQuerySet(
            (queryId) => this.state.queryPath(queryId)
          );
          const [querySetModification, authModification] = this.state.restart();
          if (authModification) {
            this.webSocketManager.sendMessage(authModification);
          }
          this.webSocketManager.sendMessage(querySetModification);
          for (const message of this.requestManager.restart()) {
            this.webSocketManager.sendMessage(message);
          }
        },
        (serverMessage) => {
          if (!this.firstMessageReceived) {
            this.firstMessageReceived = true;
            this.mark("convexFirstMessageReceived");
            this.reportMarks();
          }
          switch (serverMessage.type) {
            case "Transition": {
              this.authenticationManager.onTransition(serverMessage);
              this.remoteQuerySet.transition(serverMessage);
              this.state.saveQueryJournals(serverMessage);
              const completedRequests = this.requestManager.removeCompleted(
                this.remoteQuerySet.timestamp()
              );
              this.notifyOnQueryResultChanges(completedRequests);
              break;
            }
            case "MutationResponse": {
              const completedMutationId = this.requestManager.onResponse(serverMessage);
              if (completedMutationId) {
                this.notifyOnQueryResultChanges(/* @__PURE__ */ new Set([completedMutationId]));
              }
              break;
            }
            case "ActionResponse": {
              this.requestManager.onResponse(serverMessage);
              break;
            }
            case "AuthError": {
              this.authenticationManager.onAuthError(serverMessage);
              break;
            }
            case "FatalError": {
              const error = logFatalError(serverMessage.error);
              void this.webSocketManager.stop();
              throw error;
            }
            case "Ping":
              break;
            default: {
              const _typeCheck = serverMessage;
            }
          }
        },
        webSocketConstructor,
        this.verbose
      );
      this.mark("convexClientConstructed");
    }
    notifyOnQueryResultChanges(completedRequest) {
      const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
      const queryTokenToValue = /* @__PURE__ */ new Map();
      for (const [queryId, result] of remoteQueryResults) {
        const queryToken = this.state.queryToken(queryId);
        if (queryToken !== null) {
          const query = {
            result,
            udfPath: this.state.queryPath(queryId),
            args: this.state.queryArgs(queryId)
          };
          queryTokenToValue.set(queryToken, query);
        }
      }
      this.onTransition(
        this.optimisticQueryResults.ingestQueryResultsFromServer(
          queryTokenToValue,
          completedRequest
        )
      );
    }
    setAuth(fetchToken, onChange) {
      void this.authenticationManager.setConfig(fetchToken, onChange);
    }
    hasAuth() {
      return this.state.hasAuth();
    }
    setAdminAuth(value, fakeUserIdentity) {
      const message = this.state.setAdminAuth(value, fakeUserIdentity);
      this.webSocketManager.sendMessage(message);
    }
    clearAuth() {
      const message = this.state.clearAuth();
      this.webSocketManager.sendMessage(message);
    }
    subscribe(name, args, options) {
      const argsObject = parseArgs(args);
      const { modification, queryToken, unsubscribe } = this.state.subscribe(
        name,
        argsObject,
        options?.journal
      );
      if (modification !== null) {
        this.webSocketManager.sendMessage(modification);
      }
      return {
        queryToken,
        unsubscribe: () => {
          const modification2 = unsubscribe();
          if (modification2) {
            this.webSocketManager.sendMessage(modification2);
          }
        }
      };
    }
    localQueryResult(udfPath, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(udfPath, argsObject);
      return this.optimisticQueryResults.queryResult(queryToken);
    }
    localQueryLogs(udfPath, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(udfPath, argsObject);
      return this.optimisticQueryResults.queryLogs(queryToken);
    }
    queryJournal(name, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(name, argsObject);
      return this.state.queryJournal(queryToken);
    }
    connectionState() {
      return {
        hasInflightRequests: this.requestManager.hasInflightRequests(),
        isWebSocketConnected: this.webSocketManager.socketState() === "ready",
        timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest()
      };
    }
    async mutation(name, args, options) {
      const result = await this.mutationInternal(name, args, options);
      if (!result.success) {
        throw createError("mutation", name, result.errorMessage);
      }
      return result.value;
    }
    async mutationInternal(udfPath, args, options) {
      const mutationArgs = parseArgs(args);
      this.tryReportLongDisconnect();
      const requestId = this.nextRequestId;
      this.nextRequestId++;
      if (options !== void 0) {
        const optimisticUpdate = options.optimisticUpdate;
        if (optimisticUpdate !== void 0) {
          const wrappedUpdate = (localQueryStore) => {
            optimisticUpdate(localQueryStore, mutationArgs);
          };
          const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(
            wrappedUpdate,
            requestId
          );
          this.onTransition(changedQueries);
        }
      }
      const message = {
        type: "Mutation",
        requestId,
        udfPath,
        args: [convexToJson(mutationArgs)]
      };
      const mightBeSent = this.webSocketManager.sendMessage(message);
      return this.requestManager.request(message, mightBeSent);
    }
    async action(name, args) {
      const result = await this.actionInternal(name, args);
      if (!result.success) {
        throw createError("action", name, result.errorMessage);
      }
      return result.value;
    }
    async actionInternal(udfPath, args) {
      const actionArgs = parseArgs(args);
      const requestId = this.nextRequestId;
      this.nextRequestId++;
      this.tryReportLongDisconnect();
      const message = {
        type: "Action",
        requestId,
        udfPath,
        args: [convexToJson(actionArgs)]
      };
      const mightBeSent = this.webSocketManager.sendMessage(message);
      return this.requestManager.request(message, mightBeSent);
    }
    async close() {
      this.authenticationManager.stop();
      return this.webSocketManager.stop();
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(`${new Date().toISOString()} ${message}`);
      }
    }
    reportMarks() {
      if (this.debug) {
        const report = getMarksReport(this.sessionId);
        this.webSocketManager.sendMessage({
          type: "Event",
          eventType: "ClientConnect",
          event: report
        });
      }
    }
    tryReportLongDisconnect() {
      if (!this.debug) {
        return;
      }
      const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;
      if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {
        return;
      }
      const endpoint = `${this.address}/api/debug_event`;
      fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Convex-Client": `npm-${version}`
        },
        body: JSON.stringify({ event: "LongWebsocketDisconnect" })
      }).then((response) => {
        if (!response.ok) {
          console.warn(
            "Analytics request failed with response:",
            response.body
          );
        }
      }).catch((error) => {
        console.warn("Analytics response failed with error:", error);
      });
    }
  };

  // src/react/client.ts
  var import_react2 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // src/react/use_subscription.ts
  var import_react = __toESM(require_react());
  function useSubscription({
    getCurrentValue,
    subscribe
  }) {
    const [state, setState] = (0, import_react.useState)(() => ({
      getCurrentValue,
      subscribe,
      value: getCurrentValue()
    }));
    let valueToReturn = state.value;
    if (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) {
      valueToReturn = getCurrentValue();
      setState({
        getCurrentValue,
        subscribe,
        value: valueToReturn
      });
    }
    (0, import_react.useEffect)(() => {
      let didUnsubscribe = false;
      const checkForUpdates = () => {
        if (didUnsubscribe) {
          return;
        }
        setState((prevState) => {
          if (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) {
            return prevState;
          }
          const value = getCurrentValue();
          if (prevState.value === value) {
            return prevState;
          }
          return { ...prevState, value };
        });
      };
      const unsubscribe = subscribe(checkForUpdates);
      checkForUpdates();
      return () => {
        didUnsubscribe = true;
        unsubscribe();
      };
    }, [getCurrentValue, subscribe]);
    return valueToReturn;
  }

  // src/react/client.ts
  if (typeof import_react2.default === "undefined") {
    throw new Error("Required dependency 'react' not found");
  }
  if (typeof import_react_dom.default === "undefined") {
    throw new Error("Required dependency 'react-dom' not found");
  }
  function createMutation(name, client, update) {
    function mutation(args) {
      assertNotAccidentalArgument(args);
      return client.mutation(name, args, { optimisticUpdate: update });
    }
    mutation.withOptimisticUpdate = function withOptimisticUpdate(optimisticUpdate) {
      if (update !== void 0) {
        throw new Error(
          `Already specified optimistic update for mutation ${name}`
        );
      }
      return createMutation(name, client, optimisticUpdate);
    };
    return mutation;
  }
  function createAction(name, client) {
    return function(args) {
      return client.action(name, args);
    };
  }
  var ConvexReactClient = class {
    constructor(address, options) {
      this.closed = false;
      if (typeof address !== "string") {
        throw new Error(
          "ConvexReactClient requires a URL like 'https://happy-otter-123.convex.cloud'."
        );
      }
      if (!address.includes("://")) {
        throw new Error("Provided address was not an absolute URL.");
      }
      this.address = address;
      this.listeners = /* @__PURE__ */ new Map();
      this.options = { ...options };
    }
    get sync() {
      if (this.closed) {
        throw new Error("ConvexReactClient has already been closed.");
      }
      if (this.cachedSync) {
        return this.cachedSync;
      }
      this.cachedSync = new BaseConvexClient(
        this.address,
        (updatedQueries) => this.transition(updatedQueries),
        this.options
      );
      if (this.adminAuth) {
        this.cachedSync.setAdminAuth(this.adminAuth, this.fakeUserIdentity);
      }
      return this.cachedSync;
    }
    setAuth(fetchToken, onChange) {
      if (typeof fetchToken === "string") {
        throw new Error(
          "Passing a string to ConvexReactClient.setAuth is no longer supported, please upgrade to passing in an async function to handle reauthentication."
        );
      }
      this.sync.setAuth(
        fetchToken,
        onChange ?? (() => {
        })
      );
    }
    clearAuth() {
      this.sync.clearAuth();
    }
    setAdminAuth(token, identity) {
      this.adminAuth = token;
      this.fakeUserIdentity = identity;
      if (this.closed) {
        throw new Error("ConvexReactClient has already been closed.");
      }
      if (this.cachedSync) {
        this.sync.setAdminAuth(token, identity);
      }
    }
    watchQuery(name, ...argsAndOptions) {
      const [args, options] = argsAndOptions;
      return {
        onUpdate: (callback) => {
          const { queryToken, unsubscribe } = this.sync.subscribe(
            name,
            args,
            options
          );
          const currentListeners = this.listeners.get(queryToken);
          if (currentListeners !== void 0) {
            currentListeners.add(callback);
          } else {
            this.listeners.set(queryToken, /* @__PURE__ */ new Set([callback]));
          }
          return () => {
            if (this.closed) {
              return;
            }
            const currentListeners2 = this.listeners.get(queryToken);
            currentListeners2.delete(callback);
            if (currentListeners2.size === 0) {
              this.listeners.delete(queryToken);
            }
            unsubscribe();
          };
        },
        localQueryResult: () => {
          if (this.cachedSync) {
            return this.cachedSync.localQueryResult(name, args);
          }
          return void 0;
        },
        localQueryLogs: () => {
          if (this.cachedSync) {
            return this.cachedSync.localQueryLogs(name, args);
          }
          return void 0;
        },
        journal: () => {
          if (this.cachedSync) {
            return this.cachedSync.queryJournal(name, args);
          }
          return void 0;
        }
      };
    }
    mutation(name, ...argsAndOptions) {
      const [args, options] = argsAndOptions;
      return this.sync.mutation(name, args, options);
    }
    action(name, ...args) {
      return this.sync.action(name, ...args);
    }
    connectionState() {
      return this.sync.connectionState();
    }
    async close() {
      this.closed = true;
      this.listeners = /* @__PURE__ */ new Map();
      if (this.cachedSync) {
        const sync = this.cachedSync;
        this.cachedSync = void 0;
        await sync.close();
      }
    }
    transition(updatedQueries) {
      import_react_dom.default.unstable_batchedUpdates(() => {
        for (const queryToken of updatedQueries) {
          const callbacks = this.listeners.get(queryToken);
          if (callbacks) {
            for (const callback of callbacks) {
              callback();
            }
          }
        }
      });
    }
  };
  var ConvexContext = import_react2.default.createContext(
    void 0
  );
  function useConvexGeneric() {
    return (0, import_react2.useContext)(ConvexContext);
  }
  var ConvexProvider = ({ client, children }) => {
    return import_react2.default.createElement(
      ConvexContext.Provider,
      { value: client },
      children
    );
  };
  function useQueryGeneric(name, args, _options) {
    const convex = (0, import_react2.useContext)(ConvexContext);
    if (convex === void 0) {
      throw new Error(
        "Could not find Convex client! `useQuery` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
      );
    }
    const queryArgs = parseArgs(args);
    const subscription = (0, import_react2.useMemo)(
      () => {
        const watch = convex.watchQuery(name, queryArgs);
        return {
          getCurrentValue: () => watch.localQueryResult(),
          subscribe: (callback) => watch.onUpdate(callback)
        };
      },
      [name, convex, JSON.stringify(convexToJson(queryArgs))]
    );
    const queryResult = useSubscription(subscription);
    return queryResult;
  }
  function useMutationGeneric(name) {
    const convex = (0, import_react2.useContext)(ConvexContext);
    if (convex === void 0) {
      throw new Error(
        "Could not find Convex client! `useMutation` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
      );
    }
    return (0, import_react2.useMemo)(() => createMutation(name, convex), [convex, name]);
  }
  function useActionGeneric(name) {
    const convex = (0, import_react2.useContext)(ConvexContext);
    if (convex === void 0) {
      throw new Error(
        "Could not find Convex client! `useAction` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
      );
    }
    return (0, import_react2.useMemo)(() => createAction(name, convex), [convex, name]);
  }
  function assertNotAccidentalArgument(value) {
    if (typeof value === "object" && value !== null && "bubbles" in value && "persist" in value && "isDefaultPrevented" in value) {
      throw new Error(
        `Convex function called with SyntheticEvent object. Did you use a Convex function as an event handler directly? Event handlers like onClick receive an event object as their first argument. These SyntheticEvent objects are not valid Convex values. Try wrapping the function like \`const handler = () => myMutation();\` and using \`handler\` in the event handler.`
      );
    }
  }

  // src/react/queries_observer.ts
  var QueriesObserver = class {
    constructor(createWatch) {
      this.createWatch = createWatch;
      this.queries = {};
      this.listeners = /* @__PURE__ */ new Set();
    }
    setQueries(newQueries) {
      for (const identifier of Object.keys(newQueries)) {
        const { name, args } = newQueries[identifier];
        if (this.queries[identifier] === void 0) {
          this.addQuery(identifier, name, args);
        } else {
          const existingInfo = this.queries[identifier];
          if (name !== existingInfo.name || JSON.stringify(convexToJson(args)) !== JSON.stringify(convexToJson(existingInfo.args))) {
            this.removeQuery(identifier);
            this.addQuery(identifier, name, args);
          }
        }
      }
      for (const identifier of Object.keys(this.queries)) {
        if (newQueries[identifier] === void 0) {
          this.removeQuery(identifier);
        }
      }
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => {
        this.listeners.delete(listener);
      };
    }
    getCurrentQueries() {
      const result = {};
      for (const identifier of Object.keys(this.queries)) {
        let value;
        try {
          value = this.queries[identifier].watch.localQueryResult();
        } catch (e2) {
          if (e2 instanceof Error) {
            value = e2;
          } else {
            throw e2;
          }
        }
        result[identifier] = value;
      }
      return result;
    }
    setCreateWatch(createWatch) {
      this.createWatch = createWatch;
      for (const identifier of Object.keys(this.queries)) {
        const { name, args, watch } = this.queries[identifier];
        const journal = watch.journal();
        this.removeQuery(identifier);
        this.addQuery(identifier, name, args, journal);
      }
    }
    destroy() {
      for (const identifier of Object.keys(this.queries)) {
        this.removeQuery(identifier);
      }
      this.listeners = /* @__PURE__ */ new Set();
    }
    addQuery(identifier, name, args, journal) {
      if (this.queries[identifier] !== void 0) {
        throw new Error(
          `Tried to add a new query with identifier ${identifier} when it already exists.`
        );
      }
      const watch = this.createWatch(name, args, journal);
      const unsubscribe = watch.onUpdate(() => this.notifyListeners());
      this.queries[identifier] = {
        name,
        args,
        watch,
        unsubscribe
      };
    }
    removeQuery(identifier) {
      const info = this.queries[identifier];
      if (info === void 0) {
        throw new Error(`No query found with identifier ${identifier}.`);
      }
      info.unsubscribe();
      delete this.queries[identifier];
    }
    notifyListeners() {
      for (const listener of this.listeners) {
        listener();
      }
    }
  };

  // src/react/use_queries.ts
  function useQueriesGeneric(queries) {
    const convex = useConvexGeneric();
    if (convex === void 0) {
      throw new Error(
        "Could not find Convex client! `useQueries` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
      );
    }
    const createWatch = (0, import_react3.useMemo)(() => {
      return (name, args, journal) => {
        return convex.watchQuery(name, args, { journal });
      };
    }, [convex]);
    return useQueriesHelper(queries, createWatch);
  }
  function useQueriesHelper(queries, createWatch) {
    const [observer] = (0, import_react3.useState)(() => new QueriesObserver(createWatch));
    const [effectRan, setEffectRan] = (0, import_react3.useState)(false);
    if (observer.createWatch !== createWatch) {
      observer.setCreateWatch(createWatch);
    }
    (0, import_react3.useEffect)(() => {
      setEffectRan(true);
      return () => {
        observer.destroy();
      };
    }, [observer]);
    const subscription = (0, import_react3.useMemo)(() => {
      if (effectRan) {
        observer.setQueries(queries);
      }
      return {
        getCurrentValue: () => {
          if (effectRan) {
            return observer.getCurrentQueries();
          } else {
            const value = {};
            for (const identifier in Object.keys(queries)) {
              value[identifier] = void 0;
            }
            return value;
          }
        },
        subscribe: (callback) => observer.subscribe(callback)
      };
    }, [observer, queries, effectRan]);
    return useSubscription(subscription);
  }

  // src/react/use_paginated_query.ts
  function usePaginatedQueryGeneric(name, args, options) {
    if (typeof options?.initialNumItems !== "number" || options.initialNumItems < 0) {
      throw new Error(
        `\`options.initialNumItems\` must be a positive number. Received \`${options?.initialNumItems}\`.`
      );
    }
    const createInitialState = (0, import_react4.useMemo)(() => {
      return () => {
        const id = nextPaginationId();
        return {
          name,
          args,
          id,
          maxQueryIndex: 0,
          queries: {
            0: {
              name,
              args: {
                ...args,
                paginationOpts: {
                  numItems: options.initialNumItems,
                  cursor: null,
                  id
                }
              }
            }
          }
        };
      };
    }, [JSON.stringify(convexToJson(args)), name, options.initialNumItems]);
    const [state, setState] = (0, import_react4.useState)(createInitialState);
    let currState = state;
    if (name !== state.name || JSON.stringify(convexToJson(args)) !== JSON.stringify(convexToJson(state.args))) {
      currState = createInitialState();
      setState(currState);
    }
    const resultsObject = useQueriesGeneric(currState.queries);
    const [results, maybeLastResult] = (0, import_react4.useMemo)(() => {
      let currResult = void 0;
      const allItems = [];
      for (let i = 0; i <= currState.maxQueryIndex; i++) {
        currResult = resultsObject[i];
        if (currResult === void 0) {
          break;
        }
        if (currResult instanceof Error) {
          if (currResult.message.includes("InvalidCursor") || currResult.message.includes("QueryScannedTooManyDocuments") || currResult.message.includes("ArrayTooLong")) {
            setState(createInitialState);
            return [[], void 0];
          } else {
            throw currResult;
          }
        }
        allItems.push(...currResult.page);
      }
      return [allItems, currResult];
    }, [resultsObject, currState.maxQueryIndex, createInitialState]);
    const statusAndLoadMore = (0, import_react4.useMemo)(() => {
      if (maybeLastResult === void 0) {
        return {
          status: "LoadingMore",
          loadMore: void 0
        };
      }
      if (maybeLastResult.isDone) {
        return {
          status: "Exhausted",
          loadMore: void 0
        };
      }
      const continueCursor = maybeLastResult.continueCursor;
      let alreadyLoadingMore = false;
      return {
        status: "CanLoadMore",
        loadMore: (numItems) => {
          if (!alreadyLoadingMore) {
            alreadyLoadingMore = true;
            setState((prevState) => {
              const maxQueryIndex = prevState.maxQueryIndex + 1;
              const queries = { ...prevState.queries };
              queries[maxQueryIndex] = {
                name: prevState.name,
                args: {
                  ...prevState.args,
                  paginationOpts: {
                    numItems,
                    cursor: continueCursor,
                    id: prevState.id
                  }
                }
              };
              return {
                ...prevState,
                maxQueryIndex,
                queries
              };
            });
          }
        }
      };
    }, [maybeLastResult]);
    return {
      results,
      ...statusAndLoadMore
    };
  }
  var paginationId = 0;
  function nextPaginationId() {
    paginationId++;
    return paginationId;
  }
  function optimisticallyUpdateValueInPaginatedQuery(localStore, name, args, updateValue) {
    const expectedArgs = JSON.stringify(convexToJson(args));
    for (const query of localStore.getAllQueries(name)) {
      if (query.value !== void 0) {
        const { paginationOpts: _, ...innerArgs } = query.args;
        if (JSON.stringify(convexToJson(innerArgs)) === expectedArgs) {
          const value = query.value;
          if (typeof value === "object" && value !== null && Array.isArray(value.page)) {
            localStore.setQuery(name, query.args, {
              ...value,
              page: value.page.map(updateValue)
            });
          }
        }
      }
    }
  }

  // src/react/auth_helpers.tsx
  var import_react6 = __toESM(require_react());

  // src/react/ConvexAuthState.tsx
  var import_react5 = __toESM(require_react());
  var ConvexAuthContext = (0, import_react5.createContext)(void 0);
  function useConvexAuth() {
    return (0, import_react5.useContext)(ConvexAuthContext);
  }
  function ConvexProviderWithAuth({
    children,
    client,
    useAuth
  }) {
    const { isLoading, isAuthenticated, fetchAccessToken } = useAuth();
    const [isConvexAuthenticated, setIsConvexAuthenticated] = (0, import_react5.useState)(null);
    (0, import_react5.useEffect)(() => {
      let isThisEffectRelevant = true;
      async function setToken() {
        client.setAuth(fetchAccessToken, (isAuthenticated2) => {
          if (isThisEffectRelevant) {
            setIsConvexAuthenticated(isAuthenticated2);
          }
        });
      }
      if (isAuthenticated) {
        void setToken();
        return () => {
          isThisEffectRelevant = false;
          setIsConvexAuthenticated(
            (isConvexAuthenticated2) => isConvexAuthenticated2 ? false : null
          );
          client.clearAuth();
        };
      }
    }, [isAuthenticated, fetchAccessToken, isLoading, client]);
    if (isLoading && isConvexAuthenticated !== null) {
      setIsConvexAuthenticated(null);
    }
    if (!isLoading && !isAuthenticated && isConvexAuthenticated !== false) {
      setIsConvexAuthenticated(false);
    }
    return /* @__PURE__ */ import_react5.default.createElement(
      ConvexAuthContext.Provider,
      {
        value: {
          isLoading: isConvexAuthenticated === null,
          isAuthenticated: isAuthenticated && (isConvexAuthenticated ?? false)
        }
      },
      /* @__PURE__ */ import_react5.default.createElement(ConvexProvider, { client }, children)
    );
  }

  // src/react/auth_helpers.tsx
  function Authenticated({ children }) {
    const { isLoading, isAuthenticated } = useConvexAuth();
    if (isLoading || !isAuthenticated) {
      return null;
    }
    return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, children);
  }
  function Unauthenticated({ children }) {
    const { isLoading, isAuthenticated } = useConvexAuth();
    if (isLoading || isAuthenticated) {
      return null;
    }
    return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, children);
  }
  function AuthLoading({ children }) {
    const { isLoading } = useConvexAuth();
    if (!isLoading) {
      return null;
    }
    return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, children);
  }
  return __toCommonJS(react_exports);
})();
//# sourceMappingURL=react.bundle.js.map
