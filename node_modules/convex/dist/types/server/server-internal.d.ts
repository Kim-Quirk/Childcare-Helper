/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link actionGeneric} a type specific to your data model.
 * @public
 */
export declare type ActionBuilder<API extends GenericAPI, Visibility extends FunctionVisibility> = {
    <Output, ArgsValidator extends PropertyValidators>(func: ValidatedFunction<ActionCtx<API>, ArgsValidator, Output>): RegisteredAction<Visibility, [ObjectType<ArgsValidator>], Output>;
    <Output, Args extends ArgsArray = OneArgArray>(func: UnvalidatedFunction<ActionCtx<API>, Args, Output>): RegisteredAction<Visibility, Args, Output>;
};

/**
 * A set of services for use within Convex action functions.
 *
 * The context is passed as the first argument to any Convex action
 * run on the server.
 *
 * If you're using code generation, use the `ActionCtx` type in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @public
 */
export declare interface ActionCtx<API extends GenericAPI> {
    /**
     * Runs the Convex query with the given name and arguments.
     *
     * Consider using an {@link internalQuery} to prevent users from calling the
     * query directly.
     */
    runQuery<Name extends QueryNames<API>>(name: Name, ...args: OptionalRestArgs<NamedQuery<API, Name>>): Promise<ReturnType<NamedQuery<API, Name>>>;
    /**
     * Runs the Convex mutation with the given name and arguments.
     *
     * Consider using an {@link internalMutation} to prevent users from calling
     * the mutation directly.
     */
    runMutation<Name extends MutationNames<API>>(name: Name, ...args: OptionalRestArgs<NamedMutation<API, Name>>): Promise<ReturnType<NamedMutation<API, Name>>>;
    /**
     * Runs the Convex action with the given name and arguments.
     *
     * Consider using an {@link internalAction} to prevent users from calling the
     * action directly.
     */
    runAction<Name extends ActionNames<API>>(name: Name, ...args: OptionalRestArgs<NamedAction<API, Name>>): Promise<ReturnType<NamedAction<API, Name>>>;
    /**
     * A utility for scheduling Convex functions to run in the future.
     */
    scheduler: Scheduler<API>;
    /**
     * Information about the currently authenticated user.
     */
    auth: Auth;
    /**
     * A utility for reading and writing files in storage.
     */
    storage: StorageActionWriter;
}

/**
 * Define an action in this Convex app's public API.
 *
 * If you're using code generation, use the `action` function in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @param func - The function. It receives a {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export declare const actionGeneric: ActionBuilder<any, "public">;

/**
 * The names of actions in a Convex API.
 *
 * @public
 */
declare type ActionNames<API extends GenericAPI> = keyof API["allActions"] & string;

/**
 * A {@link GenericDataModel} that considers documents to be `any` and does not
 * support indexes.
 *
 * This is the default before a schema is defined.
 * @public
 */
export declare type AnyDataModel = {
    [tableName: string]: {
        document: any;
        fieldPaths: GenericFieldPaths;
        indexes: {};
        searchIndexes: {};
    };
};

/**
 * An array of arguments to a Convex function.
 *
 * Convex functions can take either a single {@link FunctionArgs} object or no
 * args at all.
 */
declare type ArgsArray = OneArgArray | NoArgsArray;

/**
 * An interface to access information about the currently authenticated user
 * within Convex query and mutation functions.
 *
 * @public
 */
export declare interface Auth {
    /**
     * Get details about the currently authenticated user.
     *
     * @returns A promise that resolves to a {@link UserIdentity} if the Convex
     * client was configured with a valid ID token and `null` otherwise.
     */
    getUserIdentity(): Promise<UserIdentity | null>;
}

/**
 * An `Omit<>` type that:
 * 1. Applies to each element of a union.
 * 2. Preserves the index signature of the underlying type.
 */
declare type BetterOmit<T, K extends keyof T> = {
    [Property in keyof T as Property extends K ? never : Property]: T[Property];
};

/**
 * The type of a Convex function in a {@link GenericAPI}.
 *
 * @public
 */
declare type ConvexFunction = (args?: any) => any;

/**
 * A schedule to run a Convex mutation or action on.
 * You can schedule Convex functions to run regularly with
 * {@link interval} and exporting it.
 *
 * @public
 **/
export declare interface CronJob {
    name: string;
    args: JSONValue;
    schedule: Schedule;
}

/**
 * @public
 */
export declare type CronJobsForAPI<API extends GenericAPI> = () => Crons<API>;

/**
 * Internal type helper used by Convex code generation.
 *
 * If you're using code generation, use the `cronJobs` function in
 * `convex/_generated/server.js` which is typed for your API.
 *
 *
 * ```js
 * // convex/crons.js
 * import { cronJobs } from 'convex/server';
 *
 * const crons = cronJobs();
 * crons.weekly(
 *   "weekly re-engagement email",
 *   {
 *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
 *     minuteUTC: 30,
 *   },
 *   "sendEmails"
 * )
 * export default crons;
 * ```
 *
 * @public
 */
export declare const cronJobsGeneric: <API extends GenericAPI>() => Crons<API>;

/**
 * A class for scheduling cron jobs.
 *
 * To learn more see the documentation at https://docs.convex.dev/scheduling/cron-jobs
 *
 * @public
 */
export declare class Crons<API extends GenericAPI> {
    crons: Record<string, CronJob>;
    isCrons: true;
    constructor();
    /** @internal */
    schedule(cronIdentifier: string, schedule: Schedule, name: string, args?: Record<string, Value>): void;
    /**
     * Schedule a mutation or action to run on an hourly basis.
     *
     * ```js
     * crons.interval("Clear presence data", {seconds: 30}, "clearPresence");
     * ```
     *
     * @param identifier - A unique name for this scheduled job.
     * @param schedule - The time between runs for this scheduled job.
     * @param functionName - The name of the function to schedule.
     * @param args - The arguments to the function.
     */
    interval<Name extends SchedulableFunctionNames<API>>(cronIdentifier: string, schedule: Interval, functionName: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): void;
    /**
     * Schedule a mutation or action to run on a daily basis.
     *
     * ```js
     * crons.daily(
     *   "Reset high scores",
     *   {
     *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
     *     minuteUTC: 30,
     *   },
     *   "resetHighScores"
     * )
     * ```
     *
     * @param cronIdentifier - A unique name for this scheduled job.
     * @param schedule - What time (UTC) each day to run this function.
     * @param functionName - The name of the function to schedule.
     * @param args - The arguments to the function.
     */
    hourly<Name extends SchedulableFunctionNames<API>>(cronIdentifier: string, schedule: Hourly, functionName: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): void;
    /**
     * Schedule a mutation or action to run on a daily basis.
     *
     * ```js
     * crons.daily(
     *   "Reset high scores",
     *   {
     *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
     *     minuteUTC: 30,
     *   },
     *   "resetHighScores"
     * )
     * ```
     *
     * @param cronIdentifier - A unique name for this scheduled job.
     * @param schedule - What time (UTC) each day to run this function.
     * @param functionName - The name of the function to schedule.
     * @param args - The arguments to the function.
     */
    daily<Name extends SchedulableFunctionNames<API>>(cronIdentifier: string, schedule: Daily, functionName: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): void;
    /**
     * Schedule a mutation or action to run on a weekly basis.
     *
     * ```js
     * crons.weekly(
     *   "Weekly re-engagement email",
     *   {
     *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
     *     minuteUTC: 30,
     *   },
     *   "sendExpiringMessage"
     * )
     * ```
     *
     * @param cronIdentifier - A unique name for this scheduled job.
     * @param schedule - What day and time (UTC) each week to run this function.
     * @param functionName - The name of the function to schedule.
     */
    weekly<Name extends SchedulableFunctionNames<API>>(cronIdentifier: string, schedule: Weekly, functionName: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): void;
    /**
     * Schedule a mutation or action to run on a monthly basis.
     *
     * Note that some months have fewer days than others, so e.g. a function
     * scheduled to run on the 30th will not run in February.
     *
     * ```js
     * crons.monthly(
     *   "Bill customers at ",
     *   {
     *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
     *     minuteUTC: 30,
     *     day: 1,
     *   },
     *   "billCustomers"
     * )
     * ```
     *
     * @param cronIdentifier - A unique name for this scheduled job.
     * @param schedule - What day and time (UTC) each month to run this function.
     * @param functionName - The name of the function to schedule.
     * @param args - The arguments to the function.
     */
    monthly<Name extends SchedulableFunctionNames<API>>(cronIdentifier: string, schedule: Monthly, functionName: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): void;
    /**
     * Schedule a mutation or action to run on a recurring basis.
     *
     * Like the unix command `cron`, Sunday is 0, Monday is 1, etc.
     *
     * ```
     *  ┌─ minute (0 - 59)
     *  │ ┌─ hour (0 - 23)
     *  │ │ ┌─ day of the month (1 - 31)
     *  │ │ │ ┌─ month (1 - 12)
     *  │ │ │ │ ┌─ day of the week (0 - 6) (Sunday to Saturday)
     * "* * * * *"
     * ```
     *
     * @param cronIdentifier - A unique name for this scheduled job.
     * @param cron - Cron string like `"15 7 * * *"` (Every day at 7:15 UTC)
     * @param functionName - The name of the function to schedule.
     * @param args - The arguments to the function.
     */
    cron<Name extends SchedulableFunctionNames<API>>(cronIdentifier: string, cron: CronString, functionName: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): void;
    /** @internal */
    export(): string;
}

declare type CronSchedule = {
    type: "cron";
    cron: string;
};

/**
 * @public
 *
 * This is a cron string. They're complicated!
 */
declare type CronString = string;

/**
 * An opaque identifier used for paginating a database query.
 *
 * Cursors are returned from {@link OrderedQuery.paginate} and represent the
 * point of the query where the page of results ended.
 *
 * To continue paginating, pass the cursor back into
 * {@link OrderedQuery.paginate} in the {@link PaginationOptions} object to
 * fetch another page of results.
 *
 * Note: Cursors can only be passed to _exactly_ the same database query that
 * they were generated from. You may not reuse a cursor between different
 * database queries.
 *
 * @public
 */
export declare type Cursor = string;

/** @public */
declare type Daily = {
    /**
     * 0-23, hour of day. Remember, this is UTC.
     */
    hourUTC: number;
    /**
     * 0-59, minute of hour. Remember, this is UTC.
     */
    minuteUTC: number;
};

/** @public */
declare type DailySchedule = {
    type: "daily";
    hourUTC: number;
    minuteUTC: number;
};

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link values.GenericId}, or {@link DatabaseReader.query}, which starts
 * building a query.
 *
 * If you're using code generation, use the `DatabaseReader` type in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @public
 */
export declare interface DatabaseReader<DataModel extends GenericDataModel> {
    /**
     * Fetch a single document from the database by its {@link values.GenericId}.
     *
     * @param id - The {@link values.GenericId} of the document to fetch from the database.
     * @returns - The {@link GenericDocument} of the document at the given {@link values.GenericId}, or `null` if it no longer exists.
     */
    get<TableName extends TableNamesInDataModel<DataModel>>(id: Id<TableName>): Promise<DocumentByName<DataModel, TableName> | null>;
    /**
     * Begin a query for the given table name.
     *
     * Queries don't execute immediately, so calling this method and extending its
     * query are free until the results are actually used.
     *
     * @param tableName - The name of the table to query.
     * @returns - A {@link QueryInitializer} object to start building a query.
     */
    query<TableName extends TableNamesInDataModel<DataModel>>(tableName: TableName): QueryInitializer<NamedTableInfo<DataModel, TableName>>;
}

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 *
 *  If you're using code generation, use the `DatabaseReader` type in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @public
 */
export declare interface DatabaseWriter<DataModel extends GenericDataModel> extends DatabaseReader<DataModel> {
    /**
     * Insert a new document into a table.
     *
     * @param table - The name of the table to insert a new document into.
     * @param value - The {@link values.Value} to insert into the given table.
     * @returns - {@link values.GenericId} of the new document.
     */
    insert<TableName extends TableNamesInDataModel<DataModel>>(table: TableName, value: WithoutSystemFields<DocumentByName<DataModel, TableName>>): Promise<Id<TableName>>;
    /**
     * Patch an existing document, merging its value with a new values.
     *
     * Any overlapping fields in the two documents will be overwritten with
     * their new value.
     *
     * @param id - The {@link values.GenericId} of the document to patch.
     * @param value - The partial {@link GenericDocument} to merge into the specified document. If this new value
     * specifies system fields like `_id`, they must match the document's existing field values.
     */
    patch<TableName extends TableNamesInDataModel<DataModel>>(id: Id<TableName>, value: Partial<DocumentByName<DataModel, TableName>>): Promise<void>;
    /**
     * Replace the value of an existing document, overwriting its old value.
     *
     * @param id - The {@link values.GenericId} of the document to replace.
     * @param value - The new {@link GenericDocument} for the document. This value can omit the system fields,
     * and the database will fill them in.
     */
    replace<TableName extends TableNamesInDataModel<DataModel>>(id: Id<TableName>, value: WithOptionalSystemFields<DocumentByName<DataModel, TableName>>): Promise<void>;
    /**
     * Delete an existing document.
     *
     * @param id - The {@link values.GenericId} of the document to remove.
     */
    delete(id: Id<TableNamesInDataModel<DataModel>>): Promise<void>;
}

declare type DayOfWeek = (typeof DAYS_OF_WEEK)[number];

declare const DAYS_OF_WEEK: string[];

/**
 * The type of a document in a table for a given {@link GenericTableInfo}.
 * @public
 */
export declare type DocumentByInfo<TableInfo extends GenericTableInfo> = TableInfo["document"];

/**
 * The type of a document in a {@link GenericDataModel} by table name.
 * @public
 */
export declare type DocumentByName<DataModel extends GenericDataModel, TableName extends TableNamesInDataModel<DataModel>> = DataModel[TableName]["document"];

/**
 * Common utilities for manipulating TypeScript types.
 * @module
 */
/**
 * Hack! This type causes TypeScript to simplify how it renders object types.
 *
 * It is functionally the identity for object types, but in practice it can
 * simplify expressions like `A & B`.
 */
declare type Expand<ObjectType extends Record<any, any>> = ObjectType extends Record<any, any> ? {
    [Key in keyof ObjectType]: ObjectType[Key];
} : never;

/**
 * Expressions are evaluated to produce a {@link values.Value} in the course of executing a query.
 *
 * To construct an expression, use the {@link FilterBuilder} provided within
 * {@link OrderedQuery.filter}.
 *
 * @typeParam T - The type that this expression evaluates to.
 * @public
 */
export declare abstract class Expression<T extends Value | undefined> {
    private _isExpression;
    private _value;
    /**
     * @internal
     */
    constructor();
}

/**
 * An {@link Expression} or a constant {@link values.Value}
 *
 * @public
 */
export declare type ExpressionOrValue<T extends Value | undefined> = Expression<T> | T;

/**
 * The field paths in a table for a given {@link GenericTableInfo}.
 *
 * These can either be field names (like "name") or references to fields on
 * nested objects (like "properties.name").
 * @public
 */
export declare type FieldPaths<TableInfo extends GenericTableInfo> = TableInfo["fieldPaths"];

/**
 * The type of a field in a document.
 *
 * Note that this supports both simple fields like "name" and nested fields like
 * "properties.name".
 *
 * If the field is not present in the document it is considered to be `undefined`.
 *
 * @public
 */
export declare type FieldTypeFromFieldPath<Document extends GenericDocument, FieldPath extends string> = FieldPath extends `${infer First}.${infer Second}` ? First extends keyof Document ? Document[First] extends GenericDocument ? FieldTypeFromFieldPath<Document[First], Second> : undefined : undefined : FieldPath extends keyof Document ? Document[FieldPath] : undefined;

/**
 * Metadata for a single file as returned by {@link StorageReader.getMetadata | storage.getMetadata}.
 *
 * @public
 */
export declare type FileMetadata = {
    /**
     * ID for referencing the file (eg. via {@link StorageReader.getUrl | storage.getUrl})
     */
    storageId: StorageId;
    /**
     * Hex encoded sha256 checksum of file contents
     */
    sha256: string;
    /**
     * Size of the file in bytes
     */
    size: number;
    /**
     * ContentType of the file if it was provided on upload
     */
    contentType: string | null;
};

/**
 * An interface for defining filters in queries.
 *
 * `FilterBuilder` has various methods that produce {@link Expression}s.
 * These expressions can be nested together along with constants to express
 * a filter predicate.
 *
 * `FilterBuilder` is used within {@link OrderedQuery.filter} to create query
 * filters.
 *
 * Here are the available methods:
 *
 * |                               |                                               |
 * |-------------------------------|-----------------------------------------------|
 * | **Comparisons**               | Error when `l` and `r` are not the same type. |
 * | [`eq(l, r)`](#eq)             | `l === r`                                     |
 * | [`neq(l, r)`](#neq)           | `l !== r`                                     |
 * | [`lt(l, r)`](#lt)             | `l < r`                                       |
 * | [`lte(l, r)`](#lte)           | `l <= r`                                      |
 * | [`gt(l, r)`](#gt)             | `l > r`                                       |
 * | [`gte(l, r)`](#gte)           | `l >= r`                                      |
 * |                               |                                               |
 * | **Arithmetic**                | Error when `l` and `r` are not the same type. |
 * | [`add(l, r)`](#add)           | `l + r`                                       |
 * | [`sub(l, r)`](#sub)           | `l - r`                                       |
 * | [`mul(l, r)`](#mul)           | `l * r`                                       |
 * | [`div(l, r)`](#div)           | `l / r`                                       |
 * | [`mod(l, r)`](#mod)           | `l % r`                                       |
 * | [`neg(x)`](#neg)              | `-x`                                          |
 * |                               |                                               |
 * | **Logic**                     | Error if any param is not a `bool`.           |
 * | [`not(x)`](#not)              | `!x`                                          |
 * | [`and(a, b, ..., z)`](#and)   | `a && b && ... && z`                          |
 * | [`or(a, b, ..., z)`](#or)     | <code>a &#124;&#124; b &#124;&#124; ... &#124;&#124; z</code> |
 * |                               |                                               |
 * | **Other**                     |                                               |
 * | [`field(fieldPath)`](#field)  | Evaluates to the field at `fieldPath`.        |
 * @public
 */
export declare interface FilterBuilder<TableInfo extends GenericTableInfo> {
    /**
     * `l === r`
     *
     * @public
     * */
    eq<T extends Value | undefined>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    /**
     * `l !== r`
     *
     * @public
     * */
    neq<T extends Value | undefined>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    /**
     * `l < r`
     *
     * @public
     */
    lt<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    /**
     * `l <= r`
     *
     * @public
     */
    lte<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    /**
     * `l > r`
     *
     * @public
     */
    gt<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    /**
     * `l >= r`
     *
     * @public
     */
    gte<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    /**
     * `l + r`
     *
     * @public
     */
    add<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    /**
     * `l - r`
     *
     * @public
     */
    sub<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    /**
     * `l * r`
     *
     * @public
     */
    mul<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    /**
     * `l / r`
     *
     * @public
     */
    div<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    /**
     * `l % r`
     *
     * @public
     */
    mod<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    /**
     * `-x`
     *
     * @public
     */
    neg<T extends NumericValue>(x: ExpressionOrValue<T>): Expression<T>;
    /**
     * `exprs[0] && exprs[1] && ... && exprs[n]`
     *
     * @public
     */
    and(...exprs: Array<ExpressionOrValue<boolean>>): Expression<boolean>;
    /**
     * `exprs[0] || exprs[1] || ... || exprs[n]`
     *
     * @public
     */
    or(...exprs: Array<ExpressionOrValue<boolean>>): Expression<boolean>;
    /**
     * `!x`
     *
     * @public
     */
    not(x: ExpressionOrValue<boolean>): Expression<boolean>;
    /**
     * Evaluates to the field at the given `fieldPath`.
     *
     * For example, in {@link OrderedQuery.filter} this can be used to examine the values being filtered.
     *
     * #### Example
     *
     * On this object:
     * ```
     * {
     *   "user": {
     *     "isActive": true
     *   }
     * }
     * ```
     *
     * `field("user.isActive")` evaluates to `true`.
     *
     * @public
     */
    field<FieldPath extends FieldPaths<TableInfo>>(fieldPath: FieldPath): Expression<FieldTypeFromFieldPath<DocumentByInfo<TableInfo>, FieldPath>>;
}

/**
 * The arguments to a Convex query, mutation, or action function.
 *
 * Convex functions always take an arguments object that maps the argument
 * names to their values.
 *
 * @public
 */
export declare type FunctionArgs = Record<string, unknown>;

/**
 * A type representing the visibility of a Convex function.
 */
declare type FunctionVisibility = "public" | "internal";

/**
 * Description of the Convex functions available to an application.
 *
 * This is a generic type that expresses the shape of API types created by
 * `npx convex dev`. It's used to make the Convex clients type-safe.
 *
 * @public
 */
declare type GenericAPI = {
    publicQueries: Record<string, ConvexFunction>;
    allQueries: Record<string, ConvexFunction>;
    publicMutations: Record<string, ConvexFunction>;
    allMutations: Record<string, ConvexFunction>;
    publicActions: Record<string, ConvexFunction>;
    allActions: Record<string, ConvexFunction>;
};

/**
 * A type describing the tables in a Convex project.
 *
 * This is designed to be code generated with `npx convex dev`.
 * @public
 */
export declare type GenericDataModel = Record<string, GenericTableInfo>;

/**
 * A document stored in Convex.
 * @public
 */
export declare type GenericDocument = Record<string, Value>;

/**
 * A type describing all of the document fields in a table.
 *
 * These can either be field names (like "name") or references to fields on
 * nested objects (like "properties.name").
 * @public
 */
export declare type GenericFieldPaths = string;

/**
 * A type describing the ordered fields in an index.
 *
 * These can either be field names (like "name") or references to fields on
 * nested objects (like "properties.name").
 * @public
 */
export declare type GenericIndexFields = string[];

/**
 * A type describing the configuration of a search index.
 * @public
 */
export declare type GenericSearchIndexConfig = {
    searchField: string;
    filterFields: string;
};

/**
 * A type describing the indexes in a table.
 *
 * It's an object mapping each index name to the fields in the index.
 * @public
 */
export declare type GenericTableIndexes = Record<string, GenericIndexFields>;

/**
 * A type describing the document type and indexes in a table.
 * @public
 */
export declare type GenericTableInfo = {
    document: GenericDocument;
    fieldPaths: GenericFieldPaths;
    indexes: GenericTableIndexes;
    searchIndexes: GenericTableSearchIndexes;
};

/**
 * A type describing all of the search indexes in a table.
 *
 * This is an object mapping each index name to the config for the index.
 * @public
 */
export declare type GenericTableSearchIndexes = Record<string, GenericSearchIndexConfig>;

/** @public */
declare type Hourly = {
    /**
     * Minutes past the hour, 0-59.
     */
    minuteUTC: number;
};

/** @public */
declare type HourlySchedule = {
    type: "hourly";
    minuteUTC: number;
};

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link httpActionGeneric} a type specific to your data model
 * and functions.
 * @public
 */
export declare type HttpActionBuilderForAPI<API extends GenericAPI> = (func: (ctx: ActionCtx<API>, request: Request) => Promise<Response>) => PublicHttpAction;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped function. Route a URL path to this function in `convex/http.js`.
 *
 * @public
 */
export declare const httpActionGeneric: <API extends GenericAPI>(func: (ctx: ActionCtx<API>, request: Request) => Promise<Response>) => PublicHttpAction;

/**
 * HTTP router for specifying the paths and methods of {@link httpActionGeneric}s
 *
 * An example `convex/http.js` file might look like this.
 *
 * ```js
 * import { httpRouter } from "./_generated/server";
 * import { getMessagesByAuthor } from "./getMessagesByAuthor";
 * import { httpAction } from "./_generated/server";
 *
 * const http = httpRouter();
 *
 * // HTTP actions can be defined inline...
 * http.route({
 *   path: "/message",
 *   method: "POST",
 *   handler: httpAction(async ({ runMutation }, request) => {
 *     const { author, body } = await request.json();
 *
 *     await runMutation("sendMessage", { body, author });
 *     return new Response(null, {
 *       status: 200,
 *     });
 *   })
 * });
 *
 * // ...or they can be imported from other files.
 * http.route({
 *   path: "/getMessagesByAuthor",
 *   method: "GET",
 *   handler: getMessagesByAuthor,
 * });
 *
 * // Convex expects the router to be the default export of `convex/http.js`.
 * export default http;
 * ```
 *
 * @public
 */
export declare class HttpRouter {
    exactRoutes: Map<string, Map<RoutableMethod, PublicHttpAction>>;
    prefixRoutes: Map<RoutableMethod, Map<string, PublicHttpAction>>;
    isRouter: boolean;
    /**
     * Specify an HttpAction to be used to respond to requests
     * for an HTTP method (e.g. "GET") and a path or pathPrefix.
     *
     * Paths must begin with a slash. Path prefixes must also end in a slash.
     *
     * ```js
     * // matches `/profile` (but not `/profile/`)
     * http.route({ path: "/profile", method: "GET", handler: getProfile})
     *
     * // matches `/profiles/`, `/profiles/abc`, and `/profiles/a/c/b` (but not `/profile`)
     * http.route({ pathPrefix: "/profile/", method: "GET", handler: getProfile})
     * ```
     */
    route: (spec: RouteSpec) => void;
    /**
     * Returns a list of routed HTTP actions.
     *
     * These are used to populate the list of routes shown in the Functions page of the Convex dashboard.
     *
     * @returns - an array of [path, method, endpoint] tuples.
     */
    getRoutes: () => (readonly [string, "POST" | "GET" | "PUT" | "DELETE" | "OPTIONS" | "PATCH", (...args: any[]) => any])[];
    /**
     * Returns the appropriate HTTP action and its routed request path and method.
     *
     * The path and method returned are used for logging and metrics, and should
     * match up with one of the routes returned by `getRoutes`.
     *
     * For example,
     *
     * ```js
     * http.route({ pathPrefix: "/profile/", method: "GET", handler: getProfile});
     *
     * http.lookup("/profile/abc", "GET") // returns [getProfile, "GET", "/profile/*"]
     *```
     *
     * @returns - a tuple [{@link PublicHttpAction}, method, path] or null.
     */
    lookup: (path: string, method: RoutableMethod | "HEAD") => Readonly<[PublicHttpAction, RoutableMethod, string]> | null;
    /**
     * Given a JSON string representation of a Request object, return a Response
     * by routing the request and running the appropriate endpoint or returning
     * a 404 Response.
     *
     * @param argsStr - a JSON string representing a Request object.
     *
     * @returns - a Response object.
     */
    runRequest: (argsStr: string) => Promise<string>;
}

/**
 * Return a new {@link HttpRouter} object.
 *
 * @public
 */
export declare const httpRouter: () => HttpRouter;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * **Important**: Use `myId.equals(otherId)` to check for equality.
 * Using `===` will not work because two different instances of `Id` can refer
 * to the same document.
 *
 * `Id`s are 17 bytes long and consist of:
 * - A 15-byte random value.
 * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.
 * This is encoded in base 62 ([0-9A-Za-z]).
 *
 * If you're using code generation, use the `Id` class typed for your data model in
 * `convex/_generated/dataModel.js`.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 *
 * @public
 */
declare class Id<TableName extends string> {
    /**
     * The table name this {@link GenericId} references.
     */
    readonly tableName: TableName;
    /**
     * The identifier string.
     *
     * This contains the characters `[0-9A-Za-z]`.
     */
    readonly id: string;
    constructor(tableName: TableName, id: string);
    /**
     * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.
     *
     * @param other - The other {@link GenericId} to compare to.
     * @returns `true` if the objects refer to the same document.
     */
    equals(other: unknown): boolean;
    /**
     * Parse a {@link GenericId} from its JSON representation.
     */
    static fromJSON(obj: any): Id<string>;
    /**
     * Convert a {@link GenericId} into its JSON representation.
     */
    toJSON(): JSONValue;
    /**
     * Convert a {@link GenericId} into its string representation.
     *
     * This includes the identifier but not the table name.
     */
    toString(): string;
    /**
     * Pretty-print this {@link GenericId} for debugging.
     */
    inspect(): string;
}

/**
 * The database indexes in a table for a given {@link GenericTableInfo}.
 *
 * This will be an object mapping index names to the fields in the index.
 * @public
 */
export declare type Indexes<TableInfo extends GenericTableInfo> = TableInfo["indexes"];

/**
 * The names of indexes in a table for a given {@link GenericTableInfo}.
 * @public
 */
export declare type IndexNames<TableInfo extends GenericTableInfo> = keyof Indexes<TableInfo>;

/**
 * An expression representing an index range created by
 * {@link IndexRangeBuilder}.
 * @public
 */
export declare abstract class IndexRange {
    private _isIndexRange;
    /**
     * @internal
     */
    constructor();
}

/**
 * Builder to define an index range to query.
 *
 * An index range is a description of which documents Convex should consider
 * when running the query.
 *
 * An index range is always a chained list of:
 * 1. 0 or more equality expressions defined with `.eq`.
 * 2. [Optionally] A lower bound expression defined with `.gt` or `.gte`.
 * 3. [Optionally] An upper bound expression defined with `.lt` or `.lte`.
 *
 * **You must step through fields in index order.**
 *
 * Each equality expression must compare a different index field, starting from
 * the beginning and in order. The upper and lower bounds must follow the
 * equality expressions and compare the next field.
 *
 * For example, if there is an index of messages on
 * `["projectId", "priority"]`, a range searching for "messages in 'myProjectId'
 * with priority at least 100" would look like:
 * ```ts
 * q.eq("projectId", myProjectId)
 *  .gte("priority", 100)
 * ```
 *
 * **The performance of your query is based on the specificity of the range.**
 *
 * This class is designed to only allow you to specify ranges that Convex can
 * efficiently use your index to find. For all other filtering use
 * {@link Query.filter}.
 *
 * To learn about indexes, see [Indexes](https://docs.convex.dev/using/indexes).
 * @public
 */
export declare interface IndexRangeBuilder<Document extends GenericDocument, IndexFields extends GenericIndexFields, FieldNum extends number = 0> extends LowerBoundIndexRangeBuilder<Document, IndexFields[FieldNum]> {
    /**
     * Restrict this range to documents where `doc[fieldName] === value`.
     *
     * @param fieldName - The name of the field to compare. Must be the next field
     * in the index.
     * @param value - The value to compare against.
     */
    eq(fieldName: IndexFields[FieldNum], value: FieldTypeFromFieldPath<Document, IndexFields[FieldNum]>): NextIndexRangeBuilder<Document, IndexFields, FieldNum>;
}

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * If you're using code generation, use the `internalAction` function in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @param func - The function. It receives a {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export declare const internalActionGeneric: ActionBuilder<any, "internal">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * If you're using code generation, use the `internalMutation` function in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export declare const internalMutationGeneric: MutationBuilder<any, any, "internal">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * If you're using code generation, use the `internalQuery` function in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export declare const internalQueryGeneric: QueryBuilder<any, "internal">;

/** @public */
declare type Interval = {
    /**
     * Run a job every `seconds` seconds, beginning
     * when the job is first deployed to Convex.
     */
    seconds: number;
    minutes?: undefined;
    hours?: undefined;
} | {
    /**
     * Run a job every `minutes` minutes, beginning
     * when the job is first deployed to Convex.
     */
    minutes: number;
    seconds?: undefined;
    hours?: undefined;
} | {
    /**
     * Run a job every `hours` hours, beginning when
     * when the job is first deployed to Convex.
     */
    hours: number;
    seconds?: undefined;
    minutes?: undefined;
};

/** @public */
declare type IntervalSchedule = {
    type: "interval";
    seconds: number;
} | {
    type: "interval";
    minutes: number;
} | {
    type: "interval";
    hours: number;
};

/**
 * The type of JavaScript values serializable to JSON.
 *
 * @public
 */
declare type JSONValue = null | boolean | number | string | JSONValue[] | {
    [key: string]: JSONValue;
};

/**
 * Builder to define the lower bound of an index range.
 *
 * See {@link IndexRangeBuilder}.
 *
 * @public
 */
declare interface LowerBoundIndexRangeBuilder<Document extends GenericDocument, IndexFieldName extends string> extends UpperBoundIndexRangeBuilder<Document, IndexFieldName> {
    /**
     * Restrict this range to documents where `doc[fieldName] > value`.
     *
     * @param fieldName - The name of the field to compare. Must be the next field
     * in the index.
     * @param value - The value to compare against.
     */
    gt(fieldName: IndexFieldName, value: FieldTypeFromFieldPath<Document, IndexFieldName>): UpperBoundIndexRangeBuilder<Document, IndexFieldName>;
    /**
     * Restrict this range to documents where `doc[fieldName] >= value`.
     *
     * @param fieldName - The name of the field to compare. Must be the next field
     * in the index.
     * @param value - The value to compare against.
     */
    gte(fieldName: IndexFieldName, value: FieldTypeFromFieldPath<Document, IndexFieldName>): UpperBoundIndexRangeBuilder<Document, IndexFieldName>;
}

/** @public */
declare type Monthly = {
    /**
     * 1-31, day of month. Days greater that 28 will not run every month.
     */
    day: number;
    /**
     * 0-23, hour of day. Remember to convert from your own time zone to UTC.
     */
    hourUTC: number;
    /**
     * 0-59, minute of hour. Remember to convert from your own time zone to UTC.
     */
    minuteUTC: number;
};

/** @public */
declare type MonthlySchedule = {
    type: "monthly";
    day: number;
    hourUTC: number;
    minuteUTC: number;
};

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link mutationGeneric} a type specific to your data model.
 * @public
 */
export declare type MutationBuilder<DataModel extends GenericDataModel, API extends GenericAPI, Visibility extends FunctionVisibility> = {
    <Output, ArgsValidator extends PropertyValidators>(func: ValidatedFunction<MutationCtx<DataModel, API>, ArgsValidator, Output>): RegisteredMutation<Visibility, [ObjectType<ArgsValidator>], Output>;
    <Output, Args extends ArgsArray = OneArgArray>(func: UnvalidatedFunction<MutationCtx<DataModel, API>, Args, Output>): RegisteredMutation<Visibility, Args, Output>;
};

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 *
 * If you're using code generation, use the `MutationCtx` type in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @public
 */
export declare interface MutationCtx<DataModel extends GenericDataModel, API extends GenericAPI> {
    /**
     * A utility for reading and writing data in the database.
     */
    db: DatabaseWriter<DataModel>;
    /**
     * Information about the currently authenticated user.
     */
    auth: Auth;
    /**
     * A utility for reading and writing files in storage.
     */
    storage: StorageWriter;
    /**
     * A utility for scheduling Convex functions to run in the future.
     */
    scheduler: Scheduler<API>;
}

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * If you're using code generation, use the `mutation` function in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export declare const mutationGeneric: MutationBuilder<any, any, "public">;

/**
 * The names of mutation functions in a Convex API.
 *
 * @public
 */
declare type MutationNames<API extends GenericAPI> = keyof API["allMutations"] & string;

/**
 * The type of an action in a Convex API.
 *
 * @public
 */
declare type NamedAction<API extends GenericAPI, Name extends ActionNames<API>> = API["allActions"][Name];

/**
 * Extract the fields of an index from a {@link GenericTableInfo} by name.
 * @public
 */
export declare type NamedIndex<TableInfo extends GenericTableInfo, IndexName extends IndexNames<TableInfo>> = Indexes<TableInfo>[IndexName];

/**
 * The type of a mutation function in a Convex API.
 *
 * @public
 */
declare type NamedMutation<API extends GenericAPI, Name extends MutationNames<API>> = API["allMutations"][Name];

/**
 * The type of a query function in a Convex API.
 *
 * @public
 */
declare type NamedQuery<API extends GenericAPI, Name extends QueryNames<API>> = API["allQueries"][Name];

/**
 * The type of a schedulable function in a Convex API.
 *
 * @public
 */
export declare type NamedSchedulableFunction<API extends GenericAPI, Name extends SchedulableFunctionNames<API>> = Name extends ActionNames<API> ? NamedAction<API, Name> : NamedMutation<API, Name>;

/**
 * Extract the fields of an index from a {@link GenericTableInfo} by name.
 * @public
 */
export declare type NamedSearchIndex<TableInfo extends GenericTableInfo, IndexName extends SearchIndexNames<TableInfo>> = SearchIndexes<TableInfo>[IndexName];

/**
 * Extract the `TableInfo` for a table in a {@link GenericDataModel} by table
 * name.
 *
 * @public
 */
export declare type NamedTableInfo<DataModel extends GenericDataModel, TableName extends keyof DataModel> = DataModel[TableName];

/**
 * An {@link IndexRangeBuilder} for the next field of the index.
 *
 * This type is careful to check if adding one to the `FieldNum` will exceed
 * the length of the `IndexFields`.
 */
declare type NextIndexRangeBuilder<Document extends GenericDocument, IndexFields extends GenericIndexFields, FieldNum extends number> = PlusOne<FieldNum> extends IndexFields["length"] ? IndexRange : IndexRangeBuilder<Document, IndexFields, PlusOne<FieldNum>>;

/**
 * The arguments to a function that takes no arguments (just an empty array).
 */
declare type NoArgsArray = [];

/**
 * The types of {@link Value} that can be used to represent numbers.
 *
 * @public
 */
declare type NumericValue = bigint | number;

declare type ObjectFieldType = {
    fieldType: ValidatorJSON;
    optional: boolean;
};

/**
 * Compute the type of an object from {@link PropertyValidators}.
 *
 * @public
 */
declare type ObjectType<Validators extends PropertyValidators> = Expand<{
    [Property in OptionalKeys<Validators>]?: Validators[Property]["type"];
} & {
    [Property in RequiredKeys<Validators>]: Validators[Property]["type"];
}>;

/**
 * The arguments array for a function that takes arguments.
 *
 * This is an array of a single {@link FunctionArgs} element.
 */
declare type OneArgArray = [FunctionArgs];

declare type OptionalKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = {
    [Property in keyof PropertyValidators]: PropertyValidators[Property]["isOptional"] extends true ? Property : never;
}[keyof PropertyValidators];

/**
 * An tuple type of the (maybe optional) arguments to `F`.
 *
 * This type is used to make methods involving arguments type safe while allowing
 * skipping the arguments for functions that don't require arguments.
 *
 * @public
 */
declare type OptionalRestArgs<F extends (args?: Record<string, Value>) => any> = Parameters<F>["length"] extends 0 ? [
args?: {}
] : [args: Parameters<F>[0]];

/**
 * A {@link Query} with an order that has already been defined.
 *
 * @public
 */
export declare interface OrderedQuery<TableInfo extends GenericTableInfo> extends AsyncIterable<DocumentByInfo<TableInfo>> {
    /**
     * Filter the query output, returning only the values for which `predicate` evaluates to true.
     *
     * @param predicate - An {@link Expression} constructed with the supplied {@link FilterBuilder} that specifies which documents to keep.
     * @returns - A new {@link OrderedQuery} with the given filter predicate applied.
     */
    filter(predicate: (q: FilterBuilder<TableInfo>) => Expression<boolean>): OrderedQuery<TableInfo>;
    /**
     * Take only the first `n` results from the pipeline so far.
     *
     * @param n - Limit for the number of results at this stage of the query pipeline.
     * @returns - A new {@link OrderedQuery} with the specified limit applied.
     *
     * @internal
     */
    limit(n: number): OrderedQuery<TableInfo>;
    /**
     * Load a page of `n` results and obtain a {@link Cursor} for loading more.
     *
     * Note: If this is called from a reactive query function the number of
     * results may not match `paginationOpts.numItems`!
     *
     * `paginationOpts.numItems` is only an initial value. After the first invocation,
     * `paginate` will return all items in the original query range. This ensures
     * that all pages will remain adjacent and non-overlapping.
     *
     * @param paginationOpts - A {@link PaginationOptions} object containing the number
     * of items to load and the cursor to start at.
     * @returns A {@link PaginationResult} containing the page of results and a
     * cursor to continue paginating.
     */
    paginate(paginationOpts: PaginationOptions): Promise<PaginationResult<DocumentByInfo<TableInfo>>>;
    /**
     * Execute the query and return all of the results as an array.
     *
     * Note: when processing a query with a lot of results, it's often better to use the `Query` as an
     * `AsyncIterable` instead.
     *
     * @returns - An array of all of the query's results.
     */
    collect(): Promise<Array<DocumentByInfo<TableInfo>>>;
    /**
     * Execute the query and return the first `n` results.
     *
     * @param n - The number of items to take.
     * @returns - An array of the first `n` results of the query (or less if the
     * query doesn't have `n` results).
     */
    take(n: number): Promise<Array<DocumentByInfo<TableInfo>>>;
    /**
     * Execute the query and return the first result if there is one.
     *
     * @returns - The first value of the query or `null` if the query returned no results.
     * */
    first(): Promise<DocumentByInfo<TableInfo> | null>;
    /**
     * Execute the query and return the singular result if there is one.
     *
     * @returns - The single result returned from the query or null if none exists.
     * @throws  Will throw an error if the query returns more than one result.
     */
    unique(): Promise<DocumentByInfo<TableInfo> | null>;
}

/**
 * The options passed to {@link OrderedQuery.paginate}.
 *
 * @public
 */
export declare interface PaginationOptions {
    /**
     * Number of items to load in this page of results.
     *
     * Note: This is only an initial value!
     *
     * If you are running this paginated query in a reactive query function, you
     * may receive more or less items than this if items were added to or removed
     * from the query range.
     */
    numItems: number;
    /**
     * A {@link Cursor} representing the start of this page or `null` to start
     * at the beginning of the query results.
     */
    cursor: Cursor | null;
    /**
     * What is the maximum number of rows that should be read from the database? This option
     * is different from `numItems` in that it controls the number of rows entering a query's
     * pipeline, where `numItems` controls the number of rows coming out. For example, a `filter`
     * may disqualify most of the rows coming in, so setting a low `numItems` would not help
     * bound its execution time. Instead, set a low `maximumRowsRead` to efficiently paginate
     * through the filter.
     *
     * @internal
     */
    maximumRowsRead?: number;
}

/**
 * The result of paginating using {@link OrderedQuery.paginate}.
 *
 * @public
 */
export declare interface PaginationResult<T> {
    /**
     * The page of results.
     */
    page: T[];
    /**
     * Have we reached the end of the results?
     */
    isDone: boolean;
    /**
     * A {@link Cursor} to continue loading more results.
     */
    continueCursor: Cursor;
}

/**
 * A type that adds 1 to a number literal type (up to 14).
 *
 * This is necessary to step through the fields in an index.
 */
declare type PlusOne<N extends number> = [
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15
][N];

/**
 * Validators for each property of an object.
 *
 * This is represented as an object mapping the property name to its
 * {@link Validator}.
 *
 * @public
 */
declare type PropertyValidators = Record<string, Validator<any, any, any>>;

/**
 * An HTTP action that is part of this app's public API.
 *
 * You can create public HTTP actions by wrapping your function in
 * {@link httpActionGeneric} and exporting it.
 *
 * @public
 */
export declare type PublicHttpAction = {
    (ctx: ActionCtx<any>, request: Request): Response;
    isHttp: true;
    isRegistered?: true;
    /** @internal */
    invokeHttpAction(request: Request): Promise<Response>;
};

/**
 * The {@link Query} interface allows functions to read values out of the database.
 *
 * **If you only need to load an object by ID, use `db.get(id)` instead.**
 *
 * Executing a query consists of calling
 * 1. (Optional) {@link Query.order} to define the order
 * 2. (Optional) {@link Query.filter} to refine the results
 * 3. A *consumer* method to obtain the results
 *
 * Queries are lazily evaluated. No work is done until iteration begins, so constructing and
 * extending a query is free. The query is executed incrementally as the results are iterated over,
 * so early terminating also reduces the cost of the query.
 *
 * It is more efficient to use `filter` expression rather than executing JavaScript to filter.
 *
 * |                                              | |
 * |----------------------------------------------|-|
 * | **Ordering**                                 | |
 * | [`order("asc")`](#order)                     | Define the order of query results. |
 * |                                              | |
 * | **Filtering**                                | |
 * | [`filter(...)`](#filter)                     | Filter the query results to only the values that match some condition. |
 * |                                              | |
 * | **Consuming**                                | Execute a query and return results in different ways. |
 * | [`[Symbol.asyncIterator]()`](#asynciterator) | The query's results can be iterated over using a `for await..of` loop. |
 * | [`collect()`](#collect)                      | Return all of the results as an array. |
 * | [`take(n: number)`](#take)                   | Return the first `n` results as an array. |
 * | [`first()`](#first)                          | Return the first result. |
 * | [`unique()`](#unique)                        | Return the only result, and throw if there is more than one result. |
 *
 * To learn more about how to write queries, see [Querying the Database](https://docs.convex.dev/using/database-queries).
 *
 * @public
 */
export declare interface Query<TableInfo extends GenericTableInfo> extends OrderedQuery<TableInfo> {
    /**
     * Filter the query output, returning only the values for which `predicate` evaluates to true.
     *
     * @param predicate - An {@link Expression} constructed with the supplied {@link FilterBuilder} that specifies which documents to keep.
     * @returns - A new {@link Query} with the given filter predicate applied.
     */
    filter(predicate: (q: FilterBuilder<TableInfo>) => Expression<boolean>): Query<TableInfo>;
    /**
     * Define the order of the query output.
     *
     * Use `"asc"` for an ascending order and `"desc"` for a descending order. If not specified, the order defaults to ascending.
     * @param order - The order to return results in.
     */
    order(order: "asc" | "desc"): OrderedQuery<TableInfo>;
}

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link queryGeneric} a type specific to your data model.
 * @public
 */
export declare type QueryBuilder<DataModel extends GenericDataModel, Visibility extends FunctionVisibility> = {
    <Output, ArgsValidator extends PropertyValidators>(func: ValidatedFunction<QueryCtx<DataModel>, ArgsValidator, Output>): RegisteredQuery<Visibility, [ObjectType<ArgsValidator>], Output>;
    <Output, Args extends ArgsArray = OneArgArray>(func: UnvalidatedFunction<QueryCtx<DataModel>, Args, Output>): RegisteredQuery<Visibility, Args, Output>;
};

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 *
 * If you're using code generation, use the `QueryCtx` type in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @public
 */
export declare interface QueryCtx<DataModel extends GenericDataModel> {
    /**
     * A utility for reading data in the database.
     */
    db: DatabaseReader<DataModel>;
    /**
     * Information about the currently authenticated user.
     */
    auth: Auth;
    /**
     * A utility for reading files in storage.
     */
    storage: StorageReader;
}

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * If you're using code generation, use the `query` function in
 * `convex/_generated/server.d.ts` which is typed for your data model.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export declare const queryGeneric: QueryBuilder<any, "public">;

/**
 * The {@link QueryInitializer} interface is the entry point for building a {@link Query}
 * over a Convex database table.
 *
 * There are two types of queries:
 * 1. Full table scans: Queries created with {@link QueryInitializer.fullTableScan} which
 * iterate over all of the documents in the table in insertion order.
 * 2. Indexed Queries: Queries created with {@link QueryInitializer.withIndex} which iterate
 * over an index range in index order.
 *
 * For convenience, {@link QueryInitializer} extends the {@link Query} interface, implicitly
 * starting a full table scan.
 *
 * @public
 */
export declare interface QueryInitializer<TableInfo extends GenericTableInfo> extends Query<TableInfo> {
    /**
     * Query by reading all of the values out of this table.
     *
     * This query's cost is relative to the size of the entire table, so this
     * should only be used on tables that will stay very small (say between a few
     * hundred and a few thousand documents) and are updated infrequently.
     *
     * @returns - The {@link Query} that iterates over every document of the table.
     */
    fullTableScan(): Query<TableInfo>;
    /**
     * Query by reading documents from an index on this table.
     *
     * This query's cost is relative to the number of documents that match the
     * index range expression.
     *
     * Results will be returned in index order.
     *
     * To learn about indexes, see [Indexes](https://docs.convex.dev/using/indexes).
     *
     * @param indexName - The name of the index to query.
     * @param indexRange - An optional index range constructed with the supplied
     *  {@link IndexRangeBuilder}. An index range is a description of which
     * documents Convex should consider when running the query. If no index
     * range is present, the query will consider all documents in the index.
     * @returns - The query that yields documents in the index.
     */
    withIndex<IndexName extends IndexNames<TableInfo>>(indexName: IndexName, indexRange?: (q: IndexRangeBuilder<DocumentByInfo<TableInfo>, NamedIndex<TableInfo, IndexName>>) => IndexRange): Query<TableInfo>;
    /**
     * Query by running a full text search against a search index.
     *
     * Search queries must always search for some text within the index's
     * `searchField`. This query can optionally add equality filters for any
     * `filterFields` specified in the index.
     *
     * Documents will be returned in relevance order based on how well they
     * match the search text.
     *
     * To learn about full text search, see [Indexes](https://docs.convex.dev/text-search).
     *
     * @param indexName - The name of the search index to query.
     * @param searchFilter - A search filter expression constructed with the
     * supplied {@link SearchFilterBuilder}. This defines the full text search to run
     * along with equality filtering to run within the search index.
     * @returns - A query that searches for matching documents, returning them
     * in relevancy order.
     */
    withSearchIndex<IndexName extends SearchIndexNames<TableInfo>>(indexName: IndexName, searchFilter: (q: SearchFilterBuilder<DocumentByInfo<TableInfo>, NamedSearchIndex<TableInfo, IndexName>>) => SearchFilter): OrderedQuery<TableInfo>;
    /**
     * The number of documents in the table.
     *
     * @internal
     */
    count(): Promise<number>;
}

/**
 * Helper types for interacting with the overall API type
 */
/**
 * The names of query functions in a Convex API.
 *
 * @public
 */
declare type QueryNames<API extends GenericAPI> = keyof API["allQueries"] & string;

/**
 * An action that is part of this app.
 *
 * You can create an action by wrapping your function in
 * {@link actionGeneric} or {@link internalActionGeneric} and exporting it.
 *
 * @public
 */
export declare type RegisteredAction<Visibility extends FunctionVisibility, Args extends ArgsArray, Output> = {
    (ctx: ActionCtx<any>, ...args: Args): Output;
    args: Args;
    output: Output;
    isAction: true;
    isRegistered?: true;
    /** @internal */
    invokeAction(requestId: string, argsStr: string): Promise<string>;
    /** @internal */
    exportArgs(): string;
} & VisibilityProperties<Visibility>;

/**
 * A mutation function that is part of this app.
 *
 * You can create a mutation by wrapping your function in
 * {@link mutationGeneric} or {@link internalMutationGeneric} and exporting it.
 *
 * @public
 */
export declare type RegisteredMutation<Visibility extends FunctionVisibility, Args extends ArgsArray, Output> = {
    (ctx: MutationCtx<any, any>, ...args: Args): Output;
    args: Args;
    output: Output;
    isMutation: true;
    isRegistered?: true;
    /** @internal */
    invokeMutation(argsStr: string): Promise<string>;
    /** @internal */
    exportArgs(): string;
} & VisibilityProperties<Visibility>;

/**
 * A query function that is part of this app.
 *
 * You can create a query by wrapping your function in
 * {@link queryGeneric} or {@link internalQueryGeneric} and exporting it.
 *
 * @public
 */
export declare type RegisteredQuery<Visibility extends FunctionVisibility, Args extends ArgsArray, Output> = {
    (ctx: QueryCtx<any>, ...args: Args): Output;
    args: Args;
    output: Output;
    isQuery: true;
    isRegistered?: true;
    /** @internal */
    invokeQuery(argsStr: string): Promise<string>;
    /** @internal */
    exportArgs(): string;
} & VisibilityProperties<Visibility>;

declare type RequiredKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;

/**
 * A list of the methods supported by Convex HTTP actions.
 *
 * HEAD is handled by Convex by running GET and stripping the body.
 * CONNECT is not supported and will not be supported.
 * TRACE is not supported and will not be supported.
 *
 * @public
 */
export declare const ROUTABLE_HTTP_METHODS: readonly ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"];

/**
 * A type representing the methods supported by Convex HTTP actions.
 *
 * HEAD is handled by Convex by running GET and stripping the body.
 * CONNECT is not supported and will not be supported.
 * TRACE is not supported and will not be supported.
 *
 * @public
 */
export declare type RoutableMethod = (typeof ROUTABLE_HTTP_METHODS)[number];

declare type RouteSpec = {
    path: string;
    method: RoutableMethod;
    handler: PublicHttpAction;
} | {
    pathPrefix: string;
    method: RoutableMethod;
    handler: PublicHttpAction;
};

/**
 * The names of all of the schedulable in a Convex API.
 *
 * These are all of the mutations and actions.
 *
 * @public
 */
export declare type SchedulableFunctionNames<API extends GenericAPI> = ActionNames<API> | MutationNames<API>;

/** @public */
declare type Schedule = CronSchedule | IntervalSchedule | HourlySchedule | DailySchedule | WeeklySchedule | MonthlySchedule;

/**
 * An interface to schedule Convex functions.
 *
 * You can schedule either mutations or actions. Mutations are guaranteed to execute
 * exactly once - they are automatically retried on transient errors and either execute
 * successfully or fail deterministically due to developer error in defining the
 * function. Actions execute at most once - they are not retried and might fail
 * due to transient errors.
 *
 * Consider using an {@link internalMutation} or {@link internalAction} to enforce that
 * these functions cannot be called directly from a Convex client.
 *
 * @public
 */
export declare interface Scheduler<API extends GenericAPI> {
    /**
     * Schedule a function to execute after a delay.
     *
     * @param delayMs - delay in milliseconds. Must be non-negative. If the delay
     * is zero, the scheduled function will be due to execute immediately after the
     * scheduling one completes.
     * @param name - the name of the function to schedule.
     * @param args - arguments to call the scheduled functions with.
     **/
    runAfter<Name extends SchedulableFunctionNames<API>>(delayMs: number, name: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): Promise<void>;
    /**
     * Schedule a function to execute at a given timestamp.
     *
     * @param timestamp - a Date or a timestamp (milliseconds since the epoch).
     * If the timestamp is in the past, the scheduled function will be due to
     * execute immediately after the scheduling one completes. The timestamp can't
     * be more than five years in the past or more than five years in the future.
     * @param name - the name of the function to schedule.
     * @param args - arguments to call the scheduled functions with.
     **/
    runAt<Name extends SchedulableFunctionNames<API>>(timestamp: number | Date, name: Name, ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>): Promise<void>;
}

/**
 * An expression representing a search filter created by
 * {@link SearchFilterBuilder}.
 *
 * @public
 */
export declare abstract class SearchFilter {
    private _isSearchFilter;
    /**
     * @internal
     */
    constructor();
}

/**
 * Builder for defining search filters.
 *
 * A search filter is a chained list of:
 * 1. One search expression constructed with `.search`.
 * 2. Zero or more equality expressions constructed with `.eq`.
 *
 * The search expression must search for text in the index's `searchField`. The
 * filter expressions can use any of the `filterFields` defined in the index.
 *
 * For all other filtering use {@link Query.filter}.
 *
 * To learn about full text search, see [Indexes](https://docs.convex.dev/text-search).
 * @public
 */
export declare interface SearchFilterBuilder<Document extends GenericDocument, SearchIndexConfig extends GenericSearchIndexConfig> {
    /**
     * Search for the terms in `query` within `doc[fieldName]`.
     *
     * This will do a full text search that returns results where any word of of
     * `query` appears in the field.
     *
     * Documents will be returned based on their relevance to the query. This
     * takes into account:
     * - How many words in the query appear in the text?
     * - How many times do they appear?
     * - How long is the text field?
     *
     * @param fieldName - The name of the field to search in. This must be listed
     * as the index's `searchField`.
     * @param query - The query text to search for.
     */
    search(fieldName: SearchIndexConfig["searchField"], query: string): SearchFilterFinalizer<Document, SearchIndexConfig>;
}

/**
 * Builder to define equality expressions as part of a search filter.
 *
 * See {@link SearchFilterBuilder}.
 *
 * @public
 */
export declare interface SearchFilterFinalizer<Document extends GenericDocument, SearchIndexConfig extends GenericSearchIndexConfig> extends SearchFilter {
    /**
     * Restrict this query to documents where `doc[fieldName] === value`.
     *
     * @param fieldName - The name of the field to compare. This must be listed in
     * the search index's `filterFields`.
     * @param value - The value to compare against.
     */
    eq<FieldName extends SearchIndexConfig["filterFields"]>(fieldName: FieldName, value: FieldTypeFromFieldPath<Document, FieldName>): SearchFilterFinalizer<Document, SearchIndexConfig>;
}

/**
 * The search indexes in a table for a given {@link GenericTableInfo}.
 *
 * This will be an object mapping index names to the search index config.
 * @public
 */
export declare type SearchIndexes<TableInfo extends GenericTableInfo> = TableInfo["searchIndexes"];

/**
 * The names of search indexes in a table for a given {@link GenericTableInfo}.
 * @public
 */
export declare type SearchIndexNames<TableInfo extends GenericTableInfo> = keyof SearchIndexes<TableInfo>;

/**
 * An interface to read and write files to storage within Convex actions and HTTP actions.
 *
 * @public
 */
export declare interface StorageActionWriter extends StorageWriter {
    /**
     * Get a Blob containing the file associated with the provided {@link StorageId}, or `null` if there is no file.
     */
    get(storageId: StorageId): Promise<Blob | null>;
    /**
     * Store the file contained in the Blob.
     *
     * If provided, this will verify the sha256 checksum matches the contents of the file.
     */
    store(blob: Blob, options?: {
        sha256?: string;
    }): Promise<StorageId>;
}

/**
 * A reference to a file in storage.
 *
 * This is used in the {@link StorageReader} and {@link StorageWriter} which are accessible in
 * Convex queries and mutations via {@link QueryCtx} and {@link MutationCtx} respectively.
 *
 * @public
 */
export declare type StorageId = string;

/**
 * An interface to read files from storage within Convex query functions.
 *
 * @public
 */
export declare interface StorageReader {
    /**
     * Get the URL for a file in storage by its {@link StorageId}.
     *
     * The GET response includes a standard HTTP Digest header with a sha256 checksum.
     *
     * @param storageId - The {@link StorageId} of the file to fetch from Convex storage.
     * @returns - A url which fetches the file via an HTTP GET, or `null` if it no longer exists.
     */
    getUrl(storageId: StorageId): Promise<string | null>;
    /**
     * Get metadata for a file.
     *
     * @param storageId - The {@link StorageId} of the file.
     * @returns - A {@link FileMetadata} object if found or `null` if not found.
     */
    getMetadata(storageId: StorageId): Promise<FileMetadata | null>;
}

/**
 * An interface to write files to storage within Convex mutation functions.
 *
 * @public
 */
export declare interface StorageWriter extends StorageReader {
    /**
     * Fetch a short-lived URL for uploading a file into storage.
     *
     * Upon a POST request to this URL, the endpoint will return a JSON object containing a newly allocated {@link StorageId}.
     *
     * The POST URL accepts an optional standard HTTP Digest header with a sha256 checksum.
     *
     * @returns - A url that allows file upload via an HTTP POST.
     */
    generateUploadUrl(): Promise<string>;
    /**
     * Delete a file from Convex storage.
     *
     * Once a file is deleted, any URLs previously generated by {@link StorageReader.getUrl} will return 404s.
     *
     * @param storageId - The {@link StorageId} of the file to delete from Convex storage.
     */
    delete(storageId: StorageId): Promise<void>;
}

/**
 * The fields that Convex automatically adds to documents, not including `_id`.
 *
 * This is an object type mapping field name to field type.
 * @public
 */
declare type SystemFields = {
    _creationTime: number;
};

/**
 * A type of all of the table names defined in a {@link GenericDataModel}.
 * @public
 */
export declare type TableNamesInDataModel<DataModel extends GenericDataModel> = keyof DataModel & string;

/**
 * The definition of a Convex query, mutation, or action function without
 * argument validation.
 *
 * Convex functions always take a context object as their first argument
 * and an (optional) args object as their second argument.
 *
 * This can be written as a function like:
 * ```js
 * import { query } from "./_generated/server";
 *
 * export const func = query(({ db }, { arg }) => {...});
 * ```
 * or as an object like:
 *
 * ```js
 * import { query } from "./_generated/server";
 *
 * export const func = query({
 *   handler: ({ db }, { arg }) => {...},
 * });
 * ```
 * See {@link ValidatedFunction} to add argument validation.
 *
 * @public
 */
export declare type UnvalidatedFunction<Ctx, Args extends ArgsArray, Output> = ((ctx: Ctx, ...args: Args) => Output) | {
    handler: (ctx: Ctx, ...args: Args) => Output;
};

/**
 * Builder to define the upper bound of an index range.
 *
 * See {@link IndexRangeBuilder}.
 *
 * @public
 */
declare interface UpperBoundIndexRangeBuilder<Document extends GenericDocument, IndexFieldName extends string> extends IndexRange {
    /**
     * Restrict this range to documents where `doc[fieldName] < value`.
     *
     * @param fieldName - The name of the field to compare. Must be the same index
     * field used in the lower bound (`.gt` or `.gte`) or the next field if no
     * lower bound was specified.
     * @param value - The value to compare against.
     */
    lt(fieldName: IndexFieldName, value: FieldTypeFromFieldPath<Document, IndexFieldName>): IndexRange;
    /**
     * Restrict this range to documents where `doc[fieldName] <= value`.
     *
     * @param fieldName - The name of the field to compare. Must be the same index
     * field used in the lower bound (`.gt` or `.gte`) or the next field if no
     * lower bound was specified.
     * @param value - The value to compare against.
     */
    lte(fieldName: IndexFieldName, value: FieldTypeFromFieldPath<Document, IndexFieldName>): IndexRange;
}

/**
 * Information about an authenticated user.
 *
 * The only fields guaranteed to be present are
 * {@link UserIdentity.tokenIdentifier} and {@link UserIdentity.issuer}. All
 * remaining fields may or may not be present depending on the information given
 * by the identity provider.
 *
 * See the [OpenID Connect specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
 * for more information on these fields.
 *
 * @public
 */
export declare interface UserIdentity {
    /**
     * A stable and globally unique string for this identity (i.e. no other
     * user, even from a different identity provider, will have the same string.)
     */
    readonly tokenIdentifier: string;
    /**
     * Identifier for the end-user from the identity provider, not necessarily
     * unique across different providers.
     */
    readonly subject: string;
    /**
     * The hostname of the identity provider used to authenticate this user.
     */
    readonly issuer: string;
    readonly name?: string;
    readonly givenName?: string;
    readonly familyName?: string;
    readonly nickname?: string;
    readonly preferredUsername?: string;
    readonly profileUrl?: string;
    readonly pictureUrl?: string;
    readonly email?: string;
    readonly emailVerified?: boolean;
    readonly gender?: string;
    readonly birthday?: string;
    readonly timezone?: string;
    readonly language?: string;
    readonly phoneNumber?: string;
    readonly phoneNumberVerified?: boolean;
    readonly address?: string;
    readonly updatedAt?: string;
}

/**
 * The definition of a Convex query, mutation, or action function with argument
 * validation.
 *
 * Argument validation allows you to assert that the arguments to this function
 * are the expected type.
 *
 * Example:
 *
 * ```js
 * import { query } from "./_generated/server";
 * import { v } from "convex/values";
 *
 * export const func = query({
 *   args: {
 *     arg: v.string()
 *   },
 *   handler: ({ db }, { arg }) => {...},
 * });
 * ```
 *
 * **For security, argument validation should be added to all public functions in
 * production apps.**
 *
 * See {@link UnvalidatedFunction} for functions without argument validation.
 * @public
 */
export declare interface ValidatedFunction<Ctx, ArgsValidator extends PropertyValidators, Output> {
    /**
     * A validator for the arguments of this function.
     *
     * This is an object mapping argument names to validators constructed with
     * {@link values.v}.
     *
     * ```js
     * import { v } from "convex/values";
     *
     * const args = {
     *   stringArg: v.string(),
     *   optionalNumberArg: v.optional(v.number()),
     * }
     * ```
     */
    args: ArgsValidator;
    /**
     * The implementation of this function.
     *
     * This is a function that takes in the appropriate context and arguments
     * and produces some result.
     *
     * @param ctx - The context object. This is one of {@link QueryCtx},
     * {@link MutationCtx}, or {@link ActionCtx} depending on the function type.
     * @param args - The arguments object for this function. This will match
     * the type defined by the argument validator.
     * @returns
     */
    handler: (ctx: Ctx, args: ObjectType<ArgsValidator>) => Output;
}

/**
 * A validator for a Convex value.
 *
 * This should be constructed using the validator builder, {@link v}.
 *
 * This class encapsulates:
 * - The TypeScript type of this value.
 * - Whether this field should be optional if it's included in an object.
 * - The TypeScript type for the set of index field paths that can be used to
 * build indexes on this value.
 * - A JSON representation of the validator.
 * @public
 */
declare class Validator<TypeScriptType, IsOptional extends boolean = false, FieldPaths extends string = never> {
    readonly type: TypeScriptType;
    readonly isOptional: IsOptional;
    readonly fieldPaths: FieldPaths;
    readonly _isValidator: undefined;
    readonly optional: boolean;
    readonly json: ValidatorJSON;
    constructor(json: ValidatorJSON, optional: boolean);
}

declare type ValidatorJSON = {
    type: "null";
} | {
    type: "number";
} | {
    type: "bigint";
} | {
    type: "boolean";
} | {
    type: "string";
} | {
    type: "bytes";
} | {
    type: "any";
} | {
    type: "literal";
    value: JSONValue;
} | {
    type: "id";
    tableName: string;
} | {
    type: "array";
    value: ValidatorJSON;
} | {
    type: "set";
    value: ValidatorJSON;
} | {
    type: "map";
    keys: ValidatorJSON;
    values: ValidatorJSON;
} | {
    type: "object";
    value: Record<string, ObjectFieldType>;
} | {
    type: "union";
    value: ValidatorJSON[];
};

/**
 * A value supported by Convex.
 *
 * Values can be:
 * - stored inside of documents.
 * - used as arguments and return types to queries and mutation functions.
 *
 * You can see the full set of supported types at
 * [Types](https://docs.convex.dev/using/types).
 *
 * @public
 */
declare type Value = Id<string> | null | bigint | number | boolean | string | ArrayBuffer | Value[] | Set<Value> | Map<Value, Value> | {
    [key: string]: undefined | Value;
};

/**
 * Given a {@link FunctionVisibility}, should this function have `isPublic: true`
 * or `isInternal: true`?
 */
declare type VisibilityProperties<Visiblity extends FunctionVisibility> = Visiblity extends "public" ? {
    isPublic: true;
} : {
    isInternal: true;
};

/** @public */
declare type Weekly = {
    /**
     * "monday", "tuesday", etc.
     */
    dayOfWeek: DayOfWeek;
    /**
     * 0-23, hour of day. Remember to convert from your own time zone to UTC.
     */
    hourUTC: number;
    /**
     * 0-59, minute of hour. Remember to convert from your own time zone to UTC.
     */
    minuteUTC: number;
};

/** @public */
declare type WeeklySchedule = {
    type: "weekly";
    dayOfWeek: DayOfWeek;
    hourUTC: number;
    minuteUTC: number;
};

/**
 * A Convex document with the system fields like `_id` and `_creationTime` optional.
 *
 * @public
 */
declare type WithOptionalSystemFields<Document extends GenericDocument> = Expand<WithoutSystemFields<Document> & Partial<Pick<Document, keyof SystemFields | "_id">>>;

/**
 * A Convex document with the system fields like `_id` and `_creationTime` omitted.
 *
 * @public
 */
export declare type WithoutSystemFields<Document extends GenericDocument> = Expand<BetterOmit<Document, keyof SystemFields | "_id">>;

export { }
