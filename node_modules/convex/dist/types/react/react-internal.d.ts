import { default as React_2 } from 'react';
import { ReactNode } from 'react';

/**
 * The names of actions in a Convex API.
 *
 * @public
 */
declare type ActionNames<API extends GenericAPI> = keyof API["allActions"] & string;

/**
 * A tuple type of the (maybe optional) arguments to `F`, followed by an options
 * object of type `Options`.
 *
 * This type is used to make methods like `useQuery` type-safe while allowing
 * 1. Skipping arguments for functions that don't require arguments.
 * 2. Skipping the options object.
 * @public
 */
declare type ArgsAndOptions<F extends (args?: Record<string, Value>) => any, Options> = Parameters<F>["length"] extends 0 ? [
args?: {},
options?: Options
] : [args: Parameters<F>[0], options?: Options];

/**
 * The type of the arguments to a Convex function.
 *
 * This is represented as a single object mapping argument names to values.
 * Functions that don't need any arguments object are represented as `{}`.
 * @public
 */
declare type ArgsObject<F extends (args?: Record<string, Value>) => any> = Parameters<F>["length"] extends 0 ? {} : Parameters<F>[0] & Record<string, Value>;

/**
 * Renders children if the client is authenticated.
 *
 * @public
 */
export declare function Authenticated({ children }: {
    children: ReactNode;
}): JSX.Element | null;

/**
 * Renders children if the client isn't using authentication or is in the process
 * of authenticating.
 *
 * @public
 */
export declare function AuthLoading({ children }: {
    children: ReactNode;
}): JSX.Element | null;

/**
 * An async function returning the JWT-encoded OpenID Connect Identity Token
 * if available.
 *
 * `forceRefreshToken` is `true` if the server rejected a previously
 * returned token, and the client should try to fetch a new one.
 *
 * See {@link ConvexReactClient.setAuth}.
 *
 * @public
 */
export declare type AuthTokenFetcher = (args: {
    forceRefreshToken: boolean;
}) => Promise<string | null | undefined>;

/**
 * Low-level client for directly integrating state management libraries
 * with Convex.
 *
 * Most developers should use higher level clients, like
 * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.
 *
 * @public
 */
declare class BaseConvexClient {
    private readonly address;
    private readonly state;
    private readonly requestManager;
    private readonly webSocketManager;
    private readonly authenticationManager;
    private remoteQuerySet;
    private readonly optimisticQueryResults;
    private readonly onTransition;
    private nextRequestId;
    private readonly sessionId;
    private fetchToken;
    private refetchTokenTimeoutId;
    private firstMessageReceived;
    private readonly verbose;
    private readonly debug;
    /**
     * @param address - The url of your Convex deployment, often provided
     * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
     * @param onTransition - A callback receiving an array of query tokens
     * corresponding to query results that have changed.
     * @param options - See {@link ClientOptions} for a full description.
     */
    constructor(address: string, onTransition: (updatedQueries: QueryToken[]) => void, options?: ClientOptions);
    /**
     * Compute the current query results based on the remoteQuerySet and the
     * current optimistic updates and call `onTransition` for all the changed
     * queries.
     *
     * @param completedMutations - A set of mutation IDs whose optimistic updates
     * are no longer needed.
     */
    private notifyOnQueryResultChanges;
    setAuth(fetchToken: AuthTokenFetcher, onChange: (isAuthenticated: boolean) => void): void;
    hasAuth(): boolean;
    /** @internal */
    setAdminAuth(value: string, fakeUserIdentity?: UserIdentityAttributes): void;
    clearAuth(): void;
    /**
     * Subscribe to a query function.
     *
     * Whenever this query's result changes, the `onTransition` callback
     * passed into the constructor will be called.
     *
     * @param name - The name of the query.
     * @param args - An arguments object for the query. If this is omitted, the
     * arguments will be `{}`.
     * @param options - A {@link SubscribeOptions} options object for this query.

     * @returns An object containing a {@link QueryToken} corresponding to this
     * query and an `unsubscribe` callback.
     */
    subscribe(name: string, args?: Record<string, Value>, options?: SubscribeOptions): {
        queryToken: QueryToken;
        unsubscribe: () => void;
    };
    /**
     * A query result based only on the current, local state.
     *
     * The only way this will return a value is if we're already subscribed to the
     * query or its value has been set optimistically.
     */
    localQueryResult(udfPath: string, args?: Record<string, Value>): Value | undefined;
    /**
     * @internal
     */
    localQueryLogs(udfPath: string, args?: Record<string, Value>): string[] | undefined;
    /**
     * Retrieve the current {@link QueryJournal} for this query function.
     *
     * If we have not yet received a result for this query, this will be `undefined`.
     *
     * @param name - The name of the query.
     * @param args - The arguments object for this query.
     * @returns The query's {@link QueryJournal} or `undefined`.
     */
    queryJournal(name: string, args?: Record<string, Value>): QueryJournal | undefined;
    /**
     * Get the current {@link ConnectionState} between the client and the Convex
     * backend.
     *
     * @returns The {@link ConnectionState} with the Convex backend.
     */
    connectionState(): ConnectionState;
    /**
     * Execute a mutation function.
     *
     * @param name - The name of the mutation.
     * @param args - An arguments object for the mutation. If this is omitted,
     * the arguments will be `{}`.
     * @param options - A {@link MutationOptions} options object for this mutation.

     * @returns - A promise of the mutation's result.
     */
    mutation(name: string, args?: Record<string, Value>, options?: MutationOptions_2): Promise<any>;
    /**
     * @internal
     */
    mutationInternal(udfPath: string, args?: Record<string, Value>, options?: MutationOptions_2): Promise<FunctionResult>;
    /**
     * Execute an action function.
     *
     * @param name - The name of the action.
     * @param args - An arguments object for the action. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the action's result.
     */
    action(name: string, args?: Record<string, Value>): Promise<any>;
    /**
     * @internal
     */
    actionInternal(udfPath: string, args?: Record<string, Value>): Promise<FunctionResult>;
    /**
     * Close any network handles associated with this client and stop all subscriptions.
     *
     * Call this method when you're done with an {@link BaseConvexClient} to
     * dispose of its sockets and resources.
     *
     * @returns A `Promise` fulfilled when the connection has been completely closed.
     */
    close(): Promise<void>;
    private _logVerbose;
    private mark;
    /**
     * Reports performance marks to the server. This should only be called when
     * we have a functional websocket.
     */
    private reportMarks;
    private tryReportLongDisconnect;
}

/**
 * An `Omit<>` type that:
 * 1. Applies to each element of a union.
 * 2. Preserves the index signature of the underlying type.
 */
declare type BetterOmit<T, K extends keyof T> = {
    [Property in keyof T as Property extends K ? never : Property]: T[Property];
};

/**
 * Options for {@link BaseConvexClient}.
 *
 * @public
 */
declare interface ClientOptions {
    /**
     * Whether to prompt the user if they have unsaved changes pending
     * when navigating away or closing a web page.
     *
     * This is only possible when the `window` object exists, i.e. in a browser.
     *
     * The default value is `true` in browsers.
     */
    unsavedChangesWarning?: boolean;
    /**
     * Specifies an alternate
     * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
     * constructor to use for client communication with the Convex cloud.
     * The default behavior is to use `WebSocket` from the global environment.
     */
    webSocketConstructor?: typeof WebSocket;
    /**
     * Adds additional logging for debugging purposes.
     *
     * The default value is `false`.
     */
    verbose?: boolean;
    /**
     * Sends additional metrics to Convex for debugging purposes.
     *
     * The default value is `false`.
     */
    reportDebugInfoToConvex?: boolean;
}

/**
 * State describing the client's connection with the Convex backend.
 *
 * @public
 */
declare type ConnectionState = {
    hasInflightRequests: boolean;
    isWebSocketConnected: boolean;
    timeOfOldestInflightRequest: Date | null;
};

/**
 * Type representing the state of an auth integration with Convex.
 *
 * @public
 */
export declare type ConvexAuthState = {
    isLoading: boolean;
    isAuthenticated: boolean;
};

/**
 * The type of a Convex function in a {@link GenericAPI}.
 *
 * @public
 */
declare type ConvexFunction = (args?: any) => any;

/**
 * Provides an active Convex {@link ConvexReactClient} to descendants of this component.
 *
 * Wrap your app in this component to use Convex hooks `useQuery`,
 * `useMutation`, and `useConvex`.
 *
 * @param props - an object with a `client` property that refers to a {@link ConvexReactClient}.
 *
 * @public
 */
export declare const ConvexProvider: React_2.FC<{
    client: ConvexReactClient<any>;
    children?: React_2.ReactNode;
}>;

/**
 * A replacement for {@link ConvexProvider} which additionally provides
 * {@link ConvexAuthState} to descendants of this component.
 *
 * Use this to integrate any auth provider with Convex. The `useAuth` prop
 * should be a React hook that returns the provider's authentication state
 * and a function to fetch a JWT access token.
 *
 * See [Custom Auth Integration](https://docs.convex.dev/auth/custom-auth) for more information.
 *
 * @public
 */
export declare function ConvexProviderWithAuth({ children, client, useAuth, }: {
    children?: ReactNode;
    client: IConvexReactClient;
    useAuth: () => {
        isLoading: boolean;
        isAuthenticated: boolean;
        fetchAccessToken: (args: {
            forceRefreshToken: boolean;
        }) => Promise<string | null>;
    };
}): JSX.Element;

/**
 * A Convex client for use within React.
 *
 * This loads reactive queries and executes mutations over a WebSocket.
 *
 * @typeParam API - The API of your application, composed of all Convex queries
 * and mutations. `npx convex dev` [generates this type](/generated-api/react#convexapi)
 * in `convex/_generated/react.d.ts`.
 * @public
 */
export declare class ConvexReactClient<API extends GenericAPI> {
    private address;
    private cachedSync?;
    private listeners;
    private options;
    private closed;
    private adminAuth?;
    private fakeUserIdentity?;
    /**
     * @param address - The url of your Convex deployment, often provided
     * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
     * @param options - See {@link ClientOptions} for a full description.
     */
    constructor(address: string, options?: ClientOptions);
    /**
     * Lazily instantiate the `BaseConvexClient` so we don't create the WebSocket
     * when server-side rendering.
     *
     * @internal
     */
    get sync(): BaseConvexClient;
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     * `fetchToken` will be called automatically again if a token expires.
     * `fetchToken` should return `null` if the token cannot be retrieved, for example
     * when the user's rights were permanently revoked.
     * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token
     * @param onChange - a callback that will be called when the authentication status changes
     */
    setAuth(fetchToken: AuthTokenFetcher, onChange?: (isAuthenticated: boolean) => void): void;
    /**
     * Clear the current authentication token if set.
     */
    clearAuth(): void;
    /**
     * @internal
     */
    setAdminAuth(token: string, identity?: UserIdentityAttributes): void;
    /**
     * Construct a new {@link Watch} on a Convex query function.
     *
     * **Most application code should not call this method directly. Instead use
     * the `useQuery` hook generated by `npx convex dev`.**
     *
     * @param name - The name of the query function.
     * @param args - An arguments object for the query. If this is omitted,
     * the arguments will be `{}`.
     * @param options - A {@link WatchQueryOptions} options object for this query.
     *
     * @returns The {@link Watch} object.
     */
    watchQuery<Name extends PublicQueryNames<API>>(name: Name, ...argsAndOptions: ArgsAndOptions<NamedQuery<API, Name>, WatchQueryOptions>): Watch<ReturnType<NamedQuery<API, Name>>>;
    /**
     * Execute a mutation function.
     *
     * If you are within a React component, use the `useMutation` hook generated
     * by `npx convex dev` instead.
     *
     * @param name - The name of the mutation.
     * @param args - An arguments object for the mutation. If this is omitted,
     * the arguments will be `{}`.
     * @param options - A {@link MutationOptions} options object for the mutation.
     * @returns A promise of the mutation's result.
     */
    mutation<Name extends PublicMutationNames<API>>(name: Name, ...argsAndOptions: ArgsAndOptions<NamedMutation<API, Name>, MutationOptions<API, ArgsObject<NamedMutation<API, Name>>>>): Promise<ReturnType<NamedMutation<API, Name>>>;
    /**
     * Execute an action function.
     *
     * If you are within a React component, use the `useAction` hook generated
     * by `npx convex dev` instead.
     *
     * @param name - The name of the action.
     * @param args - An arguments object for the action. If this is omitted,
     * the arguments will be `{}`.
     * @returns A promise of the action's result.
     */
    action<Name extends PublicActionNames<API>>(name: Name, ...args: OptionalRestArgs<NamedAction<API, Name>>): Promise<ReturnType<NamedAction<API, Name>>>;
    /**
     * Get the current {@link ConnectionState} between the client and the Convex
     * backend.
     *
     * @returns The {@link ConnectionState} with the Convex backend.
     */
    connectionState(): ConnectionState;
    /**
     * Close any network handles associated with this client and stop all subscriptions.
     *
     * Call this method when you're done with a {@link ConvexReactClient} to
     * dispose of its sockets and resources.
     *
     * @returns A `Promise` fulfilled when the connection has been completely closed.
     */
    close(): Promise<void>;
    private transition;
}

/**
 * An opaque identifier used for paginating a database query.
 *
 * Cursors are returned from {@link OrderedQuery.paginate} and represent the
 * point of the query where the page of results ended.
 *
 * To continue paginating, pass the cursor back into
 * {@link OrderedQuery.paginate} in the {@link PaginationOptions} object to
 * fetch another page of results.
 *
 * Note: Cursors can only be passed to _exactly_ the same database query that
 * they were generated from. You may not reuse a cursor between different
 * database queries.
 *
 * @public
 */
declare type Cursor = string;

/**
 * Common utilities for manipulating TypeScript types.
 * @module
 */
/**
 * Hack! This type causes TypeScript to simplify how it renders object types.
 *
 * It is functionally the identity for object types, but in practice it can
 * simplify expressions like `A & B`.
 */
declare type Expand<ObjectType extends Record<any, any>> = ObjectType extends Record<any, any> ? {
    [Key in keyof ObjectType]: ObjectType[Key];
} : never;

/**
 * The result of running a function on the server.
 *
 * If the function hit an exception it will have an `errorMessage`. Otherwise
 * it will produce a `Value`.
 *
 * @public
 */
declare type FunctionResult = {
    success: true;
    value: Value;
    logLines: string[];
} | {
    success: false;
    errorMessage: string;
    logLines: string[];
};

/**
 * Description of the Convex functions available to an application.
 *
 * This is a generic type that expresses the shape of API types created by
 * `npx convex dev`. It's used to make the Convex clients type-safe.
 *
 * @public
 */
declare type GenericAPI = {
    publicQueries: Record<string, ConvexFunction>;
    allQueries: Record<string, ConvexFunction>;
    publicMutations: Record<string, ConvexFunction>;
    allMutations: Record<string, ConvexFunction>;
    publicActions: Record<string, ConvexFunction>;
    allActions: Record<string, ConvexFunction>;
};

declare type IConvexReactClient = {
    setAuth(fetchToken: AuthTokenFetcher, onChange: (isAuthenticated: boolean) => void): void;
    clearAuth(): void;
};

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * **Important**: Use `myId.equals(otherId)` to check for equality.
 * Using `===` will not work because two different instances of `Id` can refer
 * to the same document.
 *
 * `Id`s are 17 bytes long and consist of:
 * - A 15-byte random value.
 * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.
 * This is encoded in base 62 ([0-9A-Za-z]).
 *
 * If you're using code generation, use the `Id` class typed for your data model in
 * `convex/_generated/dataModel.js`.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 *
 * @public
 */
declare class Id<TableName extends string> {
    /**
     * The table name this {@link GenericId} references.
     */
    readonly tableName: TableName;
    /**
     * The identifier string.
     *
     * This contains the characters `[0-9A-Za-z]`.
     */
    readonly id: string;
    constructor(tableName: TableName, id: string);
    /**
     * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.
     *
     * @param other - The other {@link GenericId} to compare to.
     * @returns `true` if the objects refer to the same document.
     */
    equals(other: unknown): boolean;
    /**
     * Parse a {@link GenericId} from its JSON representation.
     */
    static fromJSON(obj: any): Id<string>;
    /**
     * Convert a {@link GenericId} into its JSON representation.
     */
    toJSON(): JSONValue;
    /**
     * Convert a {@link GenericId} into its string representation.
     *
     * This includes the identifier but not the table name.
     */
    toString(): string;
    /**
     * Pretty-print this {@link GenericId} for debugging.
     */
    inspect(): string;
}

/**
 * Test whether a function matches the signature of {@link PaginatedQueryFunction}.
 */
declare type IsPaginatedQueryFunction<Func extends ConvexFunction> = Parameters<Func> extends [
args: {
    paginationOpts: PaginationOptions;
}
] ? ReturnType<Func> extends PaginationResult<any> ? true : false : false;

/**
 * The type of JavaScript values serializable to JSON.
 *
 * @public
 */
declare type JSONValue = null | boolean | number | string | JSONValue[] | {
    [key: string]: JSONValue;
};

/**
 * The names of mutation functions in a Convex API.
 *
 * @public
 */
declare type MutationNames<API extends GenericAPI> = keyof API["allMutations"] & string;

/**
 * Options for {@link ConvexReactClient.mutation}.
 *
 * @public
 */
export declare interface MutationOptions<API extends GenericAPI, Args extends Record<string, Value>> {
    /**
     * An optimistic update to apply along with this mutation.
     *
     * An optimistic update locally updates queries while a mutation is pending.
     * Once the mutation completes, the update will be rolled back.
     */
    optimisticUpdate?: OptimisticUpdate<API, Args>;
}

/**
 * Options for {@link BaseConvexClient.mutation}.
 *
 * @public
 */
declare interface MutationOptions_2 {
    /**
     * An optimistic update to apply along with this mutation.
     *
     * An optimistic update locally updates queries while a mutation is pending.
     * Once the mutation completes, the update will be rolled back.
     */
    optimisticUpdate?: OptimisticUpdate<any, any>;
}

/**
 * The type of an action in a Convex API.
 *
 * @public
 */
declare type NamedAction<API extends GenericAPI, Name extends ActionNames<API>> = API["allActions"][Name];

/**
 * The type of a mutation function in a Convex API.
 *
 * @public
 */
declare type NamedMutation<API extends GenericAPI, Name extends MutationNames<API>> = API["allMutations"][Name];

/**
 * The type of a query function in a Convex API.
 *
 * @public
 */
declare type NamedQuery<API extends GenericAPI, Name extends QueryNames<API>> = API["allQueries"][Name];

/**
 * Optimistically update the values in a paginated list.
 *
 * This optimistic update is designed to be used to update data loaded with
 * {@link usePaginatedQueryGeneric}. It updates the list by applying
 * `updateValue` to each element of the list across all of the loaded pages.
 *
 * This will only apply to queries with a matching names and arguments.
 *
 * Example usage:
 * ```ts
 * const myMutation = useMutation("myMutationName")
 * .withOptimisticUpdate((localStore, mutationArg) => {
 *
 *   // Optimistically update the document with ID `mutationArg`
 *   // to have an additional property.
 *
 *   optimisticallyUpdateValueInPaginatedQuery(
 *     localStore,
 *     "paginatedQueryName",
 *     {},
 *     currentValue => {
 *       if (mutationArg.equals(currentValue._id)) {
 *         return {
 *           ...currentValue,
 *           "newProperty": "newValue",
 *         };
 *       }
 *       return currentValue;
 *     }
 *   );
 *
 * });
 * ```
 *
 * @param name - The name of the paginated query function.
 * @param args - The arguments object to the query function, excluding the
 * `paginationOpts` property.
 * @param updateValue - A function to produce the new values.
 *
 * @public
 */
export declare function optimisticallyUpdateValueInPaginatedQuery<API extends GenericAPI, Name extends PaginatedQueryNames<API>>(localStore: OptimisticLocalStore<API>, name: Name, args: PaginatedQueryArgs<NamedQuery<API, Name>>, updateValue: (currentValue: PaginatedQueryReturnType<NamedQuery<API, Name>>) => PaginatedQueryReturnType<NamedQuery<API, Name>>): void;

/**
 * A view of the query results currently in the Convex client for use within
 * optimistic updates.
 *
 * @public
 */
declare interface OptimisticLocalStore<API extends GenericAPI = GenericAPI> {
    /**
     * Retrieve the result of a query from the client.
     *
     * Important: Query results should be treated as immutable!
     * Always make new copies of structures within query results to avoid
     * corrupting data within the client.
     *
     * @param name - The name of the query.
     * @param args - The arguments object for this query.
     * @returns The query result or `undefined` if the query is not currently
     * in the client.
     */
    getQuery<Name extends PublicQueryNames<API>>(name: Name, ...args: OptionalRestArgs<NamedQuery<API, Name>>): undefined | ReturnType<NamedQuery<API, Name>>;
    /**
     * Retrieve the results are arguments of all queries with a given name.
     *
     * This is useful for complex optimistic updates that need to inspect and
     * update many query results (for example updating a paginated list).
     *
     * Important: Query results should be treated as immutable!
     * Always make new copies of structures within query results to avoid
     * corrupting data within the client.
     * @param name - The name of the query.
     * @returns An array of objects, one for each query of the given name.
     * Each object includes:
     *   - `args` - The arguments object for the query.
     *   - `value` The query result or `undefined` if the query is loading.
     */
    getAllQueries<Name extends PublicQueryNames<API>>(name: Name): {
        args: ArgsObject<NamedQuery<API, Name>>;
        value: undefined | ReturnType<NamedQuery<API, Name>>;
    }[];
    /**
     * Optimistically update the result of a query.
     *
     * This can either be a new value (perhaps derived from the old value from
     * {@link OptimisticLocalStore.getQuery}) or `undefined` to remove the query.
     * Removing a query is useful to create loading states while Convex recomputes
     * the query results.
     *
     * @param name - The name of the query.
     * @param args - The arguments object for this query.
     * @param value - The new value to set the query to or `undefined` to remove
     * it from the client.
     */
    setQuery<Name extends PublicQueryNames<API>>(name: Name, args: ArgsObject<NamedQuery<API, Name>>, value: undefined | ReturnType<NamedQuery<API, Name>>): void;
}

/**
 * A temporary, local update to query results within this client.
 *
 * This update will always be executed when a mutation is synced to the Convex
 * server and rolled back when the mutation completes.
 *
 * Note that optimistic updates can be called multiple times! If the client
 * loads new data while the mutation is in progress, the update will be replayed
 * again.
 *
 * @param localQueryStore - An interface to read and edit local query results.
 * @param args - The arguments to the mutation.
 *
 * @public
 */
declare type OptimisticUpdate<API extends GenericAPI, Args extends Record<string, Value>> = (localQueryStore: OptimisticLocalStore<API>, args: Args) => void;

/**
 * An tuple type of the (maybe optional) arguments to `F`.
 *
 * This type is used to make methods involving arguments type safe while allowing
 * skipping the arguments for functions that don't require arguments.
 *
 * @public
 */
declare type OptionalRestArgs<F extends (args?: Record<string, Value>) => any> = Parameters<F>["length"] extends 0 ? [
args?: {}
] : [args: Parameters<F>[0]];

/**
 * The type of the arguments to a {@link PaginatedQueryFunction}.
 *
 * This type includes the entire arguments object except the `paginationOpts`
 * property.
 *
 * @public
 */
export declare type PaginatedQueryArgs<Query extends PaginatedQueryFunction<any, any>> = Expand<BetterOmit<Parameters<Query>[0], "paginationOpts">>;

/**
 * A query function that is usable with {@link usePaginatedQueryGeneric}.
 *
 * The function's argument must be an object with a
 * `paginationOpts` property of type {@link server.PaginationOptions}.
 *
 * The function must return a {@link server.PaginationResult}.
 *
 * @public
 */
export declare type PaginatedQueryFunction<Args extends object, ReturnType> = (args: {
    paginationOpts: PaginationOptions;
} & Args) => PaginationResult<ReturnType>;

/**
 * The names of the paginated query functions in a Convex API.
 *
 * These are normal query functions that match {@link PaginatedQueryFunction}.
 *
 * @public
 */
export declare type PaginatedQueryNames<API extends GenericAPI> = {
    [QueryName in PublicQueryNames<API>]: IsPaginatedQueryFunction<NamedQuery<API, QueryName>> extends true ? QueryName : never;
}[PublicQueryNames<API>];

/**
 * The return type of a {@link PaginatedQueryFunction}.
 *
 * This is the type of the inner document or object within the
 * {@link server.PaginationResult} that a paginated query function returns.
 *
 * @public
 */
export declare type PaginatedQueryReturnType<Query extends PaginatedQueryFunction<any, any>> = Query extends PaginatedQueryFunction<any, infer ReturnType> ? ReturnType : never;

/**
 * The options passed to {@link OrderedQuery.paginate}.
 *
 * @public
 */
declare interface PaginationOptions {
    /**
     * Number of items to load in this page of results.
     *
     * Note: This is only an initial value!
     *
     * If you are running this paginated query in a reactive query function, you
     * may receive more or less items than this if items were added to or removed
     * from the query range.
     */
    numItems: number;
    /**
     * A {@link Cursor} representing the start of this page or `null` to start
     * at the beginning of the query results.
     */
    cursor: Cursor | null;
    /**
     * What is the maximum number of rows that should be read from the database? This option
     * is different from `numItems` in that it controls the number of rows entering a query's
     * pipeline, where `numItems` controls the number of rows coming out. For example, a `filter`
     * may disqualify most of the rows coming in, so setting a low `numItems` would not help
     * bound its execution time. Instead, set a low `maximumRowsRead` to efficiently paginate
     * through the filter.
     *
     * @internal
     */
    maximumRowsRead?: number;
}

/**
 * The result of paginating using {@link OrderedQuery.paginate}.
 *
 * @public
 */
declare interface PaginationResult<T> {
    /**
     * The page of results.
     */
    page: T[];
    /**
     * Have we reached the end of the results?
     */
    isDone: boolean;
    /**
     * A {@link Cursor} to continue loading more results.
     */
    continueCursor: Cursor;
}

/**
 * The names of public query functions in a Convex API.
 *
 * @public
 */
declare type PublicActionNames<API extends GenericAPI> = keyof API["publicActions"] & string;

/**
 * The names of public mutation functions in a Convex API.
 *
 * @public
 */
declare type PublicMutationNames<API extends GenericAPI> = keyof API["publicMutations"] & string;

/**
 * The names of public query functions in a Convex API.
 *
 * @public
 */
declare type PublicQueryNames<API extends GenericAPI> = keyof API["publicQueries"] & string;

/**
 * A serialized representation of decisions made during a query's execution.
 *
 * A journal is produced when a query function first executes and is re-used
 * when a query is re-executed.
 *
 * Currently this is used to store pagination end cursors to ensure
 * that pages of paginated queries will always end at the same cursor. This
 * enables gapless, reactive pagination.
 *
 * `null` is used to represent empty journals.
 * @public
 */
declare type QueryJournal = string | null;

/**
 * Helper types for interacting with the overall API type
 */
/**
 * The names of query functions in a Convex API.
 *
 * @public
 */
declare type QueryNames<API extends GenericAPI> = keyof API["allQueries"] & string;

/**
 * A string representing the name and arguments of a query.
 *
 * This is used by the {@link BaseConvexClient}.
 *
 * @public
 */
declare type QueryToken = string;

/**
 * An interface to execute a Convex action on the server.
 *
 * @public
 */
export declare interface ReactAction<API extends GenericAPI, Name extends PublicActionNames<API>> {
    /**
     * Execute the function on the server, returning a `Promise` of its return value.
     *
     * @param args - Arguments for the function to pass up to the server.
     * @returns The return value of the server-side function call.
     * @public
     */
    (...args: OptionalRestArgs<NamedAction<API, Name>>): Promise<ReturnType<NamedAction<API, Name>>>;
}

/**
 * An interface to execute a Convex mutation function on the server.
 *
 * @public
 */
export declare interface ReactMutation<API extends GenericAPI, Name extends PublicMutationNames<API>> {
    /**
     * Execute the mutation on the server, returning a `Promise` of its return value.
     *
     * @param args - Arguments for the mutation to pass up to the server.
     * @returns The return value of the server-side function call.
     */
    (...args: OptionalRestArgs<NamedMutation<API, Name>>): Promise<ReturnType<NamedMutation<API, Name>>>;
    /**
     * Define an optimistic update to apply as part of this mutation.
     *
     * This is a temporary update to the local query results to facilitate a
     * fast, interactive UI. It enables query results to update before a mutation
     * executed on the server.
     *
     * When the mutation is invoked, the optimistic update will be applied.
     *
     * Optimistic updates can also be used to temporarily remove queries from the
     * client and create loading experiences until a mutation completes and the
     * new query results are synced.
     *
     * The update will be automatically rolled back when the mutation is fully
     * completed and queries have been updated.
     *
     * @param optimisticUpdate - The optimistic update to apply.
     * @returns A new `ReactMutation` with the update configured.
     *
     * @public
     */
    withOptimisticUpdate(optimisticUpdate: OptimisticUpdate<API, ArgsObject<NamedMutation<API, Name>>>): ReactMutation<API, Name>;
}

/**
 * An object representing a request to load multiple queries.
 *
 * The keys of this object are identifiers and the values are objects containing
 * the name of the query function and the arguments to pass to it.
 *
 * This is used as an argument to {@link useQueriesGeneric}.
 * @public
 */
export declare type RequestForQueries = Record<string, {
    name: string;
    args: Record<string, Value>;
}>;

/**
 * Options for {@link BaseConvexClient.subscribe}.
 *
 * @public
 */
declare interface SubscribeOptions {
    /**
     * An (optional) journal produced from a previous execution of this query
     * function.
     *
     * If there is an existing subscription to a query function with the same
     * name and arguments, this journal will have no effect.
     */
    journal?: QueryJournal;
}

/**
 * Renders children if the client is using authentication but is not authenticated.
 *
 * @public
 */
export declare function Unauthenticated({ children }: {
    children: ReactNode;
}): JSX.Element | null;

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link useMutationGeneric} a type specific to your API.
 * @public
 */
export declare type UseActionForAPI<API extends GenericAPI> = <Name extends PublicActionNames<API>>(name: Name) => ReactAction<API, Name>;

/**
 * Construct a new {@link ReactAction}.
 *
 * Action objects can be called like functions to request execution of the
 * corresponding Convex function.
 *
 * The value returned by this hook is stable across renders, so it can be used
 * by React dependency arrays and memoization logic relying on object identity
 * without causing rerenders.
 *
 * If you're using code generation, use the `useAction` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * @param name - The name of the action.
 * @returns The {@link ReactAction} object with that name.
 *
 * @public
 */
export declare function useActionGeneric<API extends GenericAPI, Name extends PublicActionNames<API>>(name: Name): ReactAction<API, Name>;

/**
 * Get the {@link ConvexAuthState} within a React component.
 *
 * This relies on a Convex auth integration provider being above in the React
 * component tree.
 *
 * @returns The current {@link ConvexAuthState}.
 *
 * @public
 */
export declare function useConvexAuth(): {
    isLoading: boolean;
    isAuthenticated: boolean;
};

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link useConvexGeneric} a type specific to your API.
 * @public
 */
export declare type UseConvexForAPI<API extends GenericAPI> = () => ConvexReactClient<API>;

/**
 * Get the {@link ConvexReactClient} within a React component.
 *
 * This relies on the {@link ConvexProvider} being above in the React component tree.
 *
 * If you're using code generation, use the `useConvex` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * @returns The active {@link ConvexReactClient} object, or `undefined`.
 *
 * @public
 */
export declare function useConvexGeneric<API extends GenericAPI>(): ConvexReactClient<API>;

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link useMutationGeneric} a type specific to your API.
 * @public
 */
export declare type UseMutationForAPI<API extends GenericAPI> = <Name extends PublicMutationNames<API>>(name: Name) => ReactMutation<API, Name>;

/**
 * Construct a new {@link ReactMutation}.
 *
 * Mutation objects can be called like functions to request execution of the
 * corresponding Convex function, or further configured with
 * [optimistic updates](https://docs.convex.dev/using/optimistic-updates).
 *
 * The value returned by this hook is stable across renders, so it can be used
 * by React dependency arrays and memoization logic relying on object identity
 * without causing rerenders.
 *
 * If you're using code generation, use the `useMutation` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * @param name - The name of the mutation.
 * @returns The {@link ReactMutation} object with that name.
 *
 * @public
 */
export declare function useMutationGeneric<API extends GenericAPI, Name extends PublicMutationNames<API>>(name: Name): ReactMutation<API, Name>;

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link usePaginatedQueryGeneric} a type specific to your API.
 *
 * @public
 */
export declare type UsePaginatedQueryForAPI<API extends GenericAPI> = <Name extends PaginatedQueryNames<API>>(name: Name, args: PaginatedQueryArgs<NamedQuery<API, Name>>, options: {
    initialNumItems: number;
}) => UsePaginatedQueryResult<PaginatedQueryReturnType<NamedQuery<API, Name>>>;

/**
 * Load data reactively from a paginated query to a create a growing list.
 *
 * This can be used to power "infinite scroll" UIs.
 *
 * This hook must be used with Convex query functions that match
 * {@link PaginatedQueryFunction}. This means they must:
 * 1. Have a single arguments object with a `paginationOpts` property
 * of type {@link server.PaginationOptions}.
 * 2. Return a {@link server.PaginationResult}.
 *
 * `usePaginatedQueryGeneric` concatenates all the pages
 * of results into a single list and manages the continuation cursors when
 * requesting more items.
 *
 * Example usage:
 * ```typescript
 * const { results, status, loadMore } = usePaginatedQueryGeneric(
 *   "listMessages",
 *   { channel: "#general" },
 *   { initialNumItems: 5 }
 * );
 * ```
 *
 * If the query `name` or `args` change, the pagination state will be reset
 * to the first page. Similarly, if any of the pages result in an InvalidCursor
 * or QueryScannedTooManyDocuments error, the pagination state will also reset
 * to the first page.
 *
 * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).
 *
 * If you're using code generation, use the `usePaginatedQuery` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * @param name - The name of the query function.
 * @param args - The arguments object for the query function, excluding
 * the `paginationOpts` property. That property is injected by this hook.
 * @param options - An object specifying the `initialNumItems` to be loaded in
 * the first page.
 * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded
 * items, the status of the pagination, and a `loadMore` function.
 *
 * @public
 */
export declare function usePaginatedQueryGeneric(name: string, args: Record<string, Value>, options: {
    initialNumItems: number;
}): UsePaginatedQueryResult<any>;

/**
 * The result of calling the {@link usePaginatedQueryGeneric} hook.
 *
 * This includes:
 * 1. `results` - An array of the currently loaded results.
 * 2. `status` - The status of the pagination. The possible statuses are:
 *   - "CanLoadMore": This query may have more items to fetch. Call `loadMore` to
 *   fetch another page.
 *   - "LoadingMore": We're currently loading another page of results.
 *   - "Exhausted": We've paginated to the end of the list.
 * 3. `loadMore` A callback to fetch more results. This will be `undefined`
 * unless the status is "CanLoadMore".
 *
 * @public
 */
export declare type UsePaginatedQueryResult<T> = {
    results: T[];
} & ({
    status: "CanLoadMore";
    loadMore: (numItems: number) => void;
} | {
    status: "LoadingMore";
    loadMore: undefined;
} | {
    status: "Exhausted";
    loadMore: undefined;
});

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link useQueriesGeneric} a type specific to your API.
 *
 * @public
 */
export declare type UseQueriesForAPI<API extends GenericAPI> = <QueryNameMap extends Record<string, PublicQueryNames<API>>>(queries: {
    [Identifier in keyof QueryNameMap]: {
        name: QueryNameMap[Identifier];
        args: ArgsObject<NamedQuery<API, QueryNameMap[Identifier]>>;
    };
}) => {
    [Identifier in keyof QueryNameMap]: ReturnType<NamedQuery<API, QueryNameMap[Identifier]>> | undefined | Error;
};

/**
 * Load a variable number of reactive Convex queries.
 *
 * `useQueriesGeneric` is similar to {@link useQueryGeneric} but it allows
 * loading multiple queries which can be useful for loading a dynamic number
 * of queries without violating the rules of React hooks.
 *
 * This hook accepts an object whose keys are identifiers for each query and the
 * values are objects of `{ name: string, args: Record<string, Value> }`. The
 * `name` is the name of the Convex query function to load, and the `args` are
 * the arguments to that function.
 *
 * The hook returns an object that maps each identifier to the result of the query,
 * `undefined` if the query is still loading, or an instance of `Error` if the query
 * threw an exception.
 *
 * For example if you loaded a query like:
 * ```typescript
 * const results = useQueriesGeneric({
 *   messagesInGeneral: {
 *     name: "listMessages",
 *     args: { channel: "#general" }
 *   }
 * });
 * ```
 * then the result would look like:
 * ```typescript
 * {
 *   messagesInGeneral: [{
 *     channel: "#general",
 *     body: "hello"
 *     _id: ...,
 *     _creationTime: ...
 *   }]
 * }
 * ```
 *
 * This React hook contains internal state that will cause a rerender
 * whenever any of the query results change.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * If you're using code generation, use the `useQueries` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * @param queries - An object mapping identifiers to objects of
 * `{name: string, args: Record<string, Value> }` describing which query
 * functions to fetch.
 * @returns An object with the same keys as the input. The values are the result
 * of the query function, `undefined` if it's still loading, or an `Error` if
 * it threw an exception.
 *
 * @public
 */
export declare function useQueriesGeneric(queries: RequestForQueries): Record<string, any | undefined | Error>;

/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link useQueryGeneric} a type specific to your API.
 * @public
 */
export declare type UseQueryForAPI<API extends GenericAPI> = <Name extends PublicQueryNames<API>>(name: Name, ...argsAndOptions: ArgsAndOptions<NamedQuery<API, Name>, UseQueryOptions>) => ReturnType<NamedQuery<API, Name>> | undefined;

/**
 * Load a reactive query within a React component.
 *
 * This React hook contains internal state that will cause a rerender
 * whenever the query result changes.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * If you're using code generation, use the `useQuery` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * @param name - The name of the query function.
 * @param args - The arguments to the query function.
 * @returns `undefined` if loading and the query's return value otherwise.
 *
 * @public
 */
export declare function useQueryGeneric(name: string, args?: Record<string, Value>, _options?: UseQueryOptions): unknown | undefined;

/**
 * Options object for {@link useQueryGeneric}.
 *
 * @public
 */
export declare interface UseQueryOptions {
}

/**
 * Information about an authenticated user.
 *
 * The only fields guaranteed to be present are
 * {@link UserIdentity.tokenIdentifier} and {@link UserIdentity.issuer}. All
 * remaining fields may or may not be present depending on the information given
 * by the identity provider.
 *
 * See the [OpenID Connect specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
 * for more information on these fields.
 *
 * @public
 */
declare interface UserIdentity {
    /**
     * A stable and globally unique string for this identity (i.e. no other
     * user, even from a different identity provider, will have the same string.)
     */
    readonly tokenIdentifier: string;
    /**
     * Identifier for the end-user from the identity provider, not necessarily
     * unique across different providers.
     */
    readonly subject: string;
    /**
     * The hostname of the identity provider used to authenticate this user.
     */
    readonly issuer: string;
    readonly name?: string;
    readonly givenName?: string;
    readonly familyName?: string;
    readonly nickname?: string;
    readonly preferredUsername?: string;
    readonly profileUrl?: string;
    readonly pictureUrl?: string;
    readonly email?: string;
    readonly emailVerified?: boolean;
    readonly gender?: string;
    readonly birthday?: string;
    readonly timezone?: string;
    readonly language?: string;
    readonly phoneNumber?: string;
    readonly phoneNumberVerified?: boolean;
    readonly address?: string;
    readonly updatedAt?: string;
}

/** @internal */
declare type UserIdentityAttributes = Omit<UserIdentity, "tokenIdentifier">;

/**
 * Hook used for safely managing subscriptions in concurrent mode.
 *
 * In order to avoid removing and re-adding subscriptions each time this hook is called,
 * the parameters passed to this hook should be memoized in some wayâ€“
 * either by wrapping the entire params object with useMemo()
 * or by wrapping the individual callbacks with useCallback().
 *
 * @internal
 */
export declare function useSubscription<Value>({ getCurrentValue, subscribe, }: {
    getCurrentValue: () => Value;
    subscribe: (callback: () => void) => () => void;
}): Value;

/**
 * A value supported by Convex.
 *
 * Values can be:
 * - stored inside of documents.
 * - used as arguments and return types to queries and mutation functions.
 *
 * You can see the full set of supported types at
 * [Types](https://docs.convex.dev/using/types).
 *
 * @public
 */
declare type Value = Id<string> | null | bigint | number | boolean | string | ArrayBuffer | Value[] | Set<Value> | Map<Value, Value> | {
    [key: string]: undefined | Value;
};

/**
 * A watch on the output of a Convex query function.
 *
 * @public
 */
export declare interface Watch<T> {
    /**
     * Initiate a watch on the output of a query.
     *
     * This will subscribe to this query and call
     * the callback whenever the query result changes.
     *
     * **Important: If the query is already known on the client this watch will
     * never be invoked.** To get the current, local result call
     * {@link react.Watch.localQueryResult}.
     *
     * @param callback - Function that is called whenever the query result changes.
     * @returns - A function that disposes of the subscription.
     */
    onUpdate(callback: () => void): () => void;
    /**
     * Get the current result of a query.
     *
     * This will only return a result if we're already subscribed to the query
     * and have received a result from the server or the query value has been set
     * optimistically.
     *
     * @returns The result of the query or `undefined` if it isn't known.
     * @throws An error if the query encountered an error on the server.
     */
    localQueryResult(): T | undefined;
    /**
     * @internal
     */
    localQueryLogs(): string[] | undefined;
    /**
     * Get the current {@link browser.QueryJournal} for this query.
     *
     * If we have not yet received a result for this query, this will be `undefined`.
     */
    journal(): QueryJournal | undefined;
}

/**
 * Options for {@link ConvexReactClient.watchQuery}.
 *
 * @public
 */
export declare interface WatchQueryOptions {
    /**
     * An (optional) journal produced from a previous execution of this query
     * function.
     *
     * If there is an existing subscription to a query function with the same
     * name and arguments, this journal will have no effect.
     */
    journal?: QueryJournal;
}

export { }
