import { GenericAPI, NamedQuery } from "../api/index.js";
import { ConvexFunction, OptimisticLocalStore, PublicQueryNames } from "../browser/index.js";
import { PaginationOptions, PaginationResult } from "../server/index.js";
import { BetterOmit, Expand } from "../type_utils.js";
import { Value } from "../values/index.js";
/**
 * Load data reactively from a paginated query to a create a growing list.
 *
 * This can be used to power "infinite scroll" UIs.
 *
 * This hook must be used with Convex query functions that match
 * {@link PaginatedQueryFunction}. This means they must:
 * 1. Have a single arguments object with a `paginationOpts` property
 * of type {@link server.PaginationOptions}.
 * 2. Return a {@link server.PaginationResult}.
 *
 * `usePaginatedQueryGeneric` concatenates all the pages
 * of results into a single list and manages the continuation cursors when
 * requesting more items.
 *
 * Example usage:
 * ```typescript
 * const { results, status, loadMore } = usePaginatedQueryGeneric(
 *   "listMessages",
 *   { channel: "#general" },
 *   { initialNumItems: 5 }
 * );
 * ```
 *
 * If the query `name` or `args` change, the pagination state will be reset
 * to the first page. Similarly, if any of the pages result in an InvalidCursor
 * or QueryScannedTooManyDocuments error, the pagination state will also reset
 * to the first page.
 *
 * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).
 *
 * If you're using code generation, use the `usePaginatedQuery` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * @param name - The name of the query function.
 * @param args - The arguments object for the query function, excluding
 * the `paginationOpts` property. That property is injected by this hook.
 * @param options - An object specifying the `initialNumItems` to be loaded in
 * the first page.
 * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded
 * items, the status of the pagination, and a `loadMore` function.
 *
 * @public
 */
export declare function usePaginatedQueryGeneric(name: string, args: Record<string, Value>, options: {
    initialNumItems: number;
}): UsePaginatedQueryResult<any>;
/**
 * The result of calling the {@link usePaginatedQueryGeneric} hook.
 *
 * This includes:
 * 1. `results` - An array of the currently loaded results.
 * 2. `status` - The status of the pagination. The possible statuses are:
 *   - "CanLoadMore": This query may have more items to fetch. Call `loadMore` to
 *   fetch another page.
 *   - "LoadingMore": We're currently loading another page of results.
 *   - "Exhausted": We've paginated to the end of the list.
 * 3. `loadMore` A callback to fetch more results. This will be `undefined`
 * unless the status is "CanLoadMore".
 *
 * @public
 */
export declare type UsePaginatedQueryResult<T> = {
    results: T[];
} & ({
    status: "CanLoadMore";
    loadMore: (numItems: number) => void;
} | {
    status: "LoadingMore";
    loadMore: undefined;
} | {
    status: "Exhausted";
    loadMore: undefined;
});
/**
 * A query function that is usable with {@link usePaginatedQueryGeneric}.
 *
 * The function's argument must be an object with a
 * `paginationOpts` property of type {@link server.PaginationOptions}.
 *
 * The function must return a {@link server.PaginationResult}.
 *
 * @public
 */
export declare type PaginatedQueryFunction<Args extends object, ReturnType> = (args: {
    paginationOpts: PaginationOptions;
} & Args) => PaginationResult<ReturnType>;
/**
 * Test whether a function matches the signature of {@link PaginatedQueryFunction}.
 */
declare type IsPaginatedQueryFunction<Func extends ConvexFunction> = Parameters<Func> extends [
    args: {
        paginationOpts: PaginationOptions;
    }
] ? ReturnType<Func> extends PaginationResult<any> ? true : false : false;
/**
 * The names of the paginated query functions in a Convex API.
 *
 * These are normal query functions that match {@link PaginatedQueryFunction}.
 *
 * @public
 */
export declare type PaginatedQueryNames<API extends GenericAPI> = {
    [QueryName in PublicQueryNames<API>]: IsPaginatedQueryFunction<NamedQuery<API, QueryName>> extends true ? QueryName : never;
}[PublicQueryNames<API>];
/**
 * The type of the arguments to a {@link PaginatedQueryFunction}.
 *
 * This type includes the entire arguments object except the `paginationOpts`
 * property.
 *
 * @public
 */
export declare type PaginatedQueryArgs<Query extends PaginatedQueryFunction<any, any>> = Expand<BetterOmit<Parameters<Query>[0], "paginationOpts">>;
/**
 * The return type of a {@link PaginatedQueryFunction}.
 *
 * This is the type of the inner document or object within the
 * {@link server.PaginationResult} that a paginated query function returns.
 *
 * @public
 */
export declare type PaginatedQueryReturnType<Query extends PaginatedQueryFunction<any, any>> = Query extends PaginatedQueryFunction<any, infer ReturnType> ? ReturnType : never;
/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link usePaginatedQueryGeneric} a type specific to your API.
 *
 * @public
 */
export declare type UsePaginatedQueryForAPI<API extends GenericAPI> = <Name extends PaginatedQueryNames<API>>(name: Name, args: PaginatedQueryArgs<NamedQuery<API, Name>>, options: {
    initialNumItems: number;
}) => UsePaginatedQueryResult<PaginatedQueryReturnType<NamedQuery<API, Name>>>;
/**
 * Optimistically update the values in a paginated list.
 *
 * This optimistic update is designed to be used to update data loaded with
 * {@link usePaginatedQueryGeneric}. It updates the list by applying
 * `updateValue` to each element of the list across all of the loaded pages.
 *
 * This will only apply to queries with a matching names and arguments.
 *
 * Example usage:
 * ```ts
 * const myMutation = useMutation("myMutationName")
 * .withOptimisticUpdate((localStore, mutationArg) => {
 *
 *   // Optimistically update the document with ID `mutationArg`
 *   // to have an additional property.
 *
 *   optimisticallyUpdateValueInPaginatedQuery(
 *     localStore,
 *     "paginatedQueryName",
 *     {},
 *     currentValue => {
 *       if (mutationArg.equals(currentValue._id)) {
 *         return {
 *           ...currentValue,
 *           "newProperty": "newValue",
 *         };
 *       }
 *       return currentValue;
 *     }
 *   );
 *
 * });
 * ```
 *
 * @param name - The name of the paginated query function.
 * @param args - The arguments object to the query function, excluding the
 * `paginationOpts` property.
 * @param updateValue - A function to produce the new values.
 *
 * @public
 */
export declare function optimisticallyUpdateValueInPaginatedQuery<API extends GenericAPI, Name extends PaginatedQueryNames<API>>(localStore: OptimisticLocalStore<API>, name: Name, args: PaginatedQueryArgs<NamedQuery<API, Name>>, updateValue: (currentValue: PaginatedQueryReturnType<NamedQuery<API, Name>>) => PaginatedQueryReturnType<NamedQuery<API, Name>>): void;
export {};
//# sourceMappingURL=use_paginated_query.d.ts.map