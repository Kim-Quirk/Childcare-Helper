declare namespace Base64 {
    export {
        byteLength,
        toByteArray,
        fromByteArray
    }
}
export { Base64 }

/** @public */
declare function byteLength(b64: string): number;

/**
 * Convert a Convex value to its JSON representation.
 *
 * Use {@link jsonToConvex} to recreate the original value.
 *
 * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).
 *
 * @param value - A Convex value to convert into JSON.
 * @returns The JSON representation of `value`.
 *
 * @public
 */
export declare function convexToJson(value: Value): JSONValue;

/**
 * Common utilities for manipulating TypeScript types.
 * @module
 */
/**
 * Hack! This type causes TypeScript to simplify how it renders object types.
 *
 * It is functionally the identity for object types, but in practice it can
 * simplify expressions like `A & B`.
 */
declare type Expand<ObjectType extends Record<any, any>> = ObjectType extends Record<any, any> ? {
    [Key in keyof ObjectType]: ObjectType[Key];
} : never;

/** @public */
declare function fromByteArray(uint8: Uint8Array): string;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * **Important**: Use `myId.equals(otherId)` to check for equality.
 * Using `===` will not work because two different instances of `Id` can refer
 * to the same document.
 *
 * `Id`s are 17 bytes long and consist of:
 * - A 15-byte random value.
 * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.
 * This is encoded in base 62 ([0-9A-Za-z]).
 *
 * If you're using code generation, use the `Id` class typed for your data model in
 * `convex/_generated/dataModel.js`.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 *
 * @public
 */
export declare class GenericId<TableName extends string> {
    /**
     * The table name this {@link GenericId} references.
     */
    readonly tableName: TableName;
    /**
     * The identifier string.
     *
     * This contains the characters `[0-9A-Za-z]`.
     */
    readonly id: string;
    constructor(tableName: TableName, id: string);
    /**
     * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.
     *
     * @param other - The other {@link GenericId} to compare to.
     * @returns `true` if the objects refer to the same document.
     */
    equals(other: unknown): boolean;
    /**
     * Parse a {@link GenericId} from its JSON representation.
     */
    static fromJSON(obj: any): GenericId<string>;
    /**
     * Convert a {@link GenericId} into its JSON representation.
     */
    toJSON(): JSONValue;
    /**
     * Convert a {@link GenericId} into its string representation.
     *
     * This includes the identifier but not the table name.
     */
    toString(): string;
    /**
     * Pretty-print this {@link GenericId} for debugging.
     */
    inspect(): string;
}

/**
 * Internal type used in Convex code generation.
 *
 * @public
 */
export declare type GenericIdConstructor<TableNames extends string> = {
    new <TableName extends TableNames>(tableName: TableName, id: string): GenericId<TableName>;
    prototype: GenericId<string>;
    fromJSON(obj: any): GenericId<string>;
};

/**
 * Extract a TypeScript type from a validator.
 *
 * Example usage:
 * ```ts
 * const objectSchema = v.object({
 *   property: v.string(),
 * });
 * type MyObject = Infer<typeof objectSchema>; // { property: string }
 * ```
 * @typeParam V - The type of a {@link Validator} constructed with {@link v}.
 *
 * @public
 */
export declare type Infer<V extends Validator<any, any, any>> = V["type"];

/**
 * Join together two index field paths.
 *
 * This is used within the validator builder, {@link v}.
 * @public
 */
declare type JoinFieldPaths<Start extends string, End extends string> = `${Start}.${End}`;

/**
 * Parse a Convex value from its JSON representation.
 *
 * This function will revive classes like {@link GenericId} that have been serialized to JSON, parse out `BigInt`s, and so on.
 *
 * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).
 *
 * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.
 * @returns The JavaScript representation of the Convex value.
 *
 * @public
 */
export declare function jsonToConvex(value: JSONValue): Value;

/**
 * The type of JavaScript values serializable to JSON.
 *
 * @public
 */
export declare type JSONValue = null | boolean | number | string | JSONValue[] | {
    [key: string]: JSONValue;
};

/**
 * The types of {@link Value} that can be used to represent numbers.
 *
 * @public
 */
export declare type NumericValue = bigint | number;

declare type ObjectFieldType = {
    fieldType: ValidatorJSON;
    optional: boolean;
};

/**
 * Compute the type of an object from {@link PropertyValidators}.
 *
 * @public
 */
export declare type ObjectType<Validators extends PropertyValidators> = Expand<{
    [Property in OptionalKeys<Validators>]?: Validators[Property]["type"];
} & {
    [Property in RequiredKeys<Validators>]: Validators[Property]["type"];
}>;

/**
 * Calculate the type of a {@link Validator} for an object.
 *
 * This is used within the validator builder, {@link v}.
 */
declare type ObjectValidator<Validators extends PropertyValidators> = Validator<ObjectType<Validators>, false, {
    [Property in keyof Validators]: JoinFieldPaths<Property & string, Validators[Property]["fieldPaths"]> | Property;
}[keyof Validators] & string>;

declare type OptionalKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = {
    [Property in keyof PropertyValidators]: PropertyValidators[Property]["isOptional"] extends true ? Property : never;
}[keyof PropertyValidators];

/**
 * Validators for each property of an object.
 *
 * This is represented as an object mapping the property name to its
 * {@link Validator}.
 *
 * @public
 */
export declare type PropertyValidators = Record<string, Validator<any, any, any>>;

declare type RequiredKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;

/** @public */
declare function toByteArray(b64: string): Uint8Array;

/**
 * The validator builder.
 *
 * This builder allows you to build validators for Convex values.
 *
 * Validators can be used in [schema definitions](https://docs.convex.dev/database/schemas)
 * and as input validators for Convex functions.
 * @public
 */
export declare const v: {
    id<TableName extends string>(tableName: TableName): Validator<GenericId<TableName>, false, never>;
    null(): Validator<null>;
    number(): Validator<number>;
    bigint(): Validator<bigint>;
    boolean(): Validator<boolean>;
    string(): Validator<string>;
    bytes(): Validator<ArrayBuffer>;
    literal<T extends string | number | bigint | boolean>(literal: T): Validator<T, false, never>;
    array<T_1>(values: Validator<T_1, false, any>): Validator<T_1[], false, never>;
    set<T_2>(values: Validator<T_2, false, any>): Validator<Set<T_2>, false, never>;
    map<K, V>(keys: Validator<K, false, any>, values: Validator<V, false, any>): Validator<Map<K, V>, false, never>;
    object<T_3 extends PropertyValidators>(schema: T_3): ObjectValidator<T_3>;
    union<T_4 extends [Validator<any, false, any>, Validator<any, false, any>, ...Validator<any, false, any>[]]>(...schemaTypes: T_4): Validator<T_4[number]["type"], false, T_4[number]["fieldPaths"]>;
    any(): Validator<any, false, string>;
    optional<T_5 extends Validator<any, false, any>>(inner: T_5): Validator<T_5["type"] | undefined, true, T_5["fieldPaths"]>;
};

/**
 * A validator for a Convex value.
 *
 * This should be constructed using the validator builder, {@link v}.
 *
 * This class encapsulates:
 * - The TypeScript type of this value.
 * - Whether this field should be optional if it's included in an object.
 * - The TypeScript type for the set of index field paths that can be used to
 * build indexes on this value.
 * - A JSON representation of the validator.
 * @public
 */
export declare class Validator<TypeScriptType, IsOptional extends boolean = false, FieldPaths extends string = never> {
    readonly type: TypeScriptType;
    readonly isOptional: IsOptional;
    readonly fieldPaths: FieldPaths;
    readonly _isValidator: undefined;
    readonly optional: boolean;
    readonly json: ValidatorJSON;
    constructor(json: ValidatorJSON, optional: boolean);
}

declare type ValidatorJSON = {
    type: "null";
} | {
    type: "number";
} | {
    type: "bigint";
} | {
    type: "boolean";
} | {
    type: "string";
} | {
    type: "bytes";
} | {
    type: "any";
} | {
    type: "literal";
    value: JSONValue;
} | {
    type: "id";
    tableName: string;
} | {
    type: "array";
    value: ValidatorJSON;
} | {
    type: "set";
    value: ValidatorJSON;
} | {
    type: "map";
    keys: ValidatorJSON;
    values: ValidatorJSON;
} | {
    type: "object";
    value: Record<string, ObjectFieldType>;
} | {
    type: "union";
    value: ValidatorJSON[];
};

/**
 * A value supported by Convex.
 *
 * Values can be:
 * - stored inside of documents.
 * - used as arguments and return types to queries and mutation functions.
 *
 * You can see the full set of supported types at
 * [Types](https://docs.convex.dev/using/types).
 *
 * @public
 */
export declare type Value = GenericId<string> | null | bigint | number | boolean | string | ArrayBuffer | Value[] | Set<Value> | Map<Value, Value> | {
    [key: string]: undefined | Value;
};

export { }
