/**
 * The names of actions in a Convex API.
 *
 * @public
 */
export declare type ActionNames<API extends GenericAPI> = keyof API["allActions"] & string;

/**
 * Create the API type from the types of all of the modules.
 *
 * Input is an object mapping file paths to the type of each module.
 *
 * For internal use by Convex code generation.
 *
 * @public
 */
export declare type ApiFromModules<Modules extends Record<string, Record<string, any>>> = {
    publicQueries: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isQuery: true;
        isPublic: true;
    }>>>;
    allQueries: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isQuery: true;
    }>>>;
    publicMutations: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isMutation: true;
        isPublic: true;
    }>>>;
    allMutations: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isMutation: true;
    }>>>;
    publicActions: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isAction: true;
        isPublic: true;
    }>>>;
    allActions: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isAction: true;
    }>>>;
};

/**
 * A tuple type of the (maybe optional) arguments to `F`, followed by an options
 * object of type `Options`.
 *
 * This type is used to make methods like `useQuery` type-safe while allowing
 * 1. Skipping arguments for functions that don't require arguments.
 * 2. Skipping the options object.
 * @public
 */
export declare type ArgsAndOptions<F extends (args?: Record<string, Value>) => any, Options> = Parameters<F>["length"] extends 0 ? [
args?: {},
options?: Options
] : [args: Parameters<F>[0], options?: Options];

/**
 * An array of arguments to a Convex function.
 *
 * Convex functions can take either a single {@link FunctionArgs} object or no
 * args at all.
 */
declare type ArgsArray = OneArgArray | NoArgsArray;

/**
 * The type of the arguments to a Convex function.
 *
 * This is represented as a single object mapping argument names to values.
 * Functions that don't need any arguments object are represented as `{}`.
 * @public
 */
export declare type ArgsObject<F extends (args?: Record<string, Value>) => any> = Parameters<F>["length"] extends 0 ? {} : Parameters<F>[0] & Record<string, Value>;

/**
 * Converts a map of query and mutation types into their client form.
 *
 * This is done by:
 * - Unwrapping `Promise` if it's in the output.
 * - Switching functions that output `undefined` to `null`.
 *
 */
declare type ConvertToClientFunctions<FunctionsByName extends Record<string, any>> = {
    [Name in keyof FunctionsByName]: (...args: NameArgs<FunctionsByName[Name]["args"]>) => UndefinedToNull<Awaited<FunctionsByName[Name]["output"]>>;
};

/**
 * The type of a Convex function in a {@link GenericAPI}.
 *
 * @public
 */
export declare type ConvexFunction = (args?: any) => any;

/**
 * Common utilities for manipulating TypeScript types.
 * @module
 */
/**
 * Hack! This type causes TypeScript to simplify how it renders object types.
 *
 * It is functionally the identity for object types, but in practice it can
 * simplify expressions like `A & B`.
 */
declare type Expand<ObjectType extends Record<any, any>> = ObjectType extends Record<any, any> ? {
    [Key in keyof ObjectType]: ObjectType[Key];
} : never;

/**
 * The arguments to a Convex query, mutation, or action function.
 *
 * Convex functions always take an arguments object that maps the argument
 * names to their values.
 *
 * @public
 */
declare type FunctionArgs = Record<string, unknown>;

/**
 * Internal Codegen Type Helpers
 */
/**
 * Generate the fully-qualified query/mutation name of an export.
 *
 * This is `path/to/module:export` or `path/to/module` for the default export.
 */
declare type FunctionName<FilePath extends string, ExportName extends string> = ExportName extends "default" ? FilePath : `${FilePath}:${ExportName}`;

/**
 * Description of the Convex functions available to an application.
 *
 * This is a generic type that expresses the shape of API types created by
 * `npx convex dev`. It's used to make the Convex clients type-safe.
 *
 * @public
 */
export declare type GenericAPI = {
    publicQueries: Record<string, ConvexFunction>;
    allQueries: Record<string, ConvexFunction>;
    publicMutations: Record<string, ConvexFunction>;
    allMutations: Record<string, ConvexFunction>;
    publicActions: Record<string, ConvexFunction>;
    allActions: Record<string, ConvexFunction>;
};

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * **Important**: Use `myId.equals(otherId)` to check for equality.
 * Using `===` will not work because two different instances of `Id` can refer
 * to the same document.
 *
 * `Id`s are 17 bytes long and consist of:
 * - A 15-byte random value.
 * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.
 * This is encoded in base 62 ([0-9A-Za-z]).
 *
 * If you're using code generation, use the `Id` class typed for your data model in
 * `convex/_generated/dataModel.js`.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 *
 * @public
 */
declare class Id<TableName extends string> {
    /**
     * The table name this {@link GenericId} references.
     */
    readonly tableName: TableName;
    /**
     * The identifier string.
     *
     * This contains the characters `[0-9A-Za-z]`.
     */
    readonly id: string;
    constructor(tableName: TableName, id: string);
    /**
     * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.
     *
     * @param other - The other {@link GenericId} to compare to.
     * @returns `true` if the objects refer to the same document.
     */
    equals(other: unknown): boolean;
    /**
     * Parse a {@link GenericId} from its JSON representation.
     */
    static fromJSON(obj: any): Id<string>;
    /**
     * Convert a {@link GenericId} into its JSON representation.
     */
    toJSON(): JSONValue;
    /**
     * Convert a {@link GenericId} into its string representation.
     *
     * This includes the identifier but not the table name.
     */
    toString(): string;
    /**
     * Pretty-print this {@link GenericId} for debugging.
     */
    inspect(): string;
}

/**
 * The type of JavaScript values serializable to JSON.
 *
 * @public
 */
declare type JSONValue = null | boolean | number | string | JSONValue[] | {
    [key: string]: JSONValue;
};

/**
 * Name and merge together all of the exports in the `convex/` directory into
 * a flat object type.
 */
declare type MergeAllExports<Modules extends Record<string, Record<string, any>>> = UnionToIntersection<{
    [FilePath in keyof Modules]: NameModule<FilePath & string, Modules[FilePath]>;
}[keyof Modules]>;

/**
 * The names of mutation functions in a Convex API.
 *
 * @public
 */
export declare type MutationNames<API extends GenericAPI> = keyof API["allMutations"] & string;

/**
 * If this function has an argument, name it `args` so it's pretty in editors.
 */
declare type NameArgs<Args extends ArgsArray> = Args["length"] extends 0 ? [] : [args: Args[0]];

/**
 * The type of an action in a Convex API.
 *
 * @public
 */
export declare type NamedAction<API extends GenericAPI, Name extends ActionNames<API>> = API["allActions"][Name];

/**
 * The type of a mutation function in a Convex API.
 *
 * @public
 */
export declare type NamedMutation<API extends GenericAPI, Name extends MutationNames<API>> = API["allMutations"][Name];

/**
 * The type of a query function in a Convex API.
 *
 * @public
 */
export declare type NamedQuery<API extends GenericAPI, Name extends QueryNames<API>> = API["allQueries"][Name];

/**
 * Generate a type of this module where each export is renamed to its
 * fully-qualified {@link FunctionName}.
 */
declare type NameModule<FilePath extends string, Module extends Record<string, any>> = {
    [ExportName in keyof Module as FunctionName<FilePath, ExportName & string>]: Module[ExportName];
};

/**
 * The arguments to a function that takes no arguments (just an empty array).
 */
declare type NoArgsArray = [];

/**
 * The arguments array for a function that takes arguments.
 *
 * This is an array of a single {@link FunctionArgs} element.
 */
declare type OneArgArray = [FunctionArgs];

/**
 * An tuple type of the (maybe optional) arguments to `F`.
 *
 * This type is used to make methods involving arguments type safe while allowing
 * skipping the arguments for functions that don't require arguments.
 *
 * @public
 */
export declare type OptionalRestArgs<F extends (args?: Record<string, Value>) => any> = Parameters<F>["length"] extends 0 ? [
args?: {}
] : [args: Parameters<F>[0]];

/**
 * From ObjectType, pick the properties that are assignable to T.
 */
declare type PickByValue<ObjectType, T> = Pick<ObjectType, {
    [Key in keyof ObjectType]: ObjectType[Key] extends T ? Key : never;
}[keyof ObjectType]>;

/**
 * The names of public query functions in a Convex API.
 *
 * @public
 */
export declare type PublicActionNames<API extends GenericAPI> = keyof API["publicActions"] & string;

/**
 * The names of public mutation functions in a Convex API.
 *
 * @public
 */
export declare type PublicMutationNames<API extends GenericAPI> = keyof API["publicMutations"] & string;

/**
 * The names of public query functions in a Convex API.
 *
 * @public
 */
export declare type PublicQueryNames<API extends GenericAPI> = keyof API["publicQueries"] & string;

/**
 * Helper types for interacting with the overall API type
 */
/**
 * The names of query functions in a Convex API.
 *
 * @public
 */
export declare type QueryNames<API extends GenericAPI> = keyof API["allQueries"] & string;

declare type UndefinedToNull<T> = T extends void ? null : T;

/**
 * Convert a union type like `A | B | C` into an intersection type like
 * `A & B & C`.
 */
declare type UnionToIntersection<UnionType> = (UnionType extends any ? (k: UnionType) => void : never) extends (k: infer I) => void ? I : never;

/**
 * A value supported by Convex.
 *
 * Values can be:
 * - stored inside of documents.
 * - used as arguments and return types to queries and mutation functions.
 *
 * You can see the full set of supported types at
 * [Types](https://docs.convex.dev/using/types).
 *
 * @public
 */
declare type Value = Id<string> | null | bigint | number | boolean | string | ArrayBuffer | Value[] | Set<Value> | Map<Value, Value> | {
    [key: string]: undefined | Value;
};

export { }
