/**
 * A {@link GenericDataModel} that considers documents to be `any` and does not
 * support indexes.
 *
 * This is the default before a schema is defined.
 * @public
 */
declare type AnyDataModel = {
    [tableName: string]: {
        document: any;
        fieldPaths: GenericFieldPaths;
        indexes: {};
        searchIndexes: {};
    };
};

/**
 * Internal type used in Convex code generation!
 *
 * Convert a {@link SchemaDefinition} into a {@link server.GenericDataModel}.
 *
 * @public
 */
export declare type DataModelFromSchemaDefinition<SchemaDef extends SchemaDefinition<any, boolean>> = MaybeMakeLooseDataModel<{
    [TableName in keyof SchemaDef["tables"] & string]: SchemaDef["tables"][TableName] extends TableDefinition<infer Document, infer FieldPaths, infer Indexes, infer SearchIndexes> ? {
        document: Expand<IdField<TableName> & Document>;
        fieldPaths: keyof IdField<TableName> | FieldPaths;
        indexes: Expand<Indexes & SystemIndexes>;
        searchIndexes: SearchIndexes;
    } : never;
}, SchemaDef["strictTableNameTypes"]>;

/**
 * Define the schema of this Convex project.
 *
 * This should be exported from a `schema.ts` file in your `convex/` directory
 * like:
 *
 * ```ts
 * export default defineSchema({
 *   ...
 * });
 * ```
 *
 * @param schema - A map from table name to {@link TableDefinition} for all of
 * the tables in this project.
 * @param options - Optional configuration. See {@link DefineSchemaOptions} for
 * a full description.
 * @returns The schema.
 *
 * @public
 */
export declare function defineSchema<Schema extends GenericSchema, StrictTableNameTypes extends boolean = true>(schema: Schema, options?: DefineSchemaOptions<StrictTableNameTypes>): SchemaDefinition<Schema, StrictTableNameTypes>;

/**
 * Options for {@link defineSchema}.
 *
 * @public
 */
export declare interface DefineSchemaOptions<StrictTableNameTypes extends boolean> {
    /**
     * Whether Convex should validate at runtime that all documents match
     * your schema.
     *
     * If `schemaValidation` is `true`, Convex will:
     * 1. Check that all existing documents match your schema when your schema
     * is pushed.
     * 2. Check that all insertions and updates match your schema during mutations.
     *
     * If `schemaValidation` is `false`, Convex will not validate that new or
     * existing documents match your schema. You'll still get schema-specific
     * TypeScript types, but there will be no validation at runtime that your
     * documents match those types.
     *
     * By default, `schemaValidation` is `true`.
     */
    schemaValidation?: boolean;
    /**
     * Whether the TypeScript types should allow accessing tables not in the schema.
     *
     * If `strictTableNameTypes` is `true`, using tables not listed in the schema
     * will generate a TypeScript compilation error.
     *
     * If `strictTableNameTypes` is `false`, you'll be able to access tables not
     * listed in the schema and their document type will be `any`.
     *
     * `strictTableNameTypes: false` is useful for rapid prototyping.
     *
     * Regardless of the value of `strictTableNameTypes`, your schema will only
     * validate documents in the tables listed in the schema. You can still create
     * and modify other tables on the dashboard or in JavaScript mutations.
     *
     * By default, `strictTableNameTypes` is `true`.
     */
    strictTableNameTypes?: StrictTableNameTypes;
}

/**
 * Define a table in a schema.
 *
 * You can either specify the schema of your documents as an object like
 * ```ts
 * defineTable({
 *   field: v.string()
 * });
 * ```
 *
 * or as a schema type like
 * ```ts
 * defineTable(
 *  v.union(
 *    v.object({...}),
 *    v.object({...})
 *  )
 * );
 * ```
 *
 * @param documentSchema - The type of documents stored in this table.
 * @returns A {@link TableDefinition} for the table.
 *
 * @public
 */
export declare function defineTable<DocumentSchema extends Validator<Record<string, any>, false, any>>(documentSchema: DocumentSchema): TableDefinition<ExtractDocument<DocumentSchema>, ExtractFieldPaths<DocumentSchema>>;

/**
 * Define a table in a schema.
 *
 * You can either specify the schema of your documents as an object like
 * ```ts
 * defineTable({
 *   field: v.string()
 * });
 * ```
 *
 * or as a schema type like
 * ```ts
 * defineTable(
 *  v.union(
 *    v.object({...}),
 *    v.object({...})
 *  )
 * );
 * ```
 *
 * @param documentSchema - The type of documents stored in this table.
 * @returns A {@link TableDefinition} for the table.
 *
 * @public
 */
export declare function defineTable<DocumentSchema extends Record<string, Validator<any, any, any>>>(documentSchema: DocumentSchema): TableDefinition<ExtractDocument<ObjectValidator<DocumentSchema>>, ExtractFieldPaths<ObjectValidator<DocumentSchema>>>;

/**
 * Common utilities for manipulating TypeScript types.
 * @module
 */
/**
 * Hack! This type causes TypeScript to simplify how it renders object types.
 *
 * It is functionally the identity for object types, but in practice it can
 * simplify expressions like `A & B`.
 */
declare type Expand<ObjectType extends Record<any, any>> = ObjectType extends Record<any, any> ? {
    [Key in keyof ObjectType]: ObjectType[Key];
} : never;

/**
 * Extract the {@link GenericDocument} within a {@link Validator} and
 * add on the system fields.
 *
 * This is used within {@link defineTable}.
 * @public
 */
declare type ExtractDocument<T extends Validator<any, any, any>> = Expand<SystemFields & T["type"]>;

/**
 * Extract all of the index field paths within a {@link Validator}.
 *
 * This is used within {@link defineTable}.
 * @public
 */
declare type ExtractFieldPaths<T extends Validator<any, any, any>> = T["fieldPaths"] | keyof SystemFields;

/**
 * A type describing the tables in a Convex project.
 *
 * This is designed to be code generated with `npx convex dev`.
 * @public
 */
declare type GenericDataModel = Record<string, GenericTableInfo>;

/**
 * A document stored in Convex.
 * @public
 */
declare type GenericDocument = Record<string, Value>;

/**
 * A type describing all of the document fields in a table.
 *
 * These can either be field names (like "name") or references to fields on
 * nested objects (like "properties.name").
 * @public
 */
declare type GenericFieldPaths = string;

/**
 * A type describing the ordered fields in an index.
 *
 * These can either be field names (like "name") or references to fields on
 * nested objects (like "properties.name").
 * @public
 */
declare type GenericIndexFields = string[];

/**
 * A type describing the schema of a Convex project.
 *
 * This should be constructed using {@link defineSchema}, {@link defineTable},
 * and {@link v}.
 * @public
 */
export declare type GenericSchema = Record<string, TableDefinition>;

/**
 * A type describing the configuration of a search index.
 * @public
 */
declare type GenericSearchIndexConfig = {
    searchField: string;
    filterFields: string;
};

/**
 * A type describing the indexes in a table.
 *
 * It's an object mapping each index name to the fields in the index.
 * @public
 */
declare type GenericTableIndexes = Record<string, GenericIndexFields>;

/**
 * A type describing the document type and indexes in a table.
 * @public
 */
declare type GenericTableInfo = {
    document: GenericDocument;
    fieldPaths: GenericFieldPaths;
    indexes: GenericTableIndexes;
    searchIndexes: GenericTableSearchIndexes;
};

/**
 * A type describing all of the search indexes in a table.
 *
 * This is an object mapping each index name to the config for the index.
 * @public
 */
declare type GenericTableSearchIndexes = Record<string, GenericSearchIndexConfig>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * **Important**: Use `myId.equals(otherId)` to check for equality.
 * Using `===` will not work because two different instances of `Id` can refer
 * to the same document.
 *
 * `Id`s are 17 bytes long and consist of:
 * - A 15-byte random value.
 * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.
 * This is encoded in base 62 ([0-9A-Za-z]).
 *
 * If you're using code generation, use the `Id` class typed for your data model in
 * `convex/_generated/dataModel.js`.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 *
 * @public
 */
declare class Id<TableName extends string> {
    /**
     * The table name this {@link GenericId} references.
     */
    readonly tableName: TableName;
    /**
     * The identifier string.
     *
     * This contains the characters `[0-9A-Za-z]`.
     */
    readonly id: string;
    constructor(tableName: TableName, id: string);
    /**
     * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.
     *
     * @param other - The other {@link GenericId} to compare to.
     * @returns `true` if the objects refer to the same document.
     */
    equals(other: unknown): boolean;
    /**
     * Parse a {@link GenericId} from its JSON representation.
     */
    static fromJSON(obj: any): Id<string>;
    /**
     * Convert a {@link GenericId} into its JSON representation.
     */
    toJSON(): JSONValue;
    /**
     * Convert a {@link GenericId} into its string representation.
     *
     * This includes the identifier but not the table name.
     */
    toString(): string;
    /**
     * Pretty-print this {@link GenericId} for debugging.
     */
    inspect(): string;
}

/**
 * The `_id` field that Convex automatically adds to documents.
 * @public
 */
declare type IdField<TableName extends string> = {
    _id: Id<TableName>;
};

/**
 * Convex automatically appends "_creationTime" to the end of every index to
 * break ties if all of the other fields are identical.
 * @public
 */
declare type IndexTiebreakerField = "_creationTime";

/**
 * Join together two index field paths.
 *
 * This is used within the validator builder, {@link v}.
 * @public
 */
declare type JoinFieldPaths<Start extends string, End extends string> = `${Start}.${End}`;

/**
 * The type of JavaScript values serializable to JSON.
 *
 * @public
 */
declare type JSONValue = null | boolean | number | string | JSONValue[] | {
    [key: string]: JSONValue;
};

declare type MaybeMakeLooseDataModel<DataModel extends GenericDataModel, StrictTableNameTypes extends boolean> = StrictTableNameTypes extends true ? DataModel : Expand<DataModel & AnyDataModel>;

declare type ObjectFieldType = {
    fieldType: ValidatorJSON;
    optional: boolean;
};

/**
 * Compute the type of an object from {@link PropertyValidators}.
 *
 * @public
 */
declare type ObjectType<Validators extends PropertyValidators> = Expand<{
    [Property in OptionalKeys<Validators>]?: Validators[Property]["type"];
} & {
    [Property in RequiredKeys<Validators>]: Validators[Property]["type"];
}>;

/**
 * Calculate the type of a {@link Validator} for an object.
 *
 * This is used within the validator builder, {@link v}.
 */
declare type ObjectValidator<Validators extends PropertyValidators> = Validator<ObjectType<Validators>, false, {
    [Property in keyof Validators]: JoinFieldPaths<Property & string, Validators[Property]["fieldPaths"]> | Property;
}[keyof Validators] & string>;

declare type OptionalKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = {
    [Property in keyof PropertyValidators]: PropertyValidators[Property]["isOptional"] extends true ? Property : never;
}[keyof PropertyValidators];

/**
 * Validators for each property of an object.
 *
 * This is represented as an object mapping the property name to its
 * {@link Validator}.
 *
 * @public
 */
declare type PropertyValidators = Record<string, Validator<any, any, any>>;

declare type RequiredKeys<PropertyValidators extends Record<string, Validator<any, any, any>>> = Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;

/**
 *
 * The definition of a Convex project schema.
 *
 * This should be produced by using {@link defineSchema}.
 * @public
 */
export declare class SchemaDefinition<Schema extends GenericSchema, StrictTableTypes extends boolean> {
    tables: Schema;
    strictTableNameTypes: StrictTableTypes;
    private readonly schemaValidation;
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: export */
}

/**
 * The configuration for a search index.
 *
 * @public
 */
export declare interface SearchIndexConfig<SearchField extends string, FilterFields extends string> {
    /**
     * The field to index for full text search.
     *
     * This must be a field of type `string`.
     */
    searchField: SearchField;
    /**
     * Additional fields to index for fast filtering when running search queries.
     */
    filterFields?: FilterFields[];
}

/**
 * The fields that Convex automatically adds to documents, not including `_id`.
 *
 * This is an object type mapping field name to field type.
 * @public
 */
declare type SystemFields = {
    _creationTime: number;
};

/**
 * The indexes that Convex automatically adds to every table.
 *
 * This is an object mapping index names to index field paths.
 * @public
 */
declare type SystemIndexes = {
    by_creation_time: ["_creationTime"];
};

/**
 * The definition of a table within a schema.
 *
 * This should be produced by using {@link defineTable}.
 * @public
 */
export declare class TableDefinition<Document extends GenericDocument = GenericDocument, FieldPaths extends string = string, Indexes extends GenericTableIndexes = {}, SearchIndexes extends GenericTableSearchIndexes = {}> {
    private indexes;
    private searchIndexes;
    private documentType;
    /* Excluded from this release type: __constructor */
    /**
     * Define an index on this table.
     *
     * To learn about indexes, see [Defining Indexes](https://docs.convex.dev/using/indexes).
     *
     * @param name - The name of the index.
     * @param fields - The fields to index, in order. Must specify at least one
     * field.
     * @returns A {@link TableDefinition} with this index included.
     */
    index<IndexName extends string, FirstFieldPath extends FieldPaths, RestFieldPaths extends FieldPaths[]>(name: IndexName, fields: [FirstFieldPath, ...RestFieldPaths]): TableDefinition<Document, FieldPaths, Expand<Indexes & Record<IndexName, [
    FirstFieldPath,
    ...RestFieldPaths,
    IndexTiebreakerField
    ]>>, SearchIndexes>;
    /**
     * Define a search index on this table.
     *
     * To learn about search indexes, see [Search](https://docs.convex.dev/text-search).
     *
     * @param name - The name of the index.
     * @param indexConfig - The search index configuration object.
     * @returns A {@link TableDefinition} with this search index included.
     */
    searchIndex<IndexName extends string, SearchField extends FieldPaths, FilterFields extends FieldPaths = never>(name: IndexName, indexConfig: Expand<SearchIndexConfig<SearchField, FilterFields>>): TableDefinition<Document, FieldPaths, Indexes, Expand<SearchIndexes & Record<IndexName, {
        searchField: SearchField;
        filterFields: FilterFields;
    }>>>;
    /* Excluded from this release type: export */
}

/**
 * A validator for a Convex value.
 *
 * This should be constructed using the validator builder, {@link v}.
 *
 * This class encapsulates:
 * - The TypeScript type of this value.
 * - Whether this field should be optional if it's included in an object.
 * - The TypeScript type for the set of index field paths that can be used to
 * build indexes on this value.
 * - A JSON representation of the validator.
 * @public
 */
declare class Validator<TypeScriptType, IsOptional extends boolean = false, FieldPaths extends string = never> {
    readonly type: TypeScriptType;
    readonly isOptional: IsOptional;
    readonly fieldPaths: FieldPaths;
    readonly _isValidator: undefined;
    readonly optional: boolean;
    readonly json: ValidatorJSON;
    constructor(json: ValidatorJSON, optional: boolean);
}

declare type ValidatorJSON = {
    type: "null";
} | {
    type: "number";
} | {
    type: "bigint";
} | {
    type: "boolean";
} | {
    type: "string";
} | {
    type: "bytes";
} | {
    type: "any";
} | {
    type: "literal";
    value: JSONValue;
} | {
    type: "id";
    tableName: string;
} | {
    type: "array";
    value: ValidatorJSON;
} | {
    type: "set";
    value: ValidatorJSON;
} | {
    type: "map";
    keys: ValidatorJSON;
    values: ValidatorJSON;
} | {
    type: "object";
    value: Record<string, ObjectFieldType>;
} | {
    type: "union";
    value: ValidatorJSON[];
};

/**
 * A value supported by Convex.
 *
 * Values can be:
 * - stored inside of documents.
 * - used as arguments and return types to queries and mutation functions.
 *
 * You can see the full set of supported types at
 * [Types](https://docs.convex.dev/using/types).
 *
 * @public
 */
declare type Value = Id<string> | null | bigint | number | boolean | string | ArrayBuffer | Value[] | Set<Value> | Map<Value, Value> | {
    [key: string]: undefined | Value;
};

export { }
