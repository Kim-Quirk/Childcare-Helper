"use strict";
var convex = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../common/temp/node_modules/.pnpm/node-fetch@2.6.9_encoding@0.1.13/node_modules/node-fetch/browser.js
  var require_browser = __commonJS({
    "../common/temp/node_modules/.pnpm/node-fetch@2.6.9_encoding@0.1.13/node_modules/node-fetch/browser.js"(exports, module) {
      "use strict";
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw new Error("unable to locate global object");
      };
      var globalObject = getGlobal();
      module.exports = exports = globalObject.fetch;
      if (globalObject.fetch) {
        exports.default = globalObject.fetch.bind(globalObject);
      }
      exports.Headers = globalObject.Headers;
      exports.Request = globalObject.Request;
      exports.Response = globalObject.Response;
    }
  });

  // src/browser/index.ts
  var browser_exports = {};
  __export(browser_exports, {
    BaseConvexClient: () => BaseConvexClient,
    ConvexHttpClient: () => ConvexHttpClient
  });

  // src/index.ts
  var version = "0.14.0";

  // src/values/base64.ts
  var base64_exports = {};
  __export(base64_exports, {
    byteLength: () => byteLength,
    fromByteArray: () => fromByteArray,
    toByteArray: () => toByteArray
  });
  var lookup = [];
  var revLookup = [];
  var Arr = Uint8Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(_b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i,
          i + maxChunkLength > len2 ? len2 : i + maxChunkLength
        )
      );
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }

  // src/common/index.ts
  var STATUS_CODE_UDF_FAILED = 560;
  function parseArgs(args) {
    if (args === void 0) {
      return {};
    }
    if (!isSimpleObject(args)) {
      throw new Error(
        `The arguments to a Convex function must be an object. Received: ${args}`
      );
    }
    return args;
  }
  function isSimpleObject(value) {
    const isObject = typeof value === "object";
    const prototype = Object.getPrototypeOf(value);
    const isSimple = prototype === null || prototype === Object.prototype || prototype?.constructor?.name === "Object";
    return isObject && isSimple;
  }

  // src/values/value.ts
  var LITTLE_ENDIAN = true;
  var MIN_INT64 = BigInt("-9223372036854775808");
  var MAX_INT64 = BigInt("9223372036854775807");
  var ZERO = BigInt("0");
  var EIGHT = BigInt("8");
  var TWOFIFTYSIX = BigInt("256");
  var Id = class {
    constructor(tableName, id) {
      this.tableName = tableName;
      this.id = id;
    }
    equals(other) {
      if (other instanceof Id) {
        return this.tableName === other.tableName && this.id === other.id;
      }
      return false;
    }
    static fromJSON(obj) {
      if (typeof obj.$id !== "string") {
        throw new Error(
          `Object ${JSON.stringify(obj)} isn't a valid Id: $id isn't a string.`
        );
      }
      const parts = obj.$id.split("|");
      if (parts.length !== 2) {
        throw new Error(
          `Object ${JSON.stringify(obj)} isn't a valid Id: Wrong number of parts.`
        );
      }
      return new Id(parts[0], parts[1]);
    }
    toJSON() {
      const idString = `${this.tableName}|${this.id}`;
      return { $id: idString };
    }
    toString() {
      return this.id;
    }
    inspect() {
      return `Id('${this.tableName}', '${this.id}')`;
    }
  };
  function isSpecial(n2) {
    return Number.isNaN(n2) || !Number.isFinite(n2) || Object.is(n2, -0);
  }
  function slowBigIntToBase64(value) {
    if (value < ZERO) {
      value -= MIN_INT64 + MIN_INT64;
    }
    let hex = value.toString(16);
    if (hex.length % 2 === 1)
      hex = "0" + hex;
    const bytes = new Uint8Array(new ArrayBuffer(8));
    let i = 0;
    for (const hexByte of hex.match(/.{2}/g).reverse()) {
      bytes.set([parseInt(hexByte, 16)], i++);
      value >>= EIGHT;
    }
    return fromByteArray(bytes);
  }
  function slowBase64ToBigInt(encoded) {
    const integerBytes = toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
      throw new Error(
        `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`
      );
    }
    let value = ZERO;
    let power = ZERO;
    for (const byte of integerBytes) {
      value += BigInt(byte) * TWOFIFTYSIX ** power;
      power++;
    }
    if (value > MAX_INT64) {
      value += MIN_INT64 + MIN_INT64;
    }
    return value;
  }
  function modernBigIntToBase64(value) {
    if (value < MIN_INT64 || MAX_INT64 < value) {
      throw new Error(
        `BigInt ${value} does not fit into a 64-bit signed integer.`
      );
    }
    const buffer = new ArrayBuffer(8);
    new DataView(buffer).setBigInt64(0, value, true);
    return fromByteArray(new Uint8Array(buffer));
  }
  function modernBase64ToBigInt(encoded) {
    const integerBytes = toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
      throw new Error(
        `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`
      );
    }
    const intBytesView = new DataView(integerBytes.buffer);
    return intBytesView.getBigInt64(0, true);
  }
  var bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;
  var base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;
  var MAX_IDENTIFIER_LEN = 64;
  var ALL_UNDERSCORES = /^_+$/;
  var IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;
  function validateObjectField(k) {
    if (k.length === 0) {
      throw new Error("Empty field names are disallowed.");
    }
    if (k.length > MAX_IDENTIFIER_LEN) {
      throw new Error(
        `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`
      );
    }
    if (k.startsWith("$")) {
      throw new Error(`Field name ${k} starts with a '$', which is reserved.`);
    }
    if (ALL_UNDERSCORES.test(k)) {
      throw new Error(`Field name ${k} can't exclusively be underscores.`);
    }
    if (!IDENTIFIER_REGEX.test(k)) {
      throw new Error(
        `Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`
      );
    }
  }
  function jsonToConvexInternal(value) {
    if (value === null) {
      return value;
    }
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(jsonToConvexInternal);
    }
    if (typeof value !== "object") {
      throw new Error(`Unexpected type of ${value}`);
    }
    const entries = Object.entries(value);
    if (entries.length === 1) {
      const key = entries[0][0];
      if (key === "$id" || key === "$weakRef" || key === "$strongRef") {
        return Id.fromJSON(value);
      }
      if (key === "$bytes") {
        if (typeof value.$bytes !== "string") {
          throw new Error(`Malformed $bytes field on ${value}`);
        }
        return toByteArray(value.$bytes).buffer;
      }
      if (key === "$integer") {
        if (typeof value.$integer !== "string") {
          throw new Error(`Malformed $integer field on ${value}`);
        }
        return base64ToBigInt(value.$integer);
      }
      if (key === "$float") {
        if (typeof value.$float !== "string") {
          throw new Error(`Malformed $float field on ${value}`);
        }
        const floatBytes = toByteArray(value.$float);
        if (floatBytes.byteLength !== 8) {
          throw new Error(
            `Received ${floatBytes.byteLength} bytes, expected 8 for $float`
          );
        }
        const floatBytesView = new DataView(floatBytes.buffer);
        const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);
        if (!isSpecial(float)) {
          throw new Error(`Float ${float} should be encoded as a number`);
        }
        return float;
      }
      if (key === "$set") {
        if (!Array.isArray(value.$set)) {
          throw new Error(`Malformed $set field on ${value}`);
        }
        return new Set(value.$set.map(jsonToConvexInternal));
      }
      if (key === "$map") {
        if (!Array.isArray(value.$map)) {
          throw new Error(`Malformed $map field on ${value}`);
        }
        const map = /* @__PURE__ */ new Map();
        for (const pair of value.$map) {
          if (!Array.isArray(pair) || pair.length !== 2) {
            throw new Error(`Malformed pair in $map ${value}`);
          }
          const k = jsonToConvexInternal(pair[0]);
          const v = jsonToConvexInternal(pair[1]);
          map.set(k, v);
        }
        return map;
      }
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
      validateObjectField(k);
      out[k] = jsonToConvexInternal(v);
    }
    return out;
  }
  function jsonToConvex(value) {
    return jsonToConvexInternal(value);
  }
  function stringifyValueForError(value) {
    return JSON.stringify(value, (_key, value2) => {
      if (value2 === void 0) {
        return "undefined";
      }
      if (typeof value2 === "bigint") {
        return `${value2.toString()}n`;
      }
      return value2;
    });
  }
  function convexToJsonInternal(value, originalValue, context) {
    if (value === void 0) {
      const contextText = context && ` (present at path ${context} in original object ${stringifyValueForError(
        originalValue
      )})`;
      throw new Error(
        `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`
      );
    }
    if (value === null) {
      return value;
    }
    if (value instanceof Id) {
      return value.toJSON();
    }
    if (typeof value === "bigint") {
      if (value < MIN_INT64 || MAX_INT64 < value) {
        throw new Error(
          `BigInt ${value} does not fit into a 64-bit signed integer.`
        );
      }
      return { $integer: bigIntToBase64(value) };
    }
    if (typeof value === "number") {
      if (isSpecial(value)) {
        const buffer = new ArrayBuffer(8);
        new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);
        return { $float: fromByteArray(new Uint8Array(buffer)) };
      } else {
        return value;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      return value;
    }
    if (value instanceof ArrayBuffer) {
      return { $bytes: fromByteArray(new Uint8Array(value)) };
    }
    if (Array.isArray(value)) {
      return value.map(
        (value2, i) => convexToJsonInternal(value2, originalValue, context + `[${i}]`)
      );
    }
    if (value instanceof Set) {
      return {
        $set: [...value].map(
          (value2, i) => convexToJsonInternal(value2, originalValue, context + `.keys()[${i}]`)
        )
      };
    }
    if (value instanceof Map) {
      return {
        $map: [...value].map(([k, v], i) => {
          const jsonKey = convexToJsonInternal(
            k,
            originalValue,
            context + `.keys()[${i}]`
          );
          const jsonValue = convexToJsonInternal(
            v,
            originalValue,
            context + `.values()[${i}]`
          );
          return [jsonKey, jsonValue];
        })
      };
    }
    if (!isSimpleObject(value)) {
      const theType = value?.constructor?.name;
      const typeMsg = theType ? `${theType} ` : "";
      if (context) {
        throw new Error(
          `${typeMsg}${stringifyValueForError(
            value
          )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(
            originalValue
          )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`
        );
      } else {
        throw new Error(
          `${typeMsg}${stringifyValueForError(
            value
          )} is not a supported Convex type.`
        );
      }
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
      if (v !== void 0) {
        validateObjectField(k);
        out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);
      }
    }
    return out;
  }
  function convexToJson(value) {
    return convexToJsonInternal(value, value, "");
  }

  // src/browser/logging.ts
  var INFO_COLOR = "color:rgb(0, 145, 255)";
  function prefix_for_source(source) {
    switch (source) {
      case "query":
        return "Q";
      case "mutation":
        return "M";
      case "action":
        return "A";
    }
  }
  function logToConsole(type, source, udfPath, message) {
    const prefix = prefix_for_source(source);
    if (type === "info") {
      console.log(`%c[CONVEX ${prefix}(${udfPath})] ${message}`, INFO_COLOR);
    } else {
      console.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
    }
  }
  function logFatalError(message) {
    const errorMessage = `[CONVEX FATAL ERROR] ${message}`;
    console.error(errorMessage);
    return new Error(errorMessage);
  }
  function createError(source, udfPath, message) {
    const prefix = prefix_for_source(source);
    return new Error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
  }

  // src/browser/sync/udf_path_utils.ts
  function canonicalizeUdfPath(udfPath) {
    const pieces = udfPath.split(":");
    let moduleName;
    let functionName;
    if (pieces.length === 1) {
      moduleName = pieces[0];
      functionName = "default";
    } else {
      moduleName = pieces.slice(0, pieces.length - 1).join(":");
      functionName = pieces[pieces.length - 1];
    }
    if (!moduleName.endsWith(".js")) {
      moduleName = `${moduleName}.js`;
    }
    return `${moduleName}:${functionName}`;
  }
  function serializePathAndArgs(udfPath, args) {
    return JSON.stringify({
      udfPath: canonicalizeUdfPath(udfPath),
      args: convexToJson(args)
    });
  }

  // src/browser/sync/local_state.ts
  var LocalSyncState = class {
    constructor() {
      this.nextQueryId = 0;
      this.querySetVersion = 0;
      this.identityVersion = 0;
      this.querySet = /* @__PURE__ */ new Map();
      this.queryIdToToken = /* @__PURE__ */ new Map();
    }
    subscribe(udfPath, args, journal) {
      const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
      const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
      const existingEntry = this.querySet.get(queryToken);
      if (existingEntry !== void 0) {
        existingEntry.numSubscribers += 1;
        return {
          queryToken,
          modification: null,
          unsubscribe: () => this.removeSubscriber(queryToken)
        };
      } else {
        const queryId = this.nextQueryId++;
        const query = {
          id: queryId,
          canonicalizedUdfPath,
          args,
          numSubscribers: 1,
          journal
        };
        this.querySet.set(queryToken, query);
        this.queryIdToToken.set(queryId, queryToken);
        const baseVersion = this.querySetVersion;
        const newVersion = ++this.querySetVersion;
        const add = {
          type: "Add",
          queryId,
          udfPath: canonicalizedUdfPath,
          args: [convexToJson(args)],
          journal
        };
        const modification = {
          type: "ModifyQuerySet",
          baseVersion,
          newVersion,
          modifications: [add]
        };
        return {
          queryToken,
          modification,
          unsubscribe: () => this.removeSubscriber(queryToken)
        };
      }
    }
    saveQueryJournals(transition) {
      for (const modification of transition.modifications) {
        switch (modification.type) {
          case "QueryUpdated":
          case "QueryFailed": {
            const journal = modification.journal;
            if (journal !== void 0) {
              const queryToken = this.queryIdToToken.get(modification.queryId);
              if (queryToken !== void 0) {
                this.querySet.get(queryToken).journal = journal;
              }
            }
            break;
          }
          case "QueryRemoved": {
            break;
          }
          default: {
            const _ = modification;
            throw new Error(`Invalid modification ${modification}`);
          }
        }
      }
    }
    queryId(udfPath, args) {
      const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
      const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
      const existingEntry = this.querySet.get(queryToken);
      if (existingEntry !== void 0) {
        return existingEntry.id;
      }
      return null;
    }
    isCurrentOrNewerAuthVersion(version2) {
      return version2 >= this.identityVersion;
    }
    setAuth(value) {
      this.auth = {
        tokenType: "User",
        value
      };
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        baseVersion,
        ...this.auth
      };
    }
    setAdminAuth(value, actingAs) {
      const auth = {
        tokenType: "Admin",
        value,
        impersonating: actingAs
      };
      this.auth = auth;
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        baseVersion,
        ...auth
      };
    }
    clearAuth() {
      this.auth = void 0;
      const baseVersion = this.identityVersion++;
      return {
        type: "Authenticate",
        tokenType: "None",
        baseVersion
      };
    }
    hasAuth() {
      return !!this.auth;
    }
    isNewAuth(value) {
      return this.auth?.value !== value;
    }
    queryPath(queryId) {
      const pathAndArgs = this.queryIdToToken.get(queryId);
      if (pathAndArgs) {
        return this.querySet.get(pathAndArgs).canonicalizedUdfPath;
      }
      return null;
    }
    queryArgs(queryId) {
      const pathAndArgs = this.queryIdToToken.get(queryId);
      if (pathAndArgs) {
        return this.querySet.get(pathAndArgs).args;
      }
      return null;
    }
    queryToken(queryId) {
      return this.queryIdToToken.get(queryId) ?? null;
    }
    queryJournal(queryToken) {
      return this.querySet.get(queryToken)?.journal;
    }
    restart() {
      const modifications = [];
      for (const localQuery of this.querySet.values()) {
        const add = {
          type: "Add",
          queryId: localQuery.id,
          udfPath: localQuery.canonicalizedUdfPath,
          args: [convexToJson(localQuery.args)],
          journal: localQuery.journal
        };
        modifications.push(add);
      }
      this.querySetVersion = 1;
      const querySet = {
        type: "ModifyQuerySet",
        baseVersion: 0,
        newVersion: 1,
        modifications
      };
      if (!this.auth) {
        this.identityVersion = 0;
        return [querySet, void 0];
      }
      const authenticate = {
        type: "Authenticate",
        baseVersion: 0,
        ...this.auth
      };
      this.identityVersion = 1;
      return [querySet, authenticate];
    }
    removeSubscriber(queryToken) {
      const localQuery = this.querySet.get(queryToken);
      if (localQuery.numSubscribers > 1) {
        localQuery.numSubscribers -= 1;
        return null;
      } else {
        this.querySet.delete(queryToken);
        this.queryIdToToken.delete(localQuery.id);
        const baseVersion = this.querySetVersion;
        const newVersion = ++this.querySetVersion;
        const remove = {
          type: "Remove",
          queryId: localQuery.id
        };
        return {
          type: "ModifyQuerySet",
          baseVersion,
          newVersion,
          modifications: [remove]
        };
      }
    }
  };

  // src/browser/sync/request_manager.ts
  var RequestManager = class {
    constructor() {
      this.inflightRequests = /* @__PURE__ */ new Map();
      this._timeOfOldestInflightRequest = null;
    }
    request(message, sent) {
      const result = new Promise((resolve) => {
        const status = sent ? "Requested" : "NotSent";
        this.inflightRequests.set(message.requestId, {
          message,
          status: { status, requestedAt: new Date(), onResult: resolve }
        });
      });
      return result;
    }
    onResponse(response) {
      const requestInfo = this.inflightRequests.get(response.requestId);
      if (requestInfo === void 0) {
        return null;
      }
      if (requestInfo.status.status === "Completed") {
        return null;
      }
      const udfType = requestInfo.message.type === "Mutation" ? "mutation" : "action";
      const udfPath = requestInfo.message.udfPath;
      for (const line of response.logLines) {
        logToConsole("info", udfType, udfPath, line);
      }
      const status = requestInfo.status;
      let onResolve;
      if (response.success) {
        onResolve = () => status.onResult({
          success: true,
          logLines: response.logLines,
          value: jsonToConvex(response.result)
        });
      } else {
        logToConsole("error", udfType, udfPath, response.result);
        onResolve = () => status.onResult({
          success: false,
          errorMessage: response.result,
          logLines: response.logLines
        });
      }
      if (response.type === "ActionResponse" || !response.success) {
        onResolve();
        this.inflightRequests.delete(response.requestId);
        return response.requestId;
      }
      requestInfo.status = {
        status: "Completed",
        ts: response.ts,
        onResolve
      };
      return null;
    }
    removeCompleted(ts) {
      const completeRequests = /* @__PURE__ */ new Set();
      for (const [requestId, requestInfo] of this.inflightRequests.entries()) {
        const status = requestInfo.status;
        if (status.status === "Completed" && status.ts.lessThanOrEqual(ts)) {
          status.onResolve();
          completeRequests.add(requestId);
          this.inflightRequests.delete(requestId);
        }
      }
      return completeRequests;
    }
    restart() {
      const allMessages = [];
      for (const [requestId, value] of this.inflightRequests) {
        if (value.status.status === "NotSent") {
          value.status.status = "Requested";
          allMessages.push(value.message);
          continue;
        }
        if (value.message.type === "Mutation") {
          allMessages.push(value.message);
        } else {
          this.inflightRequests.delete(requestId);
          if (value.status.status === "Completed") {
            throw new Error("Action should never be in 'Completed' state");
          }
          value.status.onResult({
            success: false,
            errorMessage: "Connection lost while action was in flight",
            logLines: []
          });
        }
      }
      return allMessages;
    }
    hasIncompleteRequests() {
      for (const requestInfo of this.inflightRequests.values()) {
        if (requestInfo.status.status === "Requested") {
          return true;
        }
      }
      return false;
    }
    hasInflightRequests() {
      return this.inflightRequests.size > 0;
    }
    timeOfOldestInflightRequest() {
      if (this.inflightRequests.size === 0) {
        return null;
      }
      let oldestInflightRequest = Date.now();
      for (const request of this.inflightRequests.values()) {
        if (request.status.status !== "Completed") {
          if (request.status.requestedAt.getTime() < oldestInflightRequest) {
            oldestInflightRequest = request.status.requestedAt.getTime();
          }
        }
      }
      return new Date(oldestInflightRequest);
    }
  };

  // src/browser/sync/optimistic_updates_impl.ts
  var OptimisticLocalStoreImpl = class {
    constructor(queryResults) {
      this.queryResults = queryResults;
      this.modifiedQueries = [];
    }
    getQuery(name, args) {
      const queryArgs = parseArgs(args);
      const query = this.queryResults.get(serializePathAndArgs(name, queryArgs));
      if (query === void 0) {
        return void 0;
      }
      return OptimisticLocalStoreImpl.queryValue(query.result);
    }
    getAllQueries(name) {
      const queriesWithName = [];
      for (const query of this.queryResults.values()) {
        if (query.udfPath === canonicalizeUdfPath(name)) {
          queriesWithName.push({
            args: query.args,
            value: OptimisticLocalStoreImpl.queryValue(query.result)
          });
        }
      }
      return queriesWithName;
    }
    setQuery(name, args, value) {
      const queryToken = serializePathAndArgs(name, args);
      let result;
      if (value === void 0) {
        result = void 0;
      } else {
        result = {
          success: true,
          value,
          logLines: []
        };
      }
      const query = {
        udfPath: name,
        args,
        result
      };
      this.queryResults.set(queryToken, query);
      this.modifiedQueries.push(queryToken);
    }
    static queryValue(result) {
      if (result === void 0) {
        return void 0;
      } else if (result.success) {
        return result.value;
      } else {
        return void 0;
      }
    }
  };
  var OptimisticQueryResults = class {
    constructor() {
      this.queryResults = /* @__PURE__ */ new Map();
      this.optimisticUpdates = [];
    }
    ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {
      this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId) => {
        return !optimisticUpdatesToDrop.has(updateAndId.mutationId);
      });
      const oldQueryResults = this.queryResults;
      this.queryResults = new Map(serverQueryResults);
      const localStore = new OptimisticLocalStoreImpl(this.queryResults);
      for (const updateAndId of this.optimisticUpdates) {
        updateAndId.update(localStore);
      }
      const changedQueries = [];
      for (const [queryToken, query] of this.queryResults) {
        const oldQuery = oldQueryResults.get(queryToken);
        if (oldQuery === void 0 || oldQuery.result !== query.result) {
          changedQueries.push(queryToken);
        }
      }
      return changedQueries;
    }
    applyOptimisticUpdate(update, mutationId) {
      this.optimisticUpdates.push({
        update,
        mutationId
      });
      const localStore = new OptimisticLocalStoreImpl(this.queryResults);
      update(localStore);
      return localStore.modifiedQueries;
    }
    queryResult(queryToken) {
      const query = this.queryResults.get(queryToken);
      if (query === void 0) {
        return void 0;
      }
      const result = query.result;
      if (result === void 0) {
        return void 0;
      } else if (result.success) {
        return result.value;
      } else {
        throw createError("query", query.udfPath, result.errorMessage);
      }
    }
    queryLogs(queryToken) {
      const query = this.queryResults.get(queryToken);
      return query?.result?.logLines;
    }
  };

  // src/browser/long.ts
  var Long = class {
    static isLong(obj) {
      return (obj && obj.__isUnsignedLong__) === true;
    }
    constructor(low, high) {
      this.low = low | 0;
      this.high = high | 0;
      this.__isUnsignedLong__ = true;
    }
    static fromBytesLE(bytes) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24
      );
    }
    toBytesLE() {
      const hi = this.high;
      const lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    static fromNumber(value) {
      if (isNaN(value))
        return UZERO;
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
      return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    notEquals(other) {
      return !this.equals(other);
    }
    comp(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.equals(other))
        return 0;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    static fromValue(val) {
      if (typeof val === "number")
        return Long.fromNumber(val);
      return new Long(val.low, val.high);
    }
  };
  var UZERO = new Long(0, 0);
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var MAX_UNSIGNED_VALUE = new Long(4294967295 | 0, 4294967295 | 0);

  // src/browser/sync/remote_query_set.ts
  var RemoteQuerySet = class {
    constructor(queryPath) {
      this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };
      this.remoteQuerySet = /* @__PURE__ */ new Map();
      this.queryPath = queryPath;
    }
    transition(transition) {
      const start = transition.startVersion;
      if (this.version.querySet !== start.querySet || this.version.ts.notEquals(start.ts) || this.version.identity !== start.identity) {
        throw new Error(`Invalid start version: ${start.ts}:${start.querySet}`);
      }
      for (const modification of transition.modifications) {
        switch (modification.type) {
          case "QueryUpdated": {
            const queryPath = this.queryPath(modification.queryId);
            if (queryPath) {
              for (const line of modification.logLines) {
                logToConsole("info", "query", queryPath, line);
              }
            }
            const value = jsonToConvex(modification.value ?? null);
            this.remoteQuerySet.set(modification.queryId, {
              success: true,
              value,
              logLines: modification.logLines
            });
            break;
          }
          case "QueryFailed": {
            const queryPath = this.queryPath(modification.queryId);
            if (queryPath) {
              for (const line of modification.logLines) {
                logToConsole("info", "query", queryPath, line);
              }
            }
            this.remoteQuerySet.set(modification.queryId, {
              success: false,
              errorMessage: modification.errorMessage,
              logLines: modification.logLines
            });
            break;
          }
          case "QueryRemoved": {
            this.remoteQuerySet.delete(modification.queryId);
            break;
          }
          default: {
            const _ = modification;
            throw new Error(`Invalid modification ${modification}`);
          }
        }
      }
      this.version = transition.endVersion;
    }
    remoteQueryResults() {
      return this.remoteQuerySet;
    }
    timestamp() {
      return this.version.ts;
    }
  };

  // src/browser/sync/protocol.ts
  function u64ToLong(encoded) {
    const integerBytes = base64_exports.toByteArray(encoded);
    return Long.fromBytesLE(Array.from(integerBytes));
  }
  function parseServerMessage(encoded) {
    switch (encoded.type) {
      case "FatalError":
      case "AuthError":
      case "ActionResponse":
      case "Ping": {
        return { ...encoded };
      }
      case "MutationResponse": {
        if (encoded.success) {
          return { ...encoded, ts: u64ToLong(encoded.ts) };
        } else {
          return { ...encoded };
        }
      }
      case "Transition": {
        return {
          ...encoded,
          startVersion: {
            ...encoded.startVersion,
            ts: u64ToLong(encoded.startVersion.ts)
          },
          endVersion: {
            ...encoded.endVersion,
            ts: u64ToLong(encoded.endVersion.ts)
          }
        };
      }
      default: {
        const _exhaustivenessCheck = encoded;
      }
    }
    return void 0;
  }

  // src/browser/sync/web_socket_manager.ts
  var CLOSE_NORMAL = 1e3;
  var CLOSE_GOING_AWAY = 1001;
  var CLOSE_NO_STATUS = 1005;
  var CLOSE_NOT_FOUND = 4040;
  function promisePair() {
    let resolvePromise;
    const promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    return { promise, resolve: resolvePromise };
  }
  var WebSocketManager = class {
    constructor(uri, onOpen, onMessage, webSocketConstructor, verbose) {
      this.webSocketConstructor = webSocketConstructor;
      this.socket = { state: "disconnected" };
      this.connectionCount = 0;
      this.lastCloseReason = "InitialConnect";
      this.initialBackoff = 100;
      this.maxBackoff = 16e3;
      this.retries = 0;
      this.serverInactivityThreshold = 3e4;
      this.reconnectDueToServerInactivityTimeout = null;
      this.uri = uri;
      this.onOpen = onOpen;
      this.onMessage = onMessage;
      this.verbose = verbose;
      void this.connect();
    }
    async connect() {
      if (this.socket.state === "closing" || this.socket.state === "stopping" || this.socket.state === "stopped") {
        return;
      }
      if (this.socket.state !== "disconnected" && this.socket.state !== "paused") {
        throw new Error(
          "Didn't start connection from disconnected state: " + this.socket.state
        );
      }
      const ws = new this.webSocketConstructor(this.uri);
      this._logVerbose("constructed WebSocket");
      this.socket = {
        state: "connecting",
        ws
      };
      ws.onopen = () => {
        this._logVerbose("begin ws.onopen");
        if (this.socket.state !== "connecting") {
          throw new Error("onopen called with socket not in connecting state");
        }
        this.socket = { state: "ready", ws };
        this.onServerActivity();
        this.onOpen({
          connectionCount: this.connectionCount,
          lastCloseReason: this.lastCloseReason
        });
        if (this.lastCloseReason !== "InitialConnect") {
          console.log("WebSocket reconnected");
        }
        this.connectionCount += 1;
        this.lastCloseReason = null;
      };
      ws.onerror = (error) => {
        const message = error.message;
        console.log(`WebSocket error: ${message}`);
        this.closeAndReconnect("WebSocketError");
      };
      ws.onmessage = (message) => {
        this.retries = 0;
        this.onServerActivity();
        const serverMessage = parseServerMessage(JSON.parse(message.data));
        this._logVerbose(`received ws message with type ${serverMessage.type}`);
        this.onMessage(serverMessage);
      };
      ws.onclose = (event) => {
        this._logVerbose("begin ws.onclose");
        if (this.lastCloseReason === null) {
          this.lastCloseReason = event.reason ?? "OnCloseInvoked";
        }
        if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY && event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {
          let msg = `WebSocket closed unexpectedly with code ${event.code}`;
          if (event.reason) {
            msg += `: ${event.reason}`;
          }
          console.error(msg);
        }
        if (this.socket.state === "stopping") {
          this.socket.promisePair.resolve(null);
          this.socket = { state: "stopped" };
          return;
        }
        if (this.socket.state === "pausing") {
          this.socket.promisePair.resolve(null);
          this.socket = { state: "paused" };
          return;
        }
        this.socket = { state: "disconnected" };
        const backoff = this.nextBackoff();
        console.log(`Attempting reconnect in ${backoff}ms`);
        setTimeout(() => this.connect(), backoff);
      };
    }
    socketState() {
      return this.socket.state;
    }
    sendMessage(message) {
      this._logVerbose(`sending message with type ${message.type}`);
      if (this.socket.state === "ready") {
        const request = JSON.stringify(message);
        try {
          this.socket.ws.send(request);
        } catch (error) {
          console.log(
            `Failed to send message on WebSocket, reconnecting: ${error}`
          );
          this.closeAndReconnect("FailedToSendMessage");
        }
        return true;
      }
      return false;
    }
    onServerActivity() {
      if (this.reconnectDueToServerInactivityTimeout !== null) {
        clearTimeout(this.reconnectDueToServerInactivityTimeout);
        this.reconnectDueToServerInactivityTimeout = null;
      }
      this.reconnectDueToServerInactivityTimeout = setTimeout(() => {
        this.closeAndReconnect("InactiveServer");
      }, this.serverInactivityThreshold);
    }
    closeAndReconnect(closeReason) {
      this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);
      switch (this.socket.state) {
        case "disconnected":
        case "closing":
        case "stopping":
        case "stopped":
        case "pausing":
        case "paused":
          return;
        case "connecting":
        case "ready":
          this.lastCloseReason = closeReason;
          this.socket.ws.close();
          this.socket = {
            state: "closing",
            ws: this.socket.ws
          };
          this._logVerbose("ws.close called");
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    async stop() {
      if (this.reconnectDueToServerInactivityTimeout) {
        clearTimeout(this.reconnectDueToServerInactivityTimeout);
      }
      switch (this.socket.state) {
        case "stopped":
          return;
        case "connecting":
        case "ready":
          this.socket.ws.close();
          this.socket = {
            state: "stopping",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "pausing":
        case "closing":
          this.socket = {
            state: "stopping",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "paused":
        case "disconnected":
          this.socket = { state: "stopped" };
          return;
        case "stopping":
          await this.socket.promisePair.promise;
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    async pause() {
      switch (this.socket.state) {
        case "stopping":
        case "stopped":
          return;
        case "paused":
          return;
        case "connecting":
        case "ready":
          this.socket.ws.close();
          this.socket = {
            state: "pausing",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "closing":
          this.socket = {
            state: "pausing",
            promisePair: promisePair()
          };
          await this.socket.promisePair.promise;
          return;
        case "disconnected":
          this.socket = { state: "paused" };
          return;
        case "pausing":
          await this.socket.promisePair.promise;
          return;
        default: {
          const _ = this.socket;
        }
      }
    }
    async resume() {
      switch (this.socket.state) {
        case "pausing":
        case "paused":
          break;
        case "stopping":
        case "stopped":
          return;
        case "connecting":
        case "ready":
        case "closing":
        case "disconnected":
          throw new Error("`resume()` is only valid after `pause()`");
        default: {
          const _ = this.socket;
        }
      }
      if (this.socket.state === "pausing") {
        await this.socket.promisePair.promise;
      }
      await this.connect();
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(`${new Date().toISOString()} ${message}`);
      }
    }
    nextBackoff() {
      const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);
      this.retries += 1;
      const actualBackoff = Math.min(baseBackoff, this.maxBackoff);
      const jitter = actualBackoff * (Math.random() - 0.5);
      return actualBackoff + jitter;
    }
  };

  // src/browser/sync/session.ts
  function newSessionId() {
    return uuidv4();
  }
  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r2 = Math.random() * 16 | 0, v = c === "x" ? r2 : r2 & 3 | 8;
      return v.toString(16);
    });
  }

  // ../common/temp/node_modules/.pnpm/jwt-decode@3.1.2/node_modules/jwt-decode/build/jwt-decode.esm.js
  function e(e2) {
    this.message = e2;
  }
  e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
  var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
    var t2 = String(r2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
      o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
    return c;
  };
  function t(e2) {
    var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
    switch (t2.length % 4) {
      case 0:
        break;
      case 2:
        t2 += "==";
        break;
      case 3:
        t2 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e3) {
        return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
          var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
          return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
        }));
      }(t2);
    } catch (e3) {
      return r(t2);
    }
  }
  function n(e2) {
    this.message = e2;
  }
  function o(e2, r2) {
    if ("string" != typeof e2)
      throw new n("Invalid token specified");
    var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
    try {
      return JSON.parse(t(e2.split(".")[o2]));
    } catch (e3) {
      throw new n("Invalid token specified: " + e3.message);
    }
  }
  n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
  var jwt_decode_esm_default = o;

  // src/browser/sync/authentication_manager.ts
  var AuthenticationManager = class {
    constructor(syncState, {
      authenticate,
      pauseSocket: pause,
      resumeSocket: resume,
      clearAuth,
      verbose
    }) {
      this.authState = { state: "noAuth" };
      this.configVersion = 0;
      this.syncState = syncState;
      this.authenticate = authenticate;
      this.pauseSocket = pause;
      this.resumeSocket = resume;
      this.clearAuth = clearAuth;
      this.verbose = verbose;
    }
    async setConfig(fetchToken, onChange) {
      this.resetAuthState();
      const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {
        forceRefreshToken: false
      });
      if (token.isFromOutdatedConfig) {
        return;
      }
      if (token.value) {
        this.setAuthState({
          state: "waitingForServerConfirmationOfCachedToken",
          config: { fetchToken, onAuthChange: onChange },
          hasRetried: false
        });
        this.authenticate(token.value);
      } else {
        await this.refetchToken();
      }
    }
    onTransition(serverMessage) {
      if (!this.syncState.isCurrentOrNewerAuthVersion(
        serverMessage.endVersion.identity
      )) {
        return;
      }
      if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) {
        return;
      }
      if (this.authState.state === "waitingForServerConfirmationOfCachedToken") {
        this._logVerbose("server confirmed auth token is valid");
        void this.refetchToken();
        this.authState.config.onAuthChange(true);
        return;
      }
      if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
        this._logVerbose("server confirmed new auth token is valid");
        this.scheduleTokenRefetch(this.authState.token);
        if (!this.authState.hadAuth) {
          this.authState.config.onAuthChange(true);
        }
      }
    }
    onAuthError(serverMessage) {
      const { baseVersion } = serverMessage;
      if (baseVersion !== null && baseVersion !== void 0) {
        if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {
          this._logVerbose("ignoring auth error for previous auth attempt");
          return;
        }
        void this.tryToReauthenticate(serverMessage);
        return;
      }
      void this.tryToReauthenticate(serverMessage);
    }
    async tryToReauthenticate(serverMessage) {
      if (this.authState.state === "noAuth" || this.authState.state === "waitingForServerConfirmationOfFreshToken") {
        console.error(
          `Failed to authenticate: "${serverMessage.error}", check your server auth config`
        );
        if (this.syncState.hasAuth()) {
          this.syncState.clearAuth();
        }
        if (this.authState.state !== "noAuth") {
          this.setAndReportAuthFailed(this.authState.config.onAuthChange);
        }
        return;
      }
      this._logVerbose("attempting to reauthenticate");
      await this.pauseSocket();
      const token = await this.fetchTokenAndGuardAgainstRace(
        this.authState.config.fetchToken,
        {
          forceRefreshToken: true
        }
      );
      if (token.isFromOutdatedConfig) {
        await this.resumeSocket();
        return;
      }
      if (token.value && this.syncState.isNewAuth(token.value)) {
        this.syncState.setAuth(token.value);
        this.setAuthState({
          state: "waitingForServerConfirmationOfFreshToken",
          config: this.authState.config,
          token: token.value,
          hadAuth: this.authState.state === "notRefetching" || this.authState.state === "waitingForScheduledRefetch"
        });
      } else {
        this._logVerbose("reauthentication failed, could not fetch a new token");
        if (this.syncState.hasAuth()) {
          this.syncState.clearAuth();
        }
        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
      }
      await this.resumeSocket();
    }
    async refetchToken() {
      if (this.authState.state === "noAuth") {
        return;
      }
      this._logVerbose("refetching auth token");
      const token = await this.fetchTokenAndGuardAgainstRace(
        this.authState.config.fetchToken,
        {
          forceRefreshToken: true
        }
      );
      if (token.isFromOutdatedConfig) {
        return;
      }
      if (token.value) {
        if (this.syncState.isNewAuth(token.value)) {
          this.setAuthState({
            state: "waitingForServerConfirmationOfFreshToken",
            hadAuth: this.syncState.hasAuth(),
            token: token.value,
            config: this.authState.config
          });
          this.authenticate(token.value);
        } else {
          this.setAuthState({
            state: "notRefetching",
            config: this.authState.config
          });
        }
      } else {
        this._logVerbose("refetching token failed");
        if (this.syncState.hasAuth()) {
          this.clearAuth();
        }
        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
      }
    }
    scheduleTokenRefetch(token) {
      if (this.authState.state === "noAuth") {
        return;
      }
      const decodedToken = this.decodeToken(token);
      if (!decodedToken) {
        console.error("Auth token is not a valid JWT, cannot refetch the token");
        return;
      }
      const { iat, exp } = decodedToken;
      if (!iat || !exp) {
        console.error(
          "Auth token does not have required fields, cannot refetch the token"
        );
        return;
      }
      const leewaySeconds = 2;
      const delay = (exp - iat - leewaySeconds) * 1e3;
      if (delay <= 0) {
        console.error(
          "Auth token does not live long enough, cannot refetch the token"
        );
        return;
      }
      const refetchTokenTimeoutId = setTimeout(() => {
        void this.refetchToken();
      }, delay);
      this.setAuthState({
        state: "waitingForScheduledRefetch",
        refetchTokenTimeoutId,
        config: this.authState.config
      });
      this._logVerbose(
        `scheduled preemptive auth token refetching in ${delay}ms`
      );
    }
    async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {
      const originalConfigVersion = ++this.configVersion;
      const token = await fetchToken(fetchArgs);
      if (this.configVersion !== originalConfigVersion) {
        return { isFromOutdatedConfig: true };
      }
      return { isFromOutdatedConfig: false, value: token };
    }
    stop() {
      this.resetAuthState();
      this.configVersion++;
    }
    setAndReportAuthFailed(onAuthChange) {
      onAuthChange(false);
      this.resetAuthState();
    }
    resetAuthState() {
      this.setAuthState({ state: "noAuth" });
    }
    setAuthState(newAuth) {
      if (this.authState.state === "waitingForScheduledRefetch") {
        clearTimeout(this.authState.refetchTokenTimeoutId);
      }
      this.authState = newAuth;
    }
    decodeToken(token) {
      try {
        return jwt_decode_esm_default(token);
      } catch (e2) {
        return null;
      }
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(
          `${new Date().toISOString()} ${message} [v${this.configVersion}]`
        );
      }
    }
  };

  // src/browser/sync/metrics.ts
  var markNames = [
    "convexClientConstructed",
    "convexWebSocketOpen",
    "convexFirstMessageReceived"
  ];
  function mark(name, sessionId) {
    const detail = { sessionId };
    if (typeof performance === "undefined" || !performance.mark)
      return;
    performance.mark(name, { detail });
  }
  function performanceMarkToJson(mark2) {
    let name = mark2.name.slice("convex".length);
    name = name.charAt(0).toLowerCase() + name.slice(1);
    return {
      name,
      startTime: mark2.startTime
    };
  }
  function getMarksReport(sessionId) {
    if (typeof performance === "undefined" || !performance.getEntriesByName) {
      return [];
    }
    const allMarks = [];
    for (const name of markNames) {
      const marks = performance.getEntriesByName(name).filter((entry) => entry.entryType === "mark").filter((mark2) => mark2.detail.sessionId === sessionId);
      allMarks.push(...marks);
    }
    return allMarks.map(performanceMarkToJson);
  }

  // src/browser/sync/client.ts
  var BaseConvexClient = class {
    constructor(address, onTransition, options) {
      this.fetchToken = null;
      this.refetchTokenTimeoutId = null;
      this.firstMessageReceived = false;
      this.mark = (name) => {
        if (this.debug) {
          mark(name, this.sessionId);
        }
      };
      if (typeof address === "object") {
        throw new Error(
          "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly."
        );
      }
      options = { ...options };
      let webSocketConstructor = options.webSocketConstructor;
      if (!webSocketConstructor && typeof WebSocket === "undefined") {
        throw new Error(
          "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient"
        );
      }
      webSocketConstructor = webSocketConstructor || WebSocket;
      this.verbose = options.verbose ?? false;
      this.debug = options.reportDebugInfoToConvex ?? false;
      this.address = address;
      const i = address.search("://");
      if (i === -1) {
        throw new Error("Provided address was not an absolute URL.");
      }
      const origin = address.substring(i + 3);
      const protocol = address.substring(0, i);
      let wsProtocol;
      if (protocol === "http") {
        wsProtocol = "ws";
      } else if (protocol === "https") {
        wsProtocol = "wss";
      } else {
        throw new Error(`Unknown parent protocol ${protocol}`);
      }
      const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;
      this.state = new LocalSyncState();
      this.remoteQuerySet = new RemoteQuerySet(
        (queryId) => this.state.queryPath(queryId)
      );
      this.requestManager = new RequestManager();
      this.authenticationManager = new AuthenticationManager(this.state, {
        authenticate: (token) => {
          const message = this.state.setAuth(token);
          this.webSocketManager.sendMessage(message);
        },
        pauseSocket: () => this.webSocketManager.pause(),
        resumeSocket: () => this.webSocketManager.resume(),
        clearAuth: () => {
          this.clearAuth();
        },
        verbose: this.verbose
      });
      this.optimisticQueryResults = new OptimisticQueryResults();
      this.onTransition = onTransition;
      this.nextRequestId = 0;
      this.sessionId = newSessionId();
      const { unsavedChangesWarning } = options;
      if (typeof window === "undefined" || typeof window.addEventListener === "undefined") {
        if (unsavedChangesWarning === true) {
          throw new Error(
            "unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options."
          );
        }
      } else if (unsavedChangesWarning !== false) {
        window.addEventListener("beforeunload", (e2) => {
          if (this.requestManager.hasIncompleteRequests()) {
            e2.preventDefault();
            const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
            (e2 || window.event).returnValue = confirmationMessage;
            return confirmationMessage;
          }
        });
      }
      this.webSocketManager = new WebSocketManager(
        wsUri,
        (reconnectMetadata) => {
          this.mark("convexWebSocketOpen");
          this.webSocketManager.sendMessage({
            ...reconnectMetadata,
            type: "Connect",
            sessionId: this.sessionId
          });
          this.remoteQuerySet = new RemoteQuerySet(
            (queryId) => this.state.queryPath(queryId)
          );
          const [querySetModification, authModification] = this.state.restart();
          if (authModification) {
            this.webSocketManager.sendMessage(authModification);
          }
          this.webSocketManager.sendMessage(querySetModification);
          for (const message of this.requestManager.restart()) {
            this.webSocketManager.sendMessage(message);
          }
        },
        (serverMessage) => {
          if (!this.firstMessageReceived) {
            this.firstMessageReceived = true;
            this.mark("convexFirstMessageReceived");
            this.reportMarks();
          }
          switch (serverMessage.type) {
            case "Transition": {
              this.authenticationManager.onTransition(serverMessage);
              this.remoteQuerySet.transition(serverMessage);
              this.state.saveQueryJournals(serverMessage);
              const completedRequests = this.requestManager.removeCompleted(
                this.remoteQuerySet.timestamp()
              );
              this.notifyOnQueryResultChanges(completedRequests);
              break;
            }
            case "MutationResponse": {
              const completedMutationId = this.requestManager.onResponse(serverMessage);
              if (completedMutationId) {
                this.notifyOnQueryResultChanges(/* @__PURE__ */ new Set([completedMutationId]));
              }
              break;
            }
            case "ActionResponse": {
              this.requestManager.onResponse(serverMessage);
              break;
            }
            case "AuthError": {
              this.authenticationManager.onAuthError(serverMessage);
              break;
            }
            case "FatalError": {
              const error = logFatalError(serverMessage.error);
              void this.webSocketManager.stop();
              throw error;
            }
            case "Ping":
              break;
            default: {
              const _typeCheck = serverMessage;
            }
          }
        },
        webSocketConstructor,
        this.verbose
      );
      this.mark("convexClientConstructed");
    }
    notifyOnQueryResultChanges(completedRequest) {
      const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
      const queryTokenToValue = /* @__PURE__ */ new Map();
      for (const [queryId, result] of remoteQueryResults) {
        const queryToken = this.state.queryToken(queryId);
        if (queryToken !== null) {
          const query = {
            result,
            udfPath: this.state.queryPath(queryId),
            args: this.state.queryArgs(queryId)
          };
          queryTokenToValue.set(queryToken, query);
        }
      }
      this.onTransition(
        this.optimisticQueryResults.ingestQueryResultsFromServer(
          queryTokenToValue,
          completedRequest
        )
      );
    }
    setAuth(fetchToken, onChange) {
      void this.authenticationManager.setConfig(fetchToken, onChange);
    }
    hasAuth() {
      return this.state.hasAuth();
    }
    setAdminAuth(value, fakeUserIdentity) {
      const message = this.state.setAdminAuth(value, fakeUserIdentity);
      this.webSocketManager.sendMessage(message);
    }
    clearAuth() {
      const message = this.state.clearAuth();
      this.webSocketManager.sendMessage(message);
    }
    subscribe(name, args, options) {
      const argsObject = parseArgs(args);
      const { modification, queryToken, unsubscribe } = this.state.subscribe(
        name,
        argsObject,
        options?.journal
      );
      if (modification !== null) {
        this.webSocketManager.sendMessage(modification);
      }
      return {
        queryToken,
        unsubscribe: () => {
          const modification2 = unsubscribe();
          if (modification2) {
            this.webSocketManager.sendMessage(modification2);
          }
        }
      };
    }
    localQueryResult(udfPath, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(udfPath, argsObject);
      return this.optimisticQueryResults.queryResult(queryToken);
    }
    localQueryLogs(udfPath, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(udfPath, argsObject);
      return this.optimisticQueryResults.queryLogs(queryToken);
    }
    queryJournal(name, args) {
      const argsObject = parseArgs(args);
      const queryToken = serializePathAndArgs(name, argsObject);
      return this.state.queryJournal(queryToken);
    }
    connectionState() {
      return {
        hasInflightRequests: this.requestManager.hasInflightRequests(),
        isWebSocketConnected: this.webSocketManager.socketState() === "ready",
        timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest()
      };
    }
    async mutation(name, args, options) {
      const result = await this.mutationInternal(name, args, options);
      if (!result.success) {
        throw createError("mutation", name, result.errorMessage);
      }
      return result.value;
    }
    async mutationInternal(udfPath, args, options) {
      const mutationArgs = parseArgs(args);
      this.tryReportLongDisconnect();
      const requestId = this.nextRequestId;
      this.nextRequestId++;
      if (options !== void 0) {
        const optimisticUpdate = options.optimisticUpdate;
        if (optimisticUpdate !== void 0) {
          const wrappedUpdate = (localQueryStore) => {
            optimisticUpdate(localQueryStore, mutationArgs);
          };
          const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(
            wrappedUpdate,
            requestId
          );
          this.onTransition(changedQueries);
        }
      }
      const message = {
        type: "Mutation",
        requestId,
        udfPath,
        args: [convexToJson(mutationArgs)]
      };
      const mightBeSent = this.webSocketManager.sendMessage(message);
      return this.requestManager.request(message, mightBeSent);
    }
    async action(name, args) {
      const result = await this.actionInternal(name, args);
      if (!result.success) {
        throw createError("action", name, result.errorMessage);
      }
      return result.value;
    }
    async actionInternal(udfPath, args) {
      const actionArgs = parseArgs(args);
      const requestId = this.nextRequestId;
      this.nextRequestId++;
      this.tryReportLongDisconnect();
      const message = {
        type: "Action",
        requestId,
        udfPath,
        args: [convexToJson(actionArgs)]
      };
      const mightBeSent = this.webSocketManager.sendMessage(message);
      return this.requestManager.request(message, mightBeSent);
    }
    async close() {
      this.authenticationManager.stop();
      return this.webSocketManager.stop();
    }
    _logVerbose(message) {
      if (this.verbose) {
        console.debug(`${new Date().toISOString()} ${message}`);
      }
    }
    reportMarks() {
      if (this.debug) {
        const report = getMarksReport(this.sessionId);
        this.webSocketManager.sendMessage({
          type: "Event",
          eventType: "ClientConnect",
          event: report
        });
      }
    }
    tryReportLongDisconnect() {
      if (!this.debug) {
        return;
      }
      const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;
      if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {
        return;
      }
      const endpoint = `${this.address}/api/debug_event`;
      fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Convex-Client": `npm-${version}`
        },
        body: JSON.stringify({ event: "LongWebsocketDisconnect" })
      }).then((response) => {
        if (!response.ok) {
          console.warn(
            "Analytics request failed with response:",
            response.body
          );
        }
      }).catch((error) => {
        console.warn("Analytics response failed with error:", error);
      });
    }
  };

  // src/browser/http_client.ts
  var fetch2 = globalThis.fetch || ((...args) => Promise.resolve().then(() => __toESM(require_browser())).then(
    ({ default: fetch3 }) => fetch3(...args)
  ));
  var ConvexHttpClient = class {
    constructor(address) {
      this.address = `${address}/api`;
      this.debug = true;
    }
    backendUrl() {
      return this.address;
    }
    setAuth(value) {
      this.auth = value;
    }
    clearAuth() {
      this.auth = void 0;
    }
    setDebug(debug) {
      this.debug = debug;
    }
    async query(name, ...args) {
      const queryArgs = parseArgs(args[0]);
      const body = JSON.stringify({
        path: name,
        args: [convexToJson(queryArgs)],
        debug: this.debug
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const response = await fetch2(`${this.address}/query`, {
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      for (const line of respJSON.logLines ?? []) {
        logToConsole("info", "query", name, line);
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value);
        case "error":
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
    async mutation(name, ...args) {
      const mutationArgs = parseArgs(args[0]);
      const body = JSON.stringify({
        path: name,
        args: [convexToJson(mutationArgs)],
        debug: this.debug
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const response = await fetch2(`${this.address}/mutation`, {
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      for (const line of respJSON.logLines ?? []) {
        logToConsole("info", "mutation", name, line);
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value);
        case "error":
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
    async action(name, ...args) {
      const actionArgs = parseArgs(args[0]);
      const body = JSON.stringify({
        path: name,
        args: [convexToJson(actionArgs)],
        debug: this.debug
      });
      const headers = {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      };
      if (this.auth) {
        headers["Authorization"] = `Bearer ${this.auth}`;
      }
      const response = await fetch2(`${this.address}/action`, {
        body,
        method: "POST",
        headers,
        credentials: "include"
      });
      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
        throw new Error(await response.text());
      }
      const respJSON = await response.json();
      for (const line of respJSON.logLines ?? []) {
        logToConsole("info", "action", name, line);
      }
      switch (respJSON.status) {
        case "success":
          return jsonToConvex(respJSON.value);
        case "error":
          throw new Error(respJSON.errorMessage);
        default:
          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
      }
    }
  };
  return __toCommonJS(browser_exports);
})();
//# sourceMappingURL=browser.bundle.js.map
