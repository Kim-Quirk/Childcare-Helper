{
  "version": 3,
  "sources": ["../../../src/server/scheduler.ts"],
  "sourcesContent": ["import {\n  ActionNames,\n  GenericAPI,\n  MutationNames,\n  NamedAction,\n  NamedMutation,\n  OptionalRestArgs,\n} from \"../browser\";\n\n/**\n * The names of all of the schedulable in a Convex API.\n *\n * These are all of the mutations and actions.\n *\n * @public\n */\nexport type SchedulableFunctionNames<API extends GenericAPI> =\n  | ActionNames<API>\n  | MutationNames<API>;\n\n/**\n * The type of a schedulable function in a Convex API.\n *\n * @public\n */\nexport type NamedSchedulableFunction<\n  API extends GenericAPI,\n  Name extends SchedulableFunctionNames<API>\n> = Name extends ActionNames<API>\n  ? NamedAction<API, Name>\n  : NamedMutation<API, Name>;\n\n/**\n * An interface to schedule Convex functions.\n *\n * You can schedule either mutations or actions. Mutations are guaranteed to execute\n * exactly once - they are automatically retried on transient errors and either execute\n * successfully or fail deterministically due to developer error in defining the\n * function. Actions execute at most once - they are not retried and might fail\n * due to transient errors.\n *\n * Consider using an {@link internalMutation} or {@link internalAction} to enforce that\n * these functions cannot be called directly from a Convex client.\n *\n * @public\n */\nexport interface Scheduler<API extends GenericAPI> {\n  /**\n   * Schedule a function to execute after a delay.\n   *\n   * @param delayMs - delay in milliseconds. Must be non-negative. If the delay\n   * is zero, the scheduled function will be due to execute immediately after the\n   * scheduling one completes.\n   * @param name - the name of the function to schedule.\n   * @param args - arguments to call the scheduled functions with.\n   **/\n  runAfter<Name extends SchedulableFunctionNames<API>>(\n    delayMs: number,\n    name: Name,\n    ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>\n  ): Promise<void>;\n\n  /**\n   * Schedule a function to execute at a given timestamp.\n   *\n   * @param timestamp - a Date or a timestamp (milliseconds since the epoch).\n   * If the timestamp is in the past, the scheduled function will be due to\n   * execute immediately after the scheduling one completes. The timestamp can't\n   * be more than five years in the past or more than five years in the future.\n   * @param name - the name of the function to schedule.\n   * @param args - arguments to call the scheduled functions with.\n   **/\n  runAt<Name extends SchedulableFunctionNames<API>>(\n    timestamp: number | Date,\n    name: Name,\n    ...args: OptionalRestArgs<NamedSchedulableFunction<API, Name>>\n  ): Promise<void>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
