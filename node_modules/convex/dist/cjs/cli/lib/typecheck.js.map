{
  "version": 3,
  "sources": ["../../../../src/cli/lib/typecheck.ts"],
  "sourcesContent": ["import child_process from \"child_process\";\nimport chalk from \"chalk\";\nimport path from \"path\";\nimport {\n  Context,\n  logError,\n  logFailure,\n  pauseSpinner,\n  resumeSpinner,\n} from \"./context\";\nimport * as Sentry from \"@sentry/node\";\nimport * as semver from \"semver\";\n\nexport type TypecheckResult = \"cantTypeCheck\" | \"success\" | \"typecheckFailed\";\n\nexport type TypeCheckMode = \"enable\" | \"try\" | \"disable\";\n\ntype TypecheckResultHandler = (\n  result: TypecheckResult,\n  logSpecificError?: () => void\n) => Promise<void>;\n\n/**\n * Conditionally run a typecheck function and interpret the result.\n *\n * If typeCheckMode === \"disable\", never run the typecheck function.\n * If typeCheckMode === \"enable\", run the typecheck and crash if typechecking\n * fails or we can't find tsc.\n * If typeCheckMode === \"try\", try and run the typecheck. crash if typechecking\n * fails but don't worry if tsc is missing and we can't run it.\n */\nexport async function typeCheckFunctionsInMode(\n  ctx: Context,\n  typeCheckMode: TypeCheckMode,\n  functionsDir: string\n): Promise<void> {\n  if (typeCheckMode === \"disable\") {\n    return;\n  }\n  await typeCheckFunctions(\n    ctx,\n    functionsDir,\n    async (result, logSpecificError) => {\n      if (\n        (result === \"cantTypeCheck\" && typeCheckMode === \"enable\") ||\n        result === \"typecheckFailed\"\n      ) {\n        logSpecificError?.();\n        logError(\n          ctx,\n          chalk.gray(\"To ignore failing typecheck, use `--typecheck=disable`.\")\n        );\n        await ctx.crash(1, \"invalid filesystem data\");\n      }\n    }\n  );\n}\n\n// Runs TypeScript compiler to typecheck Convex query and mutation functions.\nexport async function typeCheckFunctions(\n  ctx: Context,\n  functionsDir: string,\n  handleResult: TypecheckResultHandler\n): Promise<void> {\n  const tsconfig = path.join(functionsDir, \"tsconfig.json\");\n  if (!ctx.fs.exists(tsconfig)) {\n    return handleResult(\"cantTypeCheck\", () => {\n      logError(\n        ctx,\n        \"Found no convex/tsconfig.json to use to typecheck Convex functions, so skipping typecheck.\"\n      );\n      logError(ctx, \"Run `npx convex codegen --init` to create one.\");\n    });\n  }\n  await runTsc(ctx, [\"--project\", functionsDir], handleResult);\n}\n\nasync function runTsc(\n  ctx: Context,\n  tscArgs: string[],\n  handleResult: TypecheckResultHandler\n): Promise<void> {\n  // Check if tsc is even installed\n  const tscPath = path.join(\n    \"node_modules\",\n    \".bin\",\n    process.platform === \"win32\" ? \"tsc.CMD\" : \"tsc\"\n  );\n  if (!ctx.fs.exists(tscPath)) {\n    return handleResult(\"cantTypeCheck\", () => {\n      logError(\n        ctx,\n        chalk.gray(\"No TypeScript binary found, so skipping typecheck.\")\n      );\n    });\n  }\n\n  // Check the TypeScript version matches the recommendation from Convex\n  const versionResult = child_process.spawnSync(tscPath, [\"--version\"]);\n  const version =\n    versionResult.stdout.toString(\"utf-8\").match(/Version (.*)/)?.[1] ?? null;\n  const hasOlderTypeScriptVersion = version && semver.lt(version, \"4.8.4\");\n\n  await runTscInner(ctx, tscPath, tscArgs, handleResult);\n\n  // Print this warning after any logs from running `tsc`\n  if (hasOlderTypeScriptVersion) {\n    logError(\n      ctx,\n      chalk.yellow(\n        \"Convex works best with TypeScript version 4.8.4 or newer -- npm i --save-dev typescript@latest to update.\"\n      )\n    );\n  }\n}\n\nasync function runTscInner(\n  ctx: Context,\n  tscPath: string,\n  tscArgs: string[],\n  handleResult: TypecheckResultHandler\n) {\n  // We're letting TypeScript print errors directly to console later,\n  // and the first call below is \"sync\", so the spinner would stop\n  // spinning. Hide it.\n  pauseSpinner(ctx);\n\n  // Run `tsc` once and have it print out the files it touched. This output won't\n  // be very useful if there's an error, but we'll run it again to get a nice\n  // user-facing error in this exceptional case.\n  // The `--listFiles` command prints out files touched on success or error.\n  const result = child_process.spawnSync(\n    tscPath,\n    tscArgs.concat(\"--listFiles\")\n  );\n  if (result.status === null) {\n    return handleResult(\"typecheckFailed\", () => {\n      logError(ctx, chalk.red(`TypeScript typecheck timed out.`));\n      if (result.error) {\n        logError(ctx, chalk.red(`${result.error}`));\n      }\n    });\n  }\n  // Okay, we may have failed `tsc` but at least it returned. Try to parse its\n  // output to discover which files it touched.\n  const filesTouched = result.stdout\n    .toString(\"utf-8\")\n    .split(\"\\n\")\n    .map(s => s.trim())\n    .filter(s => s.length > 0);\n  let anyPathsFound = false;\n  for (const fileTouched of filesTouched) {\n    const absPath = path.resolve(fileTouched);\n    let st;\n    try {\n      st = ctx.fs.stat(absPath);\n      anyPathsFound = true;\n    } catch (err: any) {\n      // Just move on if we have a bogus path from `tsc`. We'll log below if\n      // we fail to stat *any* of the paths emitted by `tsc`.\n      // TODO: Switch to using their JS API so we can get machine readable output.\n      continue;\n    }\n    ctx.fs.registerPath(absPath, st);\n  }\n  if (filesTouched.length > 0 && !anyPathsFound) {\n    const err = new Error(\n      `Failed to stat any files emitted by tsc (received ${filesTouched.length})`\n    );\n    Sentry.captureException(err);\n  }\n\n  if (!result.error && result.status === 0) {\n    return handleResult(\"success\");\n  }\n\n  // This is the \"No inputs were found\", which is fine and we shouldn't\n  // report it to the user.\n  if (result.stdout.toString(\"utf-8\").startsWith(\"error TS18003\")) {\n    return handleResult(\"success\");\n  }\n\n  // At this point we know that `tsc` failed. Rerun it without `--listFiles`\n  // and with stderr redirected to have it print out a nice error.\n  try {\n    // prettier-ignore\n    child_process.execFileSync(tscPath, tscArgs, { stdio: \"inherit\" });\n    resumeSpinner(ctx);\n    // If this passes, we had a concurrent file change that'll overlap with\n    // our observations in the first run. Invalidate our context's filesystem\n    // but allow the rest of the system to observe the success.\n    ctx.fs.invalidate();\n    return handleResult(\"success\");\n  } catch (e) {\n    return handleResult(\"typecheckFailed\", () => {\n      logFailure(ctx, \"TypeScript typecheck via `tsc` failed.\");\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["chalk", "path", "child_process"]
}
