"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var init_exports = {};
__export(init_exports, {
  init: () => init
});
module.exports = __toCommonJS(init_exports);
var import_chalk = __toESM(require("chalk"));
var import_config = require("./config.js");
var import_utils = require("./utils.js");
var import_inquirer = __toESM(require("inquirer"));
var import_path = __toESM(require("path"));
var import_codegen = require("./codegen");
var import_context = require("./context.js");
var import_dashboard = require("../dashboard.js");
var import_envvars = require("./envvars.js");
const cwd = import_path.default.basename(process.cwd());
async function init(ctx, config, saveUrl = "ask", promptForAdditionalSteps, options = { allowExistingConfig: false }) {
  const configPath = await (0, import_config.configFilepath)(ctx);
  if (ctx.fs.exists(configPath)) {
    if (!(0, import_config.removedExistingConfig)(ctx, configPath, options)) {
      console.error(
        import_chalk.default.green(`Found existing project config "${configPath}"`)
      );
      return;
    }
  }
  const { teamSlug: selectedTeam, chosen: didChooseBetweenTeams } = await (0, import_utils.validateOrSelectTeam)(ctx, config.team, "Team:");
  let projectName = config.project || cwd;
  if (process.stdin.isTTY && !config.project) {
    projectName = (await import_inquirer.default.prompt([
      {
        type: "input",
        name: "project",
        message: "Project name:",
        default: cwd
      }
    ])).project;
  }
  const prodEnvVarWrite = await (0, import_envvars.askAboutWritingToEnv)(
    ctx,
    "prod",
    null,
    saveUrl
  );
  const executeAdditionalSteps = await promptForAdditionalSteps?.();
  (0, import_context.showSpinner)(ctx, "Creating new Convex project...");
  let projectSlug, teamSlug, prodUrl, adminKey, projectsRemaining, projectConfig, modules;
  try {
    ({ projectSlug, teamSlug, prodUrl, adminKey, projectsRemaining } = await create_project(ctx, selectedTeam, projectName));
    ({ projectConfig, modules } = await (0, import_config.pullConfig)(
      ctx,
      projectSlug,
      teamSlug,
      prodUrl,
      adminKey
    ));
  } catch (err) {
    (0, import_context.logFailure)(ctx, "Unable to create project.");
    return await (0, import_utils.logAndHandleAxiosError)(ctx, err);
  }
  const teamMessage = didChooseBetweenTeams ? " in team " + import_chalk.default.bold(teamSlug) : "";
  (0, import_context.logFinishedStep)(
    ctx,
    `Created project ${import_chalk.default.bold(
      projectSlug
    )}${teamMessage}, manage it at ${import_chalk.default.bold(
      await (0, import_dashboard.dashboardUrlForConfig)(projectConfig, false)
    )}`
  );
  if (projectsRemaining <= 2) {
    console.log(
      import_chalk.default.yellow.bold(
        `Your account now has ${projectsRemaining} project${projectsRemaining === 1 ? "" : "s"} remaining.`
      )
    );
  }
  if (modules.length > 0) {
    console.error(import_chalk.default.red("Error: Unexpected modules in new project"));
    return await ctx.crash(1, void 0);
  }
  const packages = await (0, import_utils.loadPackageJson)(ctx);
  const isCreateReactApp = "react-scripts" in packages;
  if (isCreateReactApp) {
    projectConfig.functions = `src/${projectConfig.functions}`;
  }
  await (0, import_config.writeProjectConfig)(ctx, projectConfig);
  await (0, import_codegen.doInitCodegen)(
    ctx,
    (0, import_utils.functionsDir)(configPath, projectConfig),
    true
  );
  {
    const { projectConfig: projectConfig2, configPath: configPath2 } = await (0, import_config.readProjectConfig)(ctx);
    await (0, import_codegen.doCodegen)({
      ctx,
      projectConfig: projectConfig2,
      configPath: configPath2,
      typeCheckMode: "disable",
      quiet: true
    });
  }
  (0, import_context.logFinishedStep)(ctx, `Convex configuration written to ${configPath}`);
  await (0, import_envvars.writeToEnv)(ctx, prodEnvVarWrite, projectConfig.prodUrl);
  (0, import_envvars.logProvisioning)(ctx, prodEnvVarWrite, "prod", projectConfig.prodUrl);
  await executeAdditionalSteps?.();
  console.log(
    `
Write your Convex functions in ${import_chalk.default.bold(
      (0, import_utils.functionsDir)(configPath, projectConfig)
    )}`
  );
  console.log(
    "Give us feedback at https://convex.dev/community or support@convex.dev\n"
  );
}
async function create_project(ctx, team, projectName) {
  const provisioningArgs = {
    team,
    backendVersionOverride: process.env.CONVEX_BACKEND_VERSION_OVERRIDE,
    projectName
  };
  const data = await (0, import_utils.bigBrainAPI)(
    ctx,
    "POST",
    "create_project",
    provisioningArgs
  );
  const projectSlug = data.projectSlug;
  const teamSlug = data.teamSlug;
  const prodUrl = data.prodUrl;
  const adminKey = data.adminKey;
  const projectsRemaining = data.projectsRemaining;
  if (projectSlug === void 0 || teamSlug === void 0 || prodUrl === void 0 || adminKey === void 0 || projectsRemaining === void 0) {
    throw new Error(
      "Unknown error during provisioning: " + JSON.stringify(data)
    );
  }
  return { projectSlug, teamSlug, prodUrl, adminKey, projectsRemaining };
}
//# sourceMappingURL=init.js.map
