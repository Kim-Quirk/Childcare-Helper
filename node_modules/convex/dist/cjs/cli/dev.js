"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var dev_exports = {};
__export(dev_exports, {
  dev: () => dev,
  promptToInitWithProjects: () => promptToInitWithProjects,
  promptToReconfigure: () => promptToReconfigure
});
module.exports = __toCommonJS(dev_exports);
var import_inquirer = __toESM(require("inquirer"));
var import_chalk = __toESM(require("chalk"));
var import_commander = require("commander");
var import_path = __toESM(require("path"));
var import_perf_hooks = require("perf_hooks");
var import_api = require("./lib/api");
var import_config = require("./lib/config");
var import_context = require("./lib/context");
var import_envvars = require("./lib/envvars");
var import_login = require("./lib/login");
var import_push = require("./lib/push");
var import_utils = require("./lib/utils");
var import_watch = require("./lib/watch");
var import_init = require("./lib/init");
var import_reinit = require("./lib/reinit");
const dev = new import_commander.Command("dev").summary("Develop against a dev deployment, watching for changes").description(
  "Configures a new or existing project if needed. Watches for local changes and pushes them to the configured dev deployment. Updates generated types."
).option("-v, --verbose", "Show full listing of changes").addOption(
  new import_commander.Option(
    "--typecheck <mode>",
    `Check TypeScript files with \`tsc --noEmit\`.`
  ).choices(["enable", "try", "disable"]).default("try")
).option("--save-url", "Save deployment URLs to .env and .env.local").option("--no-save-url", "Do not save deployment URLs to .env and .env.local").addOption(
  new import_commander.Option("--codegen <mode>", "Regenerate code in `convex/_generated/`").choices(["enable", "disable"]).default("enable")
).option("--once", "Run only once, do not watch for changes").addOption(
  new import_commander.Option(
    "--configure <choice>",
    "Choose whether to configure new or existing project"
  ).choices(["new", "existing", "ask"]).default("ask")
).option("--team <team_slug>", "The team you'd like to use for this project").option(
  "--project <project_slug>",
  "The name of the project you'd like to configure"
).addOption(
  new import_commander.Option(
    "--prod",
    "Develop live against this project's production deployment."
  ).hideHelp()
).addOption(new import_commander.Option("--trace-events").hideHelp()).addOption(new import_commander.Option("--admin-key <adminKey>").hideHelp()).addOption(new import_commander.Option("--url <url>").hideHelp()).addOption(new import_commander.Option("--override-auth-url <url>").hideHelp()).addOption(new import_commander.Option("--override-auth-client <id>").hideHelp()).addOption(new import_commander.Option("--override-auth-username <username>").hideHelp()).addOption(new import_commander.Option("--override-auth-password <password>").hideHelp()).showHelpAfterError().action(async (cmdOptions) => {
  const ctx = import_context.oneoffContext;
  const saveUrl = cmdOptions.saveUrl === true ? "yes" : cmdOptions.saveUrl === false ? "no" : "ask";
  if (!cmdOptions.url || !cmdOptions.adminKey) {
    if (!await (0, import_login.checkAuthorization)(ctx)) {
      await (0, import_login.performLogin)(ctx, cmdOptions);
    }
  }
  let projectConfig;
  let options;
  const promptForDevDeployment = (isInit) => async () => {
    const devEnvVarWrite = await (0, import_envvars.askAboutWritingToEnv)(
      ctx,
      "dev",
      null,
      saveUrl
    );
    return async () => {
      projectConfig = (await (0, import_config.readProjectConfig)(ctx)).projectConfig;
      options = await getDevDeploymentOptions(ctx, projectConfig, cmdOptions);
      await (0, import_envvars.writeToEnv)(ctx, devEnvVarWrite, options.url);
      if (isInit) {
        (0, import_envvars.logProvisioning)(ctx, devEnvVarWrite, "dev", options.url);
      } else {
        (0, import_envvars.logConfiguration)(ctx, devEnvVarWrite, "dev", options.url);
      }
    };
  };
  const chosenConfiguration = cmdOptions.configure === "ask" ? null : cmdOptions.configure;
  const { team, project } = cmdOptions;
  if (!await (0, import_utils.isInExistingProject)(ctx)) {
    const choice = chosenConfiguration ?? await askToConfigure(ctx);
    switch (choice) {
      case "new":
        await (0, import_init.init)(
          ctx,
          { team, project },
          saveUrl,
          promptForDevDeployment(true)
        );
        break;
      case "existing":
        await (0, import_reinit.reinit)(
          ctx,
          { team, project },
          saveUrl,
          promptForDevDeployment(false)
        );
        break;
      default: {
        const _exhaustivenessCheck = choice;
      }
    }
  } else {
    projectConfig = (await (0, import_config.readProjectConfig)(ctx)).projectConfig;
    try {
      options = await getDevDeploymentOptionsMaybeThrows(
        ctx,
        projectConfig,
        cmdOptions
      );
      await (0, import_envvars.offerToWriteToEnv)(ctx, "dev", options.url, saveUrl);
    } catch (error) {
      const choice = chosenConfiguration ?? await askToReconfigure(ctx, projectConfig, error);
      switch (choice) {
        case "new":
          await (0, import_init.init)(
            ctx,
            { team, project },
            saveUrl,
            promptForDevDeployment(true),
            { allowExistingConfig: true }
          );
          break;
        case "existing":
          await (0, import_reinit.reinit)(
            ctx,
            { team, project },
            saveUrl,
            promptForDevDeployment(false),
            { allowExistingConfig: true }
          );
          break;
        default: {
          const _exhaustivenessCheck = choice;
        }
      }
    }
  }
  await watchAndPush(ctx, projectConfig, options, cmdOptions);
});
async function watchAndPush(outerCtx, { project: projectSlug, team: teamSlug }, options, cmdOptions) {
  let watcher;
  let numFailures = 0;
  while (true) {
    const start = import_perf_hooks.performance.now();
    const ctx = new import_watch.WatchContext(cmdOptions.traceEvents);
    (0, import_context.showSpinner)(ctx, "Preparing Convex functions...");
    const config = await (0, import_config.readProjectConfig)(ctx);
    if (projectSlug !== config.projectConfig.project || teamSlug !== config.projectConfig.team) {
      (0, import_context.logFailure)(ctx, "Detected a change in your `convex.json`. Exiting...");
      return await outerCtx.crash(1, "invalid filesystem data");
    }
    try {
      await (0, import_push.runPush)(ctx, options);
      const end = import_perf_hooks.performance.now();
      numFailures = 0;
      (0, import_context.logFinishedStep)(
        ctx,
        `${(0, import_utils.getCurrentTimeString)()} Convex functions ready! (${(0, import_utils.formatDuration)(
          end - start
        )})`
      );
    } catch (e) {
      if (!(e instanceof import_watch.Crash) || !e.errorType || e.errorType === "fatal") {
        throw e;
      }
      if (e.errorType === "transient") {
        const delay = nextBackoff(numFailures);
        numFailures += 1;
        console.log(
          import_chalk.default.yellow(
            `Failed due to network error, retrying in ${(0, import_utils.formatDuration)(
              delay
            )}...`
          )
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }
      console.assert(e.errorType === "invalid filesystem data");
      if (cmdOptions.once) {
        await outerCtx.crash(1, e.errorType);
      }
      (0, import_context.stopSpinner)(ctx);
    }
    if (cmdOptions.once) {
      return;
    }
    const observations = ctx.fs.finalize();
    if (observations === "invalidated") {
      console.log("Filesystem changed during push, retrying...");
      continue;
    }
    if (!watcher) {
      watcher = new import_watch.Watcher(observations);
      await watcher.ready();
    }
    watcher.update(observations);
    let anyChanges = false;
    do {
      await watcher.waitForEvent();
      for (const event of watcher.drainEvents()) {
        if (cmdOptions.traceEvents) {
          console.log(
            "Processing",
            event.name,
            import_path.default.relative("", event.absPath)
          );
        }
        const result = observations.overlaps(event);
        if (result.overlaps) {
          const relPath = import_path.default.relative("", event.absPath);
          if (cmdOptions.traceEvents) {
            console.log(`${relPath} ${result.reason}, rebuilding...`);
          }
          anyChanges = true;
          break;
        }
      }
    } while (!anyChanges);
    let deadline = import_perf_hooks.performance.now() + quiescenceDelay;
    while (true) {
      const now = import_perf_hooks.performance.now();
      if (now >= deadline) {
        break;
      }
      const remaining = deadline - now;
      if (cmdOptions.traceEvents) {
        console.log(`Waiting for ${(0, import_utils.formatDuration)(remaining)} to quiesce...`);
      }
      const remainingWait = new Promise(
        (resolve) => setTimeout(() => resolve("timeout"), deadline - now)
      );
      const result = await Promise.race([
        remainingWait,
        watcher.waitForEvent().then(() => "newEvents")
      ]);
      if (result === "newEvents") {
        for (const event of watcher.drainEvents()) {
          const result2 = observations.overlaps(event);
          if (result2.overlaps) {
            if (cmdOptions.traceEvents) {
              console.log(
                `Received an overlapping event at ${event.absPath}, delaying push.`
              );
            }
            deadline = import_perf_hooks.performance.now() + quiescenceDelay;
          }
        }
      } else {
        console.assert(result === "timeout");
      }
    }
  }
}
async function askToConfigure(ctx) {
  if (!await (0, import_utils.hasProjects)(ctx)) {
    return "new";
  }
  return await promptToInitWithProjects();
}
async function askToReconfigure(ctx, projectConfig, error) {
  const { team, project } = projectConfig;
  const [isExistingTeam, existingProject, hasAnyProjects] = await Promise.all([
    await (0, import_utils.hasTeam)(ctx, team),
    await (0, import_utils.hasProject)(ctx, team, project),
    await (0, import_utils.hasProjects)(ctx)
  ]);
  if (isExistingTeam && existingProject) {
    return await (0, import_utils.logAndHandleAxiosError)(ctx, error);
  }
  if (isExistingTeam) {
    (0, import_context.logFailure)(
      ctx,
      `Project ${import_chalk.default.bold(project)} does not exist in your team ${import_chalk.default.bold(
        team
      )}, as configured in ${import_chalk.default.bold("convex.json")}`
    );
  } else {
    (0, import_context.logFailure)(
      ctx,
      `You don't have access to team ${import_chalk.default.bold(
        team
      )}, as configured in ${import_chalk.default.bold("convex.json")}`
    );
  }
  if (!hasAnyProjects) {
    const { confirmed } = await import_inquirer.default.prompt([
      {
        type: "confirm",
        name: "confirmed",
        message: `Create a new project?`,
        default: "new",
        choices: [
          { name: "a new project", value: "new" },
          { name: "an existing project", value: "existing" }
        ]
      }
    ]);
    if (!confirmed) {
      console.error(
        "Run `npx convex dev` in a directory with a valid convex.json."
      );
      return await ctx.crash(1, "invalid filesystem data");
    }
    return "new";
  }
  return await promptToReconfigure();
}
async function getDevDeploymentOptions(ctx, projectConfig, cmdOptions) {
  try {
    return await getDevDeploymentOptionsMaybeThrows(
      ctx,
      projectConfig,
      cmdOptions
    );
  } catch (error) {
    return await (0, import_utils.logAndHandleAxiosError)(ctx, error);
  }
}
async function getDevDeploymentOptionsMaybeThrows(ctx, projectConfig, cmdOptions) {
  const projectSlug = projectConfig.project;
  const teamSlug = projectConfig.team;
  let deployment;
  if (!cmdOptions.url || !cmdOptions.adminKey) {
    if (cmdOptions.prod) {
      deployment = await (0, import_api.getUrlAndAdminKey)(ctx, projectSlug, teamSlug, "prod");
      console.error("Found deployment ready");
    } else {
      deployment = await (0, import_api.getDevDeploymentMaybeThrows)(ctx, {
        projectSlug,
        teamSlug
      });
    }
  }
  const adminKey = cmdOptions.adminKey ?? deployment.adminKey;
  const url = cmdOptions.url ?? deployment.url;
  return {
    adminKey,
    verbose: !!cmdOptions.verbose,
    dryRun: false,
    typecheck: cmdOptions.typecheck,
    debug: false,
    codegen: cmdOptions.codegen === "enable",
    url
  };
}
const initialBackoff = 500;
const maxBackoff = 16e3;
const quiescenceDelay = 500;
function nextBackoff(prevFailures) {
  const baseBackoff = initialBackoff * Math.pow(2, prevFailures);
  const actualBackoff = Math.min(baseBackoff, maxBackoff);
  const jitter = actualBackoff * (Math.random() - 0.5);
  return actualBackoff + jitter;
}
async function promptToInitWithProjects() {
  const { choice } = await import_inquirer.default.prompt([
    {
      type: "list",
      name: "choice",
      message: `What would you like to configure?`,
      default: "new",
      choices: [
        { name: "a new project", value: "new" },
        { name: "an existing project", value: "existing" }
      ]
    }
  ]);
  return choice;
}
async function promptToReconfigure() {
  const { choice } = await import_inquirer.default.prompt([
    {
      type: "list",
      name: "choice",
      message: `Configure a different project?`,
      default: "new",
      choices: [
        { name: "create new project", value: "new" },
        { name: "choose an existing project", value: "existing" }
      ]
    }
  ]);
  return choice;
}
//# sourceMappingURL=dev.js.map
