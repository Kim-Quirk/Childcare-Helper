{
  "version": 3,
  "sources": ["../../../src/react/use_paginated_query.ts"],
  "sourcesContent": ["import { useMemo, useState } from \"react\";\n\nimport { GenericAPI, NamedQuery } from \"../api/index.js\";\nimport {\n  ConvexFunction,\n  OptimisticLocalStore,\n  PublicQueryNames,\n} from \"../browser/index.js\";\nimport { PaginationOptions, PaginationResult } from \"../server/index.js\";\nimport { BetterOmit, Expand } from \"../type_utils.js\";\nimport { convexToJson, Value } from \"../values/index.js\";\nimport { RequestForQueries, useQueriesGeneric } from \"./use_queries.js\";\n\n/**\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with Convex query functions that match\n * {@link PaginatedQueryFunction}. This means they must:\n * 1. Have a single arguments object with a `paginationOpts` property\n * of type {@link server.PaginationOptions}.\n * 2. Return a {@link server.PaginationResult}.\n *\n * `usePaginatedQueryGeneric` concatenates all the pages\n * of results into a single list and manages the continuation cursors when\n * requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, loadMore } = usePaginatedQueryGeneric(\n *   \"listMessages\",\n *   { channel: \"#general\" },\n *   { initialNumItems: 5 }\n * );\n * ```\n *\n * If the query `name` or `args` change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * or QueryScannedTooManyDocuments error, the pagination state will also reset\n * to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).\n *\n * If you're using code generation, use the `usePaginatedQuery` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @param name - The name of the query function.\n * @param args - The arguments object for the query function, excluding\n * the `paginationOpts` property. That property is injected by this hook.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQueryGeneric(\n  name: string,\n  args: Record<string, Value>,\n  options: { initialNumItems: number }\n): UsePaginatedQueryResult<any> {\n  if (\n    typeof options?.initialNumItems !== \"number\" ||\n    options.initialNumItems < 0\n  ) {\n    throw new Error(\n      `\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`\n    );\n  }\n\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        name,\n        args,\n        id,\n        maxQueryIndex: 0,\n        queries: {\n          0: {\n            name,\n            args: {\n              ...args,\n              paginationOpts: {\n                numItems: options.initialNumItems,\n                cursor: null,\n                id,\n              },\n            },\n          },\n        },\n      };\n    };\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid rerendering if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(convexToJson(args)), name, options.initialNumItems]);\n\n  const [state, setState] = useState<{\n    name: string;\n    args: Record<string, Value>;\n    id: number;\n    maxQueryIndex: number;\n    queries: RequestForQueries;\n  }>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  if (\n    name !== state.name ||\n    JSON.stringify(convexToJson(args)) !==\n      JSON.stringify(convexToJson(state.args))\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n\n  const resultsObject = useQueriesGeneric(currState.queries);\n\n  const [results, maybeLastResult]: [\n    Value[],\n    undefined | PaginationResult<Value>\n  ] = useMemo(() => {\n    let currResult = undefined;\n\n    const allItems = [];\n    for (let i = 0; i <= currState.maxQueryIndex; i++) {\n      currResult = resultsObject[i];\n      if (currResult === undefined) {\n        break;\n      }\n\n      if (currResult instanceof Error) {\n        if (\n          currResult.message.includes(\"InvalidCursor\") ||\n          currResult.message.includes(\"QueryScannedTooManyDocuments\") ||\n          currResult.message.includes(\"ArrayTooLong\")\n        ) {\n          // `usePaginatedQueryGeneric` handles a few types of query errors:\n\n          // 1. InvalidCursor: If the cursor is invalid, probably the paginated\n          // database query was data-dependent and changed underneath us. The\n          // cursor in the params or journal no longer matches the current\n          // database query.\n          // 2. QueryScannedTooManyDocuments: Likely so many elements were\n          // added to a single page they hit our limit.\n          // 3. Array length is too long: Likely so many elements were added\n          // to a single page they hit our limit.\n\n          // In both cases we want to restart pagination to throw away all our\n          // existing cursors.\n          setState(createInitialState);\n          return [[], undefined];\n        } else {\n          throw currResult;\n        }\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [resultsObject, currState.maxQueryIndex, createInitialState]);\n\n  const statusAndLoadMore = useMemo(() => {\n    if (maybeLastResult === undefined) {\n      return {\n        status: \"LoadingMore\",\n        loadMore: undefined,\n      } as const;\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        loadMore: undefined,\n      } as const;\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      loadMore: (numItems: number) => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState(prevState => {\n            const maxQueryIndex = prevState.maxQueryIndex + 1;\n            const queries = { ...prevState.queries };\n            queries[maxQueryIndex] = {\n              name: prevState.name,\n              args: {\n                ...prevState.args,\n                paginationOpts: {\n                  numItems,\n                  cursor: continueCursor,\n                  id: prevState.id,\n                },\n              },\n            };\n            return {\n              ...prevState,\n              maxQueryIndex,\n              queries,\n            };\n          });\n        }\n      },\n    } as const;\n  }, [maybeLastResult]);\n\n  return {\n    results,\n    ...statusAndLoadMore,\n  };\n}\n\nlet paginationId = 0;\n/**\n * Generate a new, unique ID for a pagination session.\n *\n * Every usage of {@link usePaginatedQueryGeneric} puts a unique ID into the\n * query function arguments as a \"cache-buster\". This serves two purposes:\n *\n * 1. All calls to {@link usePaginatedQueryGeneric} have independent query\n * journals.\n *\n * Every time we start a new pagination session, we'll load the first page of\n * results and receive a fresh journal. Without the ID, we might instead reuse\n * a query subscription already present in our client. This isn't desirable\n * because the existing query function result may have grown or shrunk from the\n * requested `initialNumItems`.\n *\n * 2. We can restart the pagination session on some types of errors.\n *\n * Sometimes we want to restart pagination from the beginning if we hit an error.\n * Similar to (1), we'd like to ensure that this new session actually requests\n * its first page from the server and doesn't reuse a query result already\n * present in the client that may have hit the error.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * The result of calling the {@link usePaginatedQueryGeneric} hook.\n *\n * This includes:\n * 1. `results` - An array of the currently loaded results.\n * 2. `status` - The status of the pagination. The possible statuses are:\n *   - \"CanLoadMore\": This query may have more items to fetch. Call `loadMore` to\n *   fetch another page.\n *   - \"LoadingMore\": We're currently loading another page of results.\n *   - \"Exhausted\": We've paginated to the end of the list.\n * 3. `loadMore` A callback to fetch more results. This will be `undefined`\n * unless the status is \"CanLoadMore\".\n *\n * @public\n */\nexport type UsePaginatedQueryResult<T> = {\n  results: T[];\n} & (\n  | {\n      status: \"CanLoadMore\";\n      loadMore: (numItems: number) => void;\n    }\n  | {\n      status: \"LoadingMore\";\n      loadMore: undefined;\n    }\n  | {\n      status: \"Exhausted\";\n      loadMore: undefined;\n    }\n);\n\n/**\n * A query function that is usable with {@link usePaginatedQueryGeneric}.\n *\n * The function's argument must be an object with a\n * `paginationOpts` property of type {@link server.PaginationOptions}.\n *\n * The function must return a {@link server.PaginationResult}.\n *\n * @public\n */\nexport type PaginatedQueryFunction<Args extends object, ReturnType> = (\n  args: {\n    paginationOpts: PaginationOptions;\n  } & Args\n) => PaginationResult<ReturnType>;\n\n/**\n * Test whether a function matches the signature of {@link PaginatedQueryFunction}.\n */\ntype IsPaginatedQueryFunction<Func extends ConvexFunction> =\n  Parameters<Func> extends [\n    args: {\n      paginationOpts: PaginationOptions;\n    }\n  ]\n    ? ReturnType<Func> extends PaginationResult<any>\n      ? true\n      : false\n    : false;\n\n/**\n * The names of the paginated query functions in a Convex API.\n *\n * These are normal query functions that match {@link PaginatedQueryFunction}.\n *\n * @public\n */\nexport type PaginatedQueryNames<API extends GenericAPI> = {\n  [QueryName in PublicQueryNames<API>]: IsPaginatedQueryFunction<\n    NamedQuery<API, QueryName>\n  > extends true\n    ? QueryName\n    : never;\n}[PublicQueryNames<API>];\n\n/**\n * The type of the arguments to a {@link PaginatedQueryFunction}.\n *\n * This type includes the entire arguments object except the `paginationOpts`\n * property.\n *\n * @public\n */\nexport type PaginatedQueryArgs<Query extends PaginatedQueryFunction<any, any>> =\n  Expand<BetterOmit<Parameters<Query>[0], \"paginationOpts\">>;\n\n/**\n * The return type of a {@link PaginatedQueryFunction}.\n *\n * This is the type of the inner document or object within the\n * {@link server.PaginationResult} that a paginated query function returns.\n *\n * @public\n */\nexport type PaginatedQueryReturnType<\n  Query extends PaginatedQueryFunction<any, any>\n> = Query extends PaginatedQueryFunction<any, infer ReturnType>\n  ? ReturnType\n  : never;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link usePaginatedQueryGeneric} a type specific to your API.\n *\n * @public\n */\nexport type UsePaginatedQueryForAPI<API extends GenericAPI> = <\n  Name extends PaginatedQueryNames<API>\n>(\n  name: Name,\n  args: PaginatedQueryArgs<NamedQuery<API, Name>>,\n  options: { initialNumItems: number }\n) => UsePaginatedQueryResult<PaginatedQueryReturnType<NamedQuery<API, Name>>>;\n\n/**\n * Optimistically update the values in a paginated list.\n *\n * This optimistic update is designed to be used to update data loaded with\n * {@link usePaginatedQueryGeneric}. It updates the list by applying\n * `updateValue` to each element of the list across all of the loaded pages.\n *\n * This will only apply to queries with a matching names and arguments.\n *\n * Example usage:\n * ```ts\n * const myMutation = useMutation(\"myMutationName\")\n * .withOptimisticUpdate((localStore, mutationArg) => {\n *\n *   // Optimistically update the document with ID `mutationArg`\n *   // to have an additional property.\n *\n *   optimisticallyUpdateValueInPaginatedQuery(\n *     localStore,\n *     \"paginatedQueryName\",\n *     {},\n *     currentValue => {\n *       if (mutationArg.equals(currentValue._id)) {\n *         return {\n *           ...currentValue,\n *           \"newProperty\": \"newValue\",\n *         };\n *       }\n *       return currentValue;\n *     }\n *   );\n *\n * });\n * ```\n *\n * @param name - The name of the paginated query function.\n * @param args - The arguments object to the query function, excluding the\n * `paginationOpts` property.\n * @param updateValue - A function to produce the new values.\n *\n * @public\n */\nexport function optimisticallyUpdateValueInPaginatedQuery<\n  API extends GenericAPI,\n  Name extends PaginatedQueryNames<API>\n>(\n  localStore: OptimisticLocalStore<API>,\n  name: Name,\n  args: PaginatedQueryArgs<NamedQuery<API, Name>>,\n  updateValue: (\n    currentValue: PaginatedQueryReturnType<NamedQuery<API, Name>>\n  ) => PaginatedQueryReturnType<NamedQuery<API, Name>>\n): void {\n  // TODO: This should really be sorted JSON or an `equals` method\n  // so that the order of properties in sets, maps, and objects doesn't break\n  // our comparison.\n  const expectedArgs = JSON.stringify(convexToJson(args as Value));\n\n  for (const query of localStore.getAllQueries(name)) {\n    if (query.value !== undefined) {\n      const { paginationOpts: _, ...innerArgs } = query.args as {\n        paginationOpts: PaginationOptions;\n      };\n      if (JSON.stringify(convexToJson(innerArgs as Value)) === expectedArgs) {\n        const value = query.value;\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          Array.isArray(value.page)\n        ) {\n          localStore.setQuery(name, query.args, {\n            ...value,\n            page: value.page.map(updateValue),\n          });\n        }\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
