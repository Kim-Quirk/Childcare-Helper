"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var schema_exports = {};
__export(schema_exports, {
  SchemaDefinition: () => SchemaDefinition,
  TableDefinition: () => TableDefinition,
  defineSchema: () => defineSchema,
  defineTable: () => defineTable
});
module.exports = __toCommonJS(schema_exports);
var import_validator = require("../values/validator.js");
class TableDefinition {
  constructor(documentType) {
    this.indexes = [];
    this.searchIndexes = [];
    this.documentType = documentType;
  }
  index(name, fields) {
    this.indexes.push({ indexDescriptor: name, fields });
    return this;
  }
  searchIndex(name, indexConfig) {
    this.searchIndexes.push({
      indexDescriptor: name,
      searchField: indexConfig.searchField,
      filterFields: indexConfig.filterFields || []
    });
    return this;
  }
  export() {
    return {
      indexes: this.indexes,
      searchIndexes: this.searchIndexes,
      documentType: this.documentType.json
    };
  }
}
function defineTable(documentSchema) {
  if (documentSchema instanceof import_validator.Validator) {
    return new TableDefinition(documentSchema);
  } else {
    return new TableDefinition(import_validator.v.object(documentSchema));
  }
}
class SchemaDefinition {
  constructor(tables, options) {
    this.tables = tables;
    this.schemaValidation = options?.schemaValidation === void 0 ? true : options.schemaValidation;
  }
  export() {
    return JSON.stringify({
      tables: Object.entries(this.tables).map(([tableName, definition]) => {
        const { indexes, searchIndexes, documentType } = definition.export();
        return {
          tableName,
          indexes,
          searchIndexes,
          documentType
        };
      }),
      schemaValidation: this.schemaValidation
    });
  }
}
function defineSchema(schema, options) {
  return new SchemaDefinition(schema, options);
}
//# sourceMappingURL=index.js.map
