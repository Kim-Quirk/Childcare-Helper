{
  "version": 3,
  "sources": ["../../../src/browser/http_client.ts"],
  "sourcesContent": ["import {\n  GenericAPI,\n  NamedAction,\n  NamedMutation,\n  NamedQuery,\n  OptionalRestArgs,\n  PublicActionNames,\n  PublicMutationNames,\n  PublicQueryNames,\n} from \"../api/index.js\";\nimport { parseArgs, STATUS_CODE_UDF_FAILED } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport { convexToJson, jsonToConvex } from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\n\n/** In browsers, Node.js 18, Deno, etc. `fetch` is a global function */\ntype WindowFetch = typeof window.fetch;\n\nconst fetch: WindowFetch =\n  globalThis.fetch ||\n  ((...args) =>\n    import(\"node-fetch\").then(({ default: fetch }) =>\n      (fetch as unknown as WindowFetch)(...args)\n    ));\n\n/**\n * A Convex client that runs queries and mutations over HTTP.\n *\n * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive\n * webapps.\n *\n * If you're building a React app, consider using\n * {@link react.ConvexReactClient} instead.\n *\n *\n * @public\n */\nexport class ConvexHttpClient<API extends GenericAPI> {\n  private readonly address: string;\n  private auth?: string;\n  private debug: boolean;\n  constructor(address: string) {\n    this.address = `${address}/api`;\n    this.debug = true;\n  }\n\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl(): string {\n    return this.address;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value: string) {\n    this.auth = value;\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = undefined;\n  }\n\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  /**\n   * Execute a Convex query function.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  async query<Name extends PublicQueryNames<API>>(\n    name: Name,\n    ...args: OptionalRestArgs<NamedQuery<API, Name>>\n  ): Promise<ReturnType<NamedQuery<API, Name>>> {\n    const queryArgs = parseArgs(args[0]);\n    const body = JSON.stringify({\n      path: name,\n      args: [convexToJson(queryArgs)],\n      debug: this.debug,\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const response = await fetch(`${this.address}/query`, {\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n\n    for (const line of respJSON.logLines ?? []) {\n      logToConsole(\"info\", \"query\", name, line);\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        // Validate that the response is a valid Convex value.\n        return jsonToConvex(respJSON.value) as Awaited<\n          ReturnType<NamedQuery<API, Name>>\n        >;\n      case \"error\":\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex mutation function.\n   *\n   * @param name - The name of the mutation.\n   * @param args - The arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation<Name extends PublicMutationNames<API>>(\n    name: Name,\n    ...args: OptionalRestArgs<NamedMutation<API, Name>>\n  ): Promise<ReturnType<NamedMutation<API, Name>>> {\n    const mutationArgs = parseArgs(args[0]);\n    const body = JSON.stringify({\n      path: name,\n      args: [convexToJson(mutationArgs)],\n      debug: this.debug,\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const response = await fetch(`${this.address}/mutation`, {\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    for (const line of respJSON.logLines ?? []) {\n      logToConsole(\"info\", \"mutation\", name, line);\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        // Validate that the response is a valid Convex value.\n        return jsonToConvex(respJSON.value) as Awaited<\n          ReturnType<NamedMutation<API, Name>>\n        >;\n      case \"error\":\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex action function.\n   *\n   * @param name - The name of the action.\n   * @param args - The arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action<Name extends PublicActionNames<API>>(\n    name: Name,\n    ...args: OptionalRestArgs<NamedAction<API, Name>>\n  ): Promise<ReturnType<NamedAction<API, Name>>> {\n    const actionArgs = parseArgs(args[0]);\n    const body = JSON.stringify({\n      path: name,\n      args: [convexToJson(actionArgs)],\n      debug: this.debug,\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const response = await fetch(`${this.address}/action`, {\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    for (const line of respJSON.logLines ?? []) {\n      logToConsole(\"info\", \"action\", name, line);\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        // Validate that the response is a valid Convex value.\n        return jsonToConvex(respJSON.value) as Awaited<\n          ReturnType<NamedAction<API, Name>>\n        >;\n      case \"error\":\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["fetch"]
}
