"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var client_exports = {};
__export(client_exports, {
  BaseConvexClient: () => BaseConvexClient
});
module.exports = __toCommonJS(client_exports);
var import__ = require("../../index.js");
var import_values = require("../../values/index.js");
var import_logging = require("../logging.js");
var import_local_state = require("./local_state.js");
var import_request_manager = require("./request_manager.js");
var import_optimistic_updates_impl = require("./optimistic_updates_impl.js");
var import_remote_query_set = require("./remote_query_set.js");
var import_udf_path_utils = require("./udf_path_utils.js");
var import_web_socket_manager = require("./web_socket_manager.js");
var import_session = require("./session.js");
var import_authentication_manager = require("./authentication_manager.js");
var import_authentication_manager2 = require("./authentication_manager.js");
var import_metrics = require("./metrics.js");
var import_common = require("../../common/index.js");
class BaseConvexClient {
  constructor(address, onTransition, options) {
    this.fetchToken = null;
    this.refetchTokenTimeoutId = null;
    this.firstMessageReceived = false;
    this.mark = (name) => {
      if (this.debug) {
        (0, import_metrics.mark)(name, this.sessionId);
      }
    };
    if (typeof address === "object") {
      throw new Error(
        "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly."
      );
    }
    options = { ...options };
    let webSocketConstructor = options.webSocketConstructor;
    if (!webSocketConstructor && typeof WebSocket === "undefined") {
      throw new Error(
        "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient"
      );
    }
    webSocketConstructor = webSocketConstructor || WebSocket;
    this.verbose = options.verbose ?? false;
    this.debug = options.reportDebugInfoToConvex ?? false;
    this.address = address;
    const i = address.search("://");
    if (i === -1) {
      throw new Error("Provided address was not an absolute URL.");
    }
    const origin = address.substring(i + 3);
    const protocol = address.substring(0, i);
    let wsProtocol;
    if (protocol === "http") {
      wsProtocol = "ws";
    } else if (protocol === "https") {
      wsProtocol = "wss";
    } else {
      throw new Error(`Unknown parent protocol ${protocol}`);
    }
    const wsUri = `${wsProtocol}://${origin}/api/${import__.version}/sync`;
    this.state = new import_local_state.LocalSyncState();
    this.remoteQuerySet = new import_remote_query_set.RemoteQuerySet(
      (queryId) => this.state.queryPath(queryId)
    );
    this.requestManager = new import_request_manager.RequestManager();
    this.authenticationManager = new import_authentication_manager.AuthenticationManager(this.state, {
      authenticate: (token) => {
        const message = this.state.setAuth(token);
        this.webSocketManager.sendMessage(message);
      },
      pauseSocket: () => this.webSocketManager.pause(),
      resumeSocket: () => this.webSocketManager.resume(),
      clearAuth: () => {
        this.clearAuth();
      },
      verbose: this.verbose
    });
    this.optimisticQueryResults = new import_optimistic_updates_impl.OptimisticQueryResults();
    this.onTransition = onTransition;
    this.nextRequestId = 0;
    this.sessionId = (0, import_session.newSessionId)();
    const { unsavedChangesWarning } = options;
    if (typeof window === "undefined" || typeof window.addEventListener === "undefined") {
      if (unsavedChangesWarning === true) {
        throw new Error(
          "unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options."
        );
      }
    } else if (unsavedChangesWarning !== false) {
      window.addEventListener("beforeunload", (e) => {
        if (this.requestManager.hasIncompleteRequests()) {
          e.preventDefault();
          const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
          (e || window.event).returnValue = confirmationMessage;
          return confirmationMessage;
        }
      });
    }
    this.webSocketManager = new import_web_socket_manager.WebSocketManager(
      wsUri,
      (reconnectMetadata) => {
        this.mark("convexWebSocketOpen");
        this.webSocketManager.sendMessage({
          ...reconnectMetadata,
          type: "Connect",
          sessionId: this.sessionId
        });
        this.remoteQuerySet = new import_remote_query_set.RemoteQuerySet(
          (queryId) => this.state.queryPath(queryId)
        );
        const [querySetModification, authModification] = this.state.restart();
        if (authModification) {
          this.webSocketManager.sendMessage(authModification);
        }
        this.webSocketManager.sendMessage(querySetModification);
        for (const message of this.requestManager.restart()) {
          this.webSocketManager.sendMessage(message);
        }
      },
      (serverMessage) => {
        if (!this.firstMessageReceived) {
          this.firstMessageReceived = true;
          this.mark("convexFirstMessageReceived");
          this.reportMarks();
        }
        switch (serverMessage.type) {
          case "Transition": {
            this.authenticationManager.onTransition(serverMessage);
            this.remoteQuerySet.transition(serverMessage);
            this.state.saveQueryJournals(serverMessage);
            const completedRequests = this.requestManager.removeCompleted(
              this.remoteQuerySet.timestamp()
            );
            this.notifyOnQueryResultChanges(completedRequests);
            break;
          }
          case "MutationResponse": {
            const completedMutationId = this.requestManager.onResponse(serverMessage);
            if (completedMutationId) {
              this.notifyOnQueryResultChanges(/* @__PURE__ */ new Set([completedMutationId]));
            }
            break;
          }
          case "ActionResponse": {
            this.requestManager.onResponse(serverMessage);
            break;
          }
          case "AuthError": {
            this.authenticationManager.onAuthError(serverMessage);
            break;
          }
          case "FatalError": {
            const error = (0, import_logging.logFatalError)(serverMessage.error);
            void this.webSocketManager.stop();
            throw error;
          }
          case "Ping":
            break;
          default: {
            const _typeCheck = serverMessage;
          }
        }
      },
      webSocketConstructor,
      this.verbose
    );
    this.mark("convexClientConstructed");
  }
  notifyOnQueryResultChanges(completedRequest) {
    const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
    const queryTokenToValue = /* @__PURE__ */ new Map();
    for (const [queryId, result] of remoteQueryResults) {
      const queryToken = this.state.queryToken(queryId);
      if (queryToken !== null) {
        const query = {
          result,
          udfPath: this.state.queryPath(queryId),
          args: this.state.queryArgs(queryId)
        };
        queryTokenToValue.set(queryToken, query);
      }
    }
    this.onTransition(
      this.optimisticQueryResults.ingestQueryResultsFromServer(
        queryTokenToValue,
        completedRequest
      )
    );
  }
  setAuth(fetchToken, onChange) {
    void this.authenticationManager.setConfig(fetchToken, onChange);
  }
  hasAuth() {
    return this.state.hasAuth();
  }
  setAdminAuth(value, fakeUserIdentity) {
    const message = this.state.setAdminAuth(value, fakeUserIdentity);
    this.webSocketManager.sendMessage(message);
  }
  clearAuth() {
    const message = this.state.clearAuth();
    this.webSocketManager.sendMessage(message);
  }
  subscribe(name, args, options) {
    const argsObject = (0, import_common.parseArgs)(args);
    const { modification, queryToken, unsubscribe } = this.state.subscribe(
      name,
      argsObject,
      options?.journal
    );
    if (modification !== null) {
      this.webSocketManager.sendMessage(modification);
    }
    return {
      queryToken,
      unsubscribe: () => {
        const modification2 = unsubscribe();
        if (modification2) {
          this.webSocketManager.sendMessage(modification2);
        }
      }
    };
  }
  localQueryResult(udfPath, args) {
    const argsObject = (0, import_common.parseArgs)(args);
    const queryToken = (0, import_udf_path_utils.serializePathAndArgs)(udfPath, argsObject);
    return this.optimisticQueryResults.queryResult(queryToken);
  }
  localQueryLogs(udfPath, args) {
    const argsObject = (0, import_common.parseArgs)(args);
    const queryToken = (0, import_udf_path_utils.serializePathAndArgs)(udfPath, argsObject);
    return this.optimisticQueryResults.queryLogs(queryToken);
  }
  queryJournal(name, args) {
    const argsObject = (0, import_common.parseArgs)(args);
    const queryToken = (0, import_udf_path_utils.serializePathAndArgs)(name, argsObject);
    return this.state.queryJournal(queryToken);
  }
  connectionState() {
    return {
      hasInflightRequests: this.requestManager.hasInflightRequests(),
      isWebSocketConnected: this.webSocketManager.socketState() === "ready",
      timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest()
    };
  }
  async mutation(name, args, options) {
    const result = await this.mutationInternal(name, args, options);
    if (!result.success) {
      throw (0, import_logging.createError)("mutation", name, result.errorMessage);
    }
    return result.value;
  }
  async mutationInternal(udfPath, args, options) {
    const mutationArgs = (0, import_common.parseArgs)(args);
    this.tryReportLongDisconnect();
    const requestId = this.nextRequestId;
    this.nextRequestId++;
    if (options !== void 0) {
      const optimisticUpdate = options.optimisticUpdate;
      if (optimisticUpdate !== void 0) {
        const wrappedUpdate = (localQueryStore) => {
          optimisticUpdate(localQueryStore, mutationArgs);
        };
        const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(
          wrappedUpdate,
          requestId
        );
        this.onTransition(changedQueries);
      }
    }
    const message = {
      type: "Mutation",
      requestId,
      udfPath,
      args: [(0, import_values.convexToJson)(mutationArgs)]
    };
    const mightBeSent = this.webSocketManager.sendMessage(message);
    return this.requestManager.request(message, mightBeSent);
  }
  async action(name, args) {
    const result = await this.actionInternal(name, args);
    if (!result.success) {
      throw (0, import_logging.createError)("action", name, result.errorMessage);
    }
    return result.value;
  }
  async actionInternal(udfPath, args) {
    const actionArgs = (0, import_common.parseArgs)(args);
    const requestId = this.nextRequestId;
    this.nextRequestId++;
    this.tryReportLongDisconnect();
    const message = {
      type: "Action",
      requestId,
      udfPath,
      args: [(0, import_values.convexToJson)(actionArgs)]
    };
    const mightBeSent = this.webSocketManager.sendMessage(message);
    return this.requestManager.request(message, mightBeSent);
  }
  async close() {
    this.authenticationManager.stop();
    return this.webSocketManager.stop();
  }
  _logVerbose(message) {
    if (this.verbose) {
      console.debug(`${new Date().toISOString()} ${message}`);
    }
  }
  reportMarks() {
    if (this.debug) {
      const report = (0, import_metrics.getMarksReport)(this.sessionId);
      this.webSocketManager.sendMessage({
        type: "Event",
        eventType: "ClientConnect",
        event: report
      });
    }
  }
  tryReportLongDisconnect() {
    if (!this.debug) {
      return;
    }
    const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;
    if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {
      return;
    }
    const endpoint = `${this.address}/api/debug_event`;
    fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${import__.version}`
      },
      body: JSON.stringify({ event: "LongWebsocketDisconnect" })
    }).then((response) => {
      if (!response.ok) {
        console.warn(
          "Analytics request failed with response:",
          response.body
        );
      }
    }).catch((error) => {
      console.warn("Analytics response failed with error:", error);
    });
  }
}
//# sourceMappingURL=client.js.map
