"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bundler_exports = {};
__export(bundler_exports, {
  BundleError: () => BundleError,
  RecordingFs: () => import_fs2.RecordingFs,
  actionsDir: () => actionsDir,
  bundle: () => bundle,
  bundleSchema: () => bundleSchema,
  entryPoints: () => entryPoints,
  entryPointsByEnvironment: () => entryPointsByEnvironment,
  mustBeIsolate: () => mustBeIsolate,
  nodeFs: () => import_fs2.nodeFs,
  useNodeDirectiveRegex: () => useNodeDirectiveRegex,
  walkDir: () => walkDir
});
module.exports = __toCommonJS(bundler_exports);
var import_parser = require("@babel/parser");
var import_path = __toESM(require("path"));
var import_chalk = __toESM(require("chalk"));
var import_esbuild = __toESM(require("esbuild"));
var import_wasm = require("./wasm.js");
var import_fs2 = require("./fs.js");
const actionsDir = "actions";
function* walkDir(fs, dirPath) {
  for (const dirEntry of fs.listDir(dirPath)) {
    const childPath = import_path.default.join(dirPath, dirEntry.name);
    if (dirEntry.isDirectory()) {
      yield { isDir: true, path: childPath };
      yield* walkDir(fs, childPath);
    } else if (dirEntry.isFile()) {
      yield { isDir: false, path: childPath };
    }
  }
}
class BundleError extends Error {
}
async function doEsbuild(fs, dir, entryPoints2, generateSourceMaps, platform, chunksFolder) {
  try {
    const result = await import_esbuild.default.build({
      entryPoints: entryPoints2,
      bundle: true,
      platform,
      format: "esm",
      target: "esnext",
      outdir: "out",
      outbase: dir,
      plugins: [import_wasm.wasmPlugin],
      write: false,
      sourcemap: generateSourceMaps,
      splitting: true,
      chunkNames: import_path.default.join(chunksFolder, "[hash]"),
      treeShaking: true,
      minify: false,
      keepNames: true,
      metafile: true
    });
    for (const [relPath, input] of Object.entries(result.metafile.inputs)) {
      if (relPath.indexOf("(disabled):") !== -1 || relPath.startsWith("wasm-binary:") || relPath.startsWith("wasm-stub:")) {
        continue;
      }
      const absPath = import_path.default.resolve(relPath);
      const st = fs.stat(absPath);
      if (st.size !== input.bytes) {
        throw new Error(
          `Bundled file ${absPath} changed right after esbuild invocation`
        );
      }
      fs.registerPath(absPath, st);
    }
    return result;
  } catch (err) {
    throw new BundleError(`esbuild failed: ${err.toString()}`);
  }
}
async function bundle(fs, dir, entryPoints2, generateSourceMaps, platform, chunksFolder = "_deps") {
  const result = await doEsbuild(
    fs,
    dir,
    entryPoints2,
    generateSourceMaps,
    platform,
    chunksFolder
  );
  if (result.errors.length) {
    for (const error of result.errors) {
      console.log(import_chalk.default.red(`esbuild error: ${error.text}`));
    }
    throw new BundleError("esbuild failed");
  }
  for (const warning of result.warnings) {
    console.log(import_chalk.default.yellow(`esbuild warning: ${warning.text}`));
  }
  const sourceMaps = /* @__PURE__ */ new Map();
  const modules = [];
  const environment = platform === "node" ? "node" : "isolate";
  for (const outputFile of result.outputFiles) {
    const relPath = import_path.default.relative(import_path.default.normalize("out"), outputFile.path);
    if (import_path.default.extname(relPath) === ".map") {
      sourceMaps.set(relPath, outputFile.text);
      continue;
    }
    const posixRelPath = relPath.split(import_path.default.sep).join(import_path.default.posix.sep);
    modules.push({ path: posixRelPath, source: outputFile.text, environment });
  }
  for (const module2 of modules) {
    const sourceMapPath = module2.path + ".map";
    const sourceMap = sourceMaps.get(sourceMapPath);
    if (sourceMap) {
      module2.sourceMap = sourceMap;
    }
  }
  return modules;
}
async function bundleSchema(fs, dir) {
  return bundle(fs, dir, [import_path.default.resolve(dir, "schema.ts")], true, "browser");
}
async function entryPoints(fs, dir, verbose) {
  const entryPoints2 = [];
  for (const { isDir, path: fpath } of walkDir(fs, dir)) {
    if (isDir) {
      continue;
    }
    const relPath = import_path.default.relative(dir, fpath);
    const base = import_path.default.parse(fpath).base;
    const log = (line) => {
      if (verbose) {
        console.log(line);
      }
    };
    if (relPath.startsWith("_deps" + import_path.default.sep)) {
      throw new Error(
        `The path "${fpath}" is within the "_deps" directory, which is reserved for dependencies. Please move your code to another directory.`
      );
    } else if (relPath.startsWith("_generated" + import_path.default.sep)) {
      log(import_chalk.default.yellow(`Skipping ${fpath}`));
    } else if (base.startsWith(".")) {
      log(import_chalk.default.yellow(`Skipping dotfile ${fpath}`));
    } else if (base === "README.md") {
      log(import_chalk.default.yellow(`Skipping ${fpath}`));
    } else if (base === "_generated.ts") {
      log(import_chalk.default.yellow(`Skipping ${fpath}`));
    } else if (base === "schema.ts") {
      log(import_chalk.default.yellow(`Skipping ${fpath}`));
    } else if (base.includes(".test.")) {
      log(import_chalk.default.yellow(`Skipping ${fpath}`));
    } else if (base === "tsconfig.json") {
      log(import_chalk.default.yellow(`Skipping ${fpath}`));
    } else if (relPath.includes(" ")) {
      log(import_chalk.default.yellow(`Skipping ${relPath} because it contains a space`));
    } else if (base.endsWith(".d.ts")) {
      log(import_chalk.default.yellow(`Skipping ${fpath} declaration file`));
    } else {
      log(import_chalk.default.green(`Preparing ${fpath}`));
      entryPoints2.push(fpath);
    }
  }
  return entryPoints2;
}
const useNodeDirectiveRegex = /^\s*("|')use node("|');?\s*$/;
function hasUseNodeDirective(fs, fpath, verbose) {
  const source = fs.readUtf8File(fpath);
  if (source.indexOf("use node") === -1) {
    return false;
  }
  try {
    const ast = (0, import_parser.parse)(source, {
      sourceType: "module",
      plugins: ["jsx", "typescript"]
    });
    return ast.program.directives.map((d) => d.value.value).includes("use node");
  } catch (error) {
    let lineMatches = false;
    for (const line of source.split("\n")) {
      if (line.match(useNodeDirectiveRegex)) {
        lineMatches = true;
        break;
      }
    }
    if (verbose) {
      console.warn(
        `Failed to parse ${fpath}. Use node is set to ${lineMatches} based on regex. Parse error: ${error.toString()}.`
      );
    }
    return lineMatches;
  }
}
function mustBeIsolate(relPath) {
  return ["http", "crons", "schema"].includes(relPath.replace(/\.[^/.]+$/, ""));
}
function determineEnvironment(fs, dir, fpath, verbose) {
  const relPath = import_path.default.relative(dir, fpath);
  const useNodeDirectiveFound = hasUseNodeDirective(fs, fpath, verbose);
  if (useNodeDirectiveFound) {
    if (mustBeIsolate(relPath)) {
      throw new BundleError(
        `"use node" directive is not allowed for ${relPath}.`
      );
    }
    return "node";
  }
  const actionsPrefix = actionsDir + import_path.default.sep;
  if (relPath.startsWith(actionsPrefix)) {
    throw new Error(
      `${relPath} is in /actions subfolder but has no "use node"; directive. You can now define actions in any folder and indicate they should run in node by adding "use node" directive. /actions is a deprecated way to choose Node.js environment, and we require "use node" for all files within that folder to avoid unexpected errors during the migration. See https://docs.convex.dev/functions/actions for more details`
    );
  }
  return "isolate";
}
async function entryPointsByEnvironment(fs, dir, verbose) {
  const isolate = [];
  const node = [];
  for (const entryPoint of await entryPoints(fs, dir, verbose)) {
    const environment = determineEnvironment(fs, dir, entryPoint, verbose);
    if (environment === "node") {
      node.push(entryPoint);
    } else {
      isolate.push(entryPoint);
    }
  }
  return { isolate, node };
}
//# sourceMappingURL=index.js.map
