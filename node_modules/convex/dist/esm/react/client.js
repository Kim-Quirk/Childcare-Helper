"use strict";
import {
  BaseConvexClient
} from "../browser/index.js";
import React, { useContext, useMemo } from "react";
import { convexToJson } from "../values/index.js";
import ReactDOM from "react-dom";
import { useSubscription } from "./use_subscription.js";
import { parseArgs } from "../common/index.js";
if (typeof React === "undefined") {
  throw new Error("Required dependency 'react' not found");
}
if (typeof ReactDOM === "undefined") {
  throw new Error("Required dependency 'react-dom' not found");
}
export function createMutation(name, client, update) {
  function mutation(args) {
    assertNotAccidentalArgument(args);
    return client.mutation(name, args, { optimisticUpdate: update });
  }
  mutation.withOptimisticUpdate = function withOptimisticUpdate(optimisticUpdate) {
    if (update !== void 0) {
      throw new Error(
        `Already specified optimistic update for mutation ${name}`
      );
    }
    return createMutation(name, client, optimisticUpdate);
  };
  return mutation;
}
function createAction(name, client) {
  return function(args) {
    return client.action(name, args);
  };
}
export class ConvexReactClient {
  constructor(address, options) {
    this.closed = false;
    if (typeof address !== "string") {
      throw new Error(
        "ConvexReactClient requires a URL like 'https://happy-otter-123.convex.cloud'."
      );
    }
    if (!address.includes("://")) {
      throw new Error("Provided address was not an absolute URL.");
    }
    this.address = address;
    this.listeners = /* @__PURE__ */ new Map();
    this.options = { ...options };
  }
  get sync() {
    if (this.closed) {
      throw new Error("ConvexReactClient has already been closed.");
    }
    if (this.cachedSync) {
      return this.cachedSync;
    }
    this.cachedSync = new BaseConvexClient(
      this.address,
      (updatedQueries) => this.transition(updatedQueries),
      this.options
    );
    if (this.adminAuth) {
      this.cachedSync.setAdminAuth(this.adminAuth, this.fakeUserIdentity);
    }
    return this.cachedSync;
  }
  setAuth(fetchToken, onChange) {
    if (typeof fetchToken === "string") {
      throw new Error(
        "Passing a string to ConvexReactClient.setAuth is no longer supported, please upgrade to passing in an async function to handle reauthentication."
      );
    }
    this.sync.setAuth(
      fetchToken,
      onChange ?? (() => {
      })
    );
  }
  clearAuth() {
    this.sync.clearAuth();
  }
  setAdminAuth(token, identity) {
    this.adminAuth = token;
    this.fakeUserIdentity = identity;
    if (this.closed) {
      throw new Error("ConvexReactClient has already been closed.");
    }
    if (this.cachedSync) {
      this.sync.setAdminAuth(token, identity);
    }
  }
  watchQuery(name, ...argsAndOptions) {
    const [args, options] = argsAndOptions;
    return {
      onUpdate: (callback) => {
        const { queryToken, unsubscribe } = this.sync.subscribe(
          name,
          args,
          options
        );
        const currentListeners = this.listeners.get(queryToken);
        if (currentListeners !== void 0) {
          currentListeners.add(callback);
        } else {
          this.listeners.set(queryToken, /* @__PURE__ */ new Set([callback]));
        }
        return () => {
          if (this.closed) {
            return;
          }
          const currentListeners2 = this.listeners.get(queryToken);
          currentListeners2.delete(callback);
          if (currentListeners2.size === 0) {
            this.listeners.delete(queryToken);
          }
          unsubscribe();
        };
      },
      localQueryResult: () => {
        if (this.cachedSync) {
          return this.cachedSync.localQueryResult(name, args);
        }
        return void 0;
      },
      localQueryLogs: () => {
        if (this.cachedSync) {
          return this.cachedSync.localQueryLogs(name, args);
        }
        return void 0;
      },
      journal: () => {
        if (this.cachedSync) {
          return this.cachedSync.queryJournal(name, args);
        }
        return void 0;
      }
    };
  }
  mutation(name, ...argsAndOptions) {
    const [args, options] = argsAndOptions;
    return this.sync.mutation(name, args, options);
  }
  action(name, ...args) {
    return this.sync.action(name, ...args);
  }
  connectionState() {
    return this.sync.connectionState();
  }
  async close() {
    this.closed = true;
    this.listeners = /* @__PURE__ */ new Map();
    if (this.cachedSync) {
      const sync = this.cachedSync;
      this.cachedSync = void 0;
      await sync.close();
    }
  }
  transition(updatedQueries) {
    ReactDOM.unstable_batchedUpdates(() => {
      for (const queryToken of updatedQueries) {
        const callbacks = this.listeners.get(queryToken);
        if (callbacks) {
          for (const callback of callbacks) {
            callback();
          }
        }
      }
    });
  }
}
const ConvexContext = React.createContext(
  void 0
);
export function useConvexGeneric() {
  return useContext(ConvexContext);
}
export const ConvexProvider = ({ client, children }) => {
  return React.createElement(
    ConvexContext.Provider,
    { value: client },
    children
  );
};
export function useQueryGeneric(name, args, _options) {
  const convex = useContext(ConvexContext);
  if (convex === void 0) {
    throw new Error(
      "Could not find Convex client! `useQuery` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
    );
  }
  const queryArgs = parseArgs(args);
  const subscription = useMemo(
    () => {
      const watch = convex.watchQuery(name, queryArgs);
      return {
        getCurrentValue: () => watch.localQueryResult(),
        subscribe: (callback) => watch.onUpdate(callback)
      };
    },
    [name, convex, JSON.stringify(convexToJson(queryArgs))]
  );
  const queryResult = useSubscription(subscription);
  return queryResult;
}
export function useMutationGeneric(name) {
  const convex = useContext(ConvexContext);
  if (convex === void 0) {
    throw new Error(
      "Could not find Convex client! `useMutation` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
    );
  }
  return useMemo(() => createMutation(name, convex), [convex, name]);
}
export function useActionGeneric(name) {
  const convex = useContext(ConvexContext);
  if (convex === void 0) {
    throw new Error(
      "Could not find Convex client! `useAction` must be used in the React component tree under `ConvexProvider`. Did you forget it? See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app"
    );
  }
  return useMemo(() => createAction(name, convex), [convex, name]);
}
function assertNotAccidentalArgument(value) {
  if (typeof value === "object" && value !== null && "bubbles" in value && "persist" in value && "isDefaultPrevented" in value) {
    throw new Error(
      `Convex function called with SyntheticEvent object. Did you use a Convex function as an event handler directly? Event handlers like onClick receive an event object as their first argument. These SyntheticEvent objects are not valid Convex values. Try wrapping the function like \`const handler = () => myMutation();\` and using \`handler\` in the event handler.`
    );
  }
}
//# sourceMappingURL=client.js.map
