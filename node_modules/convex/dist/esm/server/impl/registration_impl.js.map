{
  "version": 3,
  "sources": ["../../../../src/server/impl/registration_impl.ts"],
  "sourcesContent": ["import { GenericAPI } from \"../../api/index.js\";\nimport {\n  convexToJson,\n  jsonToConvex,\n  v,\n  Validator,\n} from \"../../values/index.js\";\nimport { GenericDataModel } from \"../data_model.js\";\nimport {\n  ActionCtx,\n  MutationCtx,\n  RegisteredAction,\n  PublicHttpAction,\n  RegisteredMutation,\n  RegisteredQuery,\n  QueryCtx,\n  FunctionArgs,\n  MutationBuilder,\n  QueryBuilder,\n  ActionBuilder,\n} from \"../registration.js\";\nimport { setupActionCalls } from \"./actions_impl.js\";\nimport { setupAuth } from \"./authentication_impl.js\";\nimport { setupReader, setupWriter } from \"./database_impl.js\";\nimport { QueryImpl, QueryInitializerImpl } from \"./query_impl.js\";\nimport {\n  setupActionScheduler,\n  setupMutationScheduler,\n} from \"./scheduler_impl.js\";\nimport {\n  setupStorageActionWriter,\n  setupStorageReader,\n  setupStorageWriter,\n} from \"./storage_impl.js\";\n\nasync function invokeMutation<\n  F extends (\n    ctx: MutationCtx<GenericDataModel, GenericAPI>,\n    ...args: any\n  ) => any\n>(func: F, argsStr: string) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since queries are only running in V8.\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const mutationCtx = {\n    db: setupWriter(),\n    auth: setupAuth(requestId),\n    storage: setupStorageWriter(requestId),\n    scheduler: setupMutationScheduler(),\n  };\n  const result = await Promise.resolve(func(mutationCtx, ...(args as any)));\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\nfunction validateReturnValue(v: any) {\n  if (v instanceof QueryInitializerImpl || v instanceof QueryImpl) {\n    throw new Error(\n      \"Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.\"\n    );\n  }\n}\n\ntype FunctionDefinition =\n  | ((ctx: any, args: FunctionArgs) => any)\n  | {\n      args?: Record<string, Validator<any, boolean>>;\n      handler: (ctx: any, args: FunctionArgs) => any;\n    };\n\nfunction exportArgs(functionDefinition: FunctionDefinition) {\n  return () => {\n    let args = v.any();\n    if (\n      typeof functionDefinition === \"object\" &&\n      functionDefinition.args !== undefined\n    ) {\n      args = v.object(functionDefinition.args);\n    }\n    return JSON.stringify(args.json);\n  };\n}\n/**\n * Define a mutation in this Convex app's public API.\n *\n * This function will be allowed to modify your Convex database and will be accessible from the client.\n *\n * If you're using code generation, use the `mutation` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const mutationGeneric: MutationBuilder<any, any, \"public\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredMutation<\"public\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  func.isRegistered = true;\n  func.isMutation = true;\n  func.isPublic = true;\n  func.invokeMutation = argsStr => invokeMutation(func, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\n/**\n * Define a mutation that is only accessible from other Convex functions (but not from the client).\n *\n * This function will be allowed to modify your Convex database. It will not be accessible from the client.\n *\n * If you're using code generation, use the `internalMutation` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const internalMutationGeneric: MutationBuilder<any, any, \"internal\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredMutation<\"internal\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  func.isRegistered = true;\n  func.isMutation = true;\n  func.isInternal = true;\n  func.invokeMutation = argsStr => invokeMutation(func, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\nasync function invokeQuery<\n  F extends (ctx: QueryCtx<GenericDataModel>, ...args: any) => any\n>(func: F, argsStr: string) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since queries are only running in V8.\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const queryCtx = {\n    db: setupReader(),\n    auth: setupAuth(requestId),\n    storage: setupStorageReader(requestId),\n  };\n  const result = await Promise.resolve(func(queryCtx, ...(args as any)));\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define a query in this Convex app's public API.\n *\n * This function will be allowed to read your Convex database and will be accessible from the client.\n *\n * If you're using code generation, use the `query` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const queryGeneric: QueryBuilder<any, \"public\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredQuery<\"public\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  func.isRegistered = true;\n  func.isQuery = true;\n  func.isPublic = true;\n  func.invokeQuery = argsStr => invokeQuery(func, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\n/**\n * Define a query that is only accessible from other Convex functions (but not from the client).\n *\n * This function will be allowed to read from your Convex database. It will not be accessible from the client.\n *\n * If you're using code generation, use the `internalQuery` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const internalQueryGeneric: QueryBuilder<any, \"internal\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredQuery<\"internal\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  func.isRegistered = true;\n  func.isQuery = true;\n  func.isInternal = true;\n  func.invokeQuery = argsStr => invokeQuery(func as any, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\nasync function invokeAction<\n  API extends GenericAPI,\n  F extends (ctx: ActionCtx<API>, ...args: any) => any\n>(func: F, requestId: string, argsStr: string) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    scheduler: setupActionScheduler(requestId),\n    storage: setupStorageActionWriter(requestId),\n  };\n  const result = await Promise.resolve(func(ctx, ...(args as any)));\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define an action in this Convex app's public API.\n *\n * If you're using code generation, use the `action` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The function. It receives a {@link ActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const actionGeneric: ActionBuilder<any, \"public\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredAction<\"public\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  func.isRegistered = true;\n  func.isAction = true;\n  func.isPublic = true;\n  func.invokeAction = (requestId, argsStr) =>\n    invokeAction(func, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\n/**\n * Define an action that is only accessible from other Convex functions (but not from the client).\n *\n * If you're using code generation, use the `internalAction` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The function. It receives a {@link ActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const internalActionGeneric: ActionBuilder<any, \"internal\"> = (\n  functionDefinition: FunctionDefinition\n) => {\n  const func = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as RegisteredAction<\"internal\", any, any>;\n\n  // Helpful runtime check that functions are only be registered once\n  if (func.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  func.isRegistered = true;\n  func.isAction = true;\n  func.isInternal = true;\n  func.invokeAction = (requestId, argsStr) =>\n    invokeAction(func, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  return func;\n};\n\nasync function invokeHttpAction<\n  API extends GenericAPI,\n  F extends (ctx: ActionCtx<API>, request: Request) => any\n>(func: F, request: Request) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since http endpoints are only running in V8.\n  const requestId = \"\";\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    storage: setupStorageActionWriter(requestId),\n    scheduler: setupActionScheduler(requestId),\n  };\n  return await Promise.resolve(func(ctx, request));\n}\n\n/**\n * Define a Convex HTTP action.\n *\n * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object\n * as its second.\n * @returns The wrapped function. Route a URL path to this function in `convex/http.js`.\n *\n * @public\n */\nexport const httpActionGeneric = <API extends GenericAPI>(\n  func: (ctx: ActionCtx<API>, request: Request) => Promise<Response>\n): PublicHttpAction => {\n  const q = func as unknown as PublicHttpAction;\n  // Helpful runtime check that functions are only be registered once\n  if (q.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  q.isRegistered = true;\n  q.isHttp = true;\n  q.invokeHttpAction = request => invokeHttpAction(func as any, request);\n  return q;\n};\n"],
  "mappings": "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",
  "names": ["v"]
}
