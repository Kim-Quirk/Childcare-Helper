"use strict";
import { version } from "../../index.js";
import { convexToJson } from "../../values/index.js";
import { createError, logFatalError } from "../logging.js";
import { LocalSyncState } from "./local_state.js";
import { RequestManager } from "./request_manager.js";
import {
  OptimisticQueryResults
} from "./optimistic_updates_impl.js";
import { RemoteQuerySet } from "./remote_query_set.js";
import { serializePathAndArgs } from "./udf_path_utils.js";
import { WebSocketManager } from "./web_socket_manager.js";
import { newSessionId } from "./session.js";
import {
  AuthenticationManager
} from "./authentication_manager.js";
export {} from "./authentication_manager.js";
import { getMarksReport, mark } from "./metrics.js";
import { parseArgs } from "../../common/index.js";
export class BaseConvexClient {
  constructor(address, onTransition, options) {
    this.fetchToken = null;
    this.refetchTokenTimeoutId = null;
    this.firstMessageReceived = false;
    this.mark = (name) => {
      if (this.debug) {
        mark(name, this.sessionId);
      }
    };
    if (typeof address === "object") {
      throw new Error(
        "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly."
      );
    }
    options = { ...options };
    let webSocketConstructor = options.webSocketConstructor;
    if (!webSocketConstructor && typeof WebSocket === "undefined") {
      throw new Error(
        "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient"
      );
    }
    webSocketConstructor = webSocketConstructor || WebSocket;
    this.verbose = options.verbose ?? false;
    this.debug = options.reportDebugInfoToConvex ?? false;
    this.address = address;
    const i = address.search("://");
    if (i === -1) {
      throw new Error("Provided address was not an absolute URL.");
    }
    const origin = address.substring(i + 3);
    const protocol = address.substring(0, i);
    let wsProtocol;
    if (protocol === "http") {
      wsProtocol = "ws";
    } else if (protocol === "https") {
      wsProtocol = "wss";
    } else {
      throw new Error(`Unknown parent protocol ${protocol}`);
    }
    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;
    this.state = new LocalSyncState();
    this.remoteQuerySet = new RemoteQuerySet(
      (queryId) => this.state.queryPath(queryId)
    );
    this.requestManager = new RequestManager();
    this.authenticationManager = new AuthenticationManager(this.state, {
      authenticate: (token) => {
        const message = this.state.setAuth(token);
        this.webSocketManager.sendMessage(message);
      },
      pauseSocket: () => this.webSocketManager.pause(),
      resumeSocket: () => this.webSocketManager.resume(),
      clearAuth: () => {
        this.clearAuth();
      },
      verbose: this.verbose
    });
    this.optimisticQueryResults = new OptimisticQueryResults();
    this.onTransition = onTransition;
    this.nextRequestId = 0;
    this.sessionId = newSessionId();
    const { unsavedChangesWarning } = options;
    if (typeof window === "undefined" || typeof window.addEventListener === "undefined") {
      if (unsavedChangesWarning === true) {
        throw new Error(
          "unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options."
        );
      }
    } else if (unsavedChangesWarning !== false) {
      window.addEventListener("beforeunload", (e) => {
        if (this.requestManager.hasIncompleteRequests()) {
          e.preventDefault();
          const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
          (e || window.event).returnValue = confirmationMessage;
          return confirmationMessage;
        }
      });
    }
    this.webSocketManager = new WebSocketManager(
      wsUri,
      (reconnectMetadata) => {
        this.mark("convexWebSocketOpen");
        this.webSocketManager.sendMessage({
          ...reconnectMetadata,
          type: "Connect",
          sessionId: this.sessionId
        });
        this.remoteQuerySet = new RemoteQuerySet(
          (queryId) => this.state.queryPath(queryId)
        );
        const [querySetModification, authModification] = this.state.restart();
        if (authModification) {
          this.webSocketManager.sendMessage(authModification);
        }
        this.webSocketManager.sendMessage(querySetModification);
        for (const message of this.requestManager.restart()) {
          this.webSocketManager.sendMessage(message);
        }
      },
      (serverMessage) => {
        if (!this.firstMessageReceived) {
          this.firstMessageReceived = true;
          this.mark("convexFirstMessageReceived");
          this.reportMarks();
        }
        switch (serverMessage.type) {
          case "Transition": {
            this.authenticationManager.onTransition(serverMessage);
            this.remoteQuerySet.transition(serverMessage);
            this.state.saveQueryJournals(serverMessage);
            const completedRequests = this.requestManager.removeCompleted(
              this.remoteQuerySet.timestamp()
            );
            this.notifyOnQueryResultChanges(completedRequests);
            break;
          }
          case "MutationResponse": {
            const completedMutationId = this.requestManager.onResponse(serverMessage);
            if (completedMutationId) {
              this.notifyOnQueryResultChanges(/* @__PURE__ */ new Set([completedMutationId]));
            }
            break;
          }
          case "ActionResponse": {
            this.requestManager.onResponse(serverMessage);
            break;
          }
          case "AuthError": {
            this.authenticationManager.onAuthError(serverMessage);
            break;
          }
          case "FatalError": {
            const error = logFatalError(serverMessage.error);
            void this.webSocketManager.stop();
            throw error;
          }
          case "Ping":
            break;
          default: {
            const _typeCheck = serverMessage;
          }
        }
      },
      webSocketConstructor,
      this.verbose
    );
    this.mark("convexClientConstructed");
  }
  notifyOnQueryResultChanges(completedRequest) {
    const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
    const queryTokenToValue = /* @__PURE__ */ new Map();
    for (const [queryId, result] of remoteQueryResults) {
      const queryToken = this.state.queryToken(queryId);
      if (queryToken !== null) {
        const query = {
          result,
          udfPath: this.state.queryPath(queryId),
          args: this.state.queryArgs(queryId)
        };
        queryTokenToValue.set(queryToken, query);
      }
    }
    this.onTransition(
      this.optimisticQueryResults.ingestQueryResultsFromServer(
        queryTokenToValue,
        completedRequest
      )
    );
  }
  setAuth(fetchToken, onChange) {
    void this.authenticationManager.setConfig(fetchToken, onChange);
  }
  hasAuth() {
    return this.state.hasAuth();
  }
  setAdminAuth(value, fakeUserIdentity) {
    const message = this.state.setAdminAuth(value, fakeUserIdentity);
    this.webSocketManager.sendMessage(message);
  }
  clearAuth() {
    const message = this.state.clearAuth();
    this.webSocketManager.sendMessage(message);
  }
  subscribe(name, args, options) {
    const argsObject = parseArgs(args);
    const { modification, queryToken, unsubscribe } = this.state.subscribe(
      name,
      argsObject,
      options?.journal
    );
    if (modification !== null) {
      this.webSocketManager.sendMessage(modification);
    }
    return {
      queryToken,
      unsubscribe: () => {
        const modification2 = unsubscribe();
        if (modification2) {
          this.webSocketManager.sendMessage(modification2);
        }
      }
    };
  }
  localQueryResult(udfPath, args) {
    const argsObject = parseArgs(args);
    const queryToken = serializePathAndArgs(udfPath, argsObject);
    return this.optimisticQueryResults.queryResult(queryToken);
  }
  localQueryLogs(udfPath, args) {
    const argsObject = parseArgs(args);
    const queryToken = serializePathAndArgs(udfPath, argsObject);
    return this.optimisticQueryResults.queryLogs(queryToken);
  }
  queryJournal(name, args) {
    const argsObject = parseArgs(args);
    const queryToken = serializePathAndArgs(name, argsObject);
    return this.state.queryJournal(queryToken);
  }
  connectionState() {
    return {
      hasInflightRequests: this.requestManager.hasInflightRequests(),
      isWebSocketConnected: this.webSocketManager.socketState() === "ready",
      timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest()
    };
  }
  async mutation(name, args, options) {
    const result = await this.mutationInternal(name, args, options);
    if (!result.success) {
      throw createError("mutation", name, result.errorMessage);
    }
    return result.value;
  }
  async mutationInternal(udfPath, args, options) {
    const mutationArgs = parseArgs(args);
    this.tryReportLongDisconnect();
    const requestId = this.nextRequestId;
    this.nextRequestId++;
    if (options !== void 0) {
      const optimisticUpdate = options.optimisticUpdate;
      if (optimisticUpdate !== void 0) {
        const wrappedUpdate = (localQueryStore) => {
          optimisticUpdate(localQueryStore, mutationArgs);
        };
        const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(
          wrappedUpdate,
          requestId
        );
        this.onTransition(changedQueries);
      }
    }
    const message = {
      type: "Mutation",
      requestId,
      udfPath,
      args: [convexToJson(mutationArgs)]
    };
    const mightBeSent = this.webSocketManager.sendMessage(message);
    return this.requestManager.request(message, mightBeSent);
  }
  async action(name, args) {
    const result = await this.actionInternal(name, args);
    if (!result.success) {
      throw createError("action", name, result.errorMessage);
    }
    return result.value;
  }
  async actionInternal(udfPath, args) {
    const actionArgs = parseArgs(args);
    const requestId = this.nextRequestId;
    this.nextRequestId++;
    this.tryReportLongDisconnect();
    const message = {
      type: "Action",
      requestId,
      udfPath,
      args: [convexToJson(actionArgs)]
    };
    const mightBeSent = this.webSocketManager.sendMessage(message);
    return this.requestManager.request(message, mightBeSent);
  }
  async close() {
    this.authenticationManager.stop();
    return this.webSocketManager.stop();
  }
  _logVerbose(message) {
    if (this.verbose) {
      console.debug(`${new Date().toISOString()} ${message}`);
    }
  }
  reportMarks() {
    if (this.debug) {
      const report = getMarksReport(this.sessionId);
      this.webSocketManager.sendMessage({
        type: "Event",
        eventType: "ClientConnect",
        event: report
      });
    }
  }
  tryReportLongDisconnect() {
    if (!this.debug) {
      return;
    }
    const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;
    if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {
      return;
    }
    const endpoint = `${this.address}/api/debug_event`;
    fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Convex-Client": `npm-${version}`
      },
      body: JSON.stringify({ event: "LongWebsocketDisconnect" })
    }).then((response) => {
      if (!response.ok) {
        console.warn(
          "Analytics request failed with response:",
          response.body
        );
      }
    }).catch((error) => {
      console.warn("Analytics response failed with error:", error);
    });
  }
}
//# sourceMappingURL=client.js.map
